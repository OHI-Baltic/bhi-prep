---
title: "Clean Water (CW) - Eutrophication (EUT) Subgoal Data Preparation"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: hide
---

<br>

```{r eut preamble prep including spatial functions and files, message = FALSE, warning = FALSE, include = FALSE}
loc <- here::here("prep", "CW", "eutrophication")

source(here::here("R", "setup.R"))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, results = "hide", fig.width = 9.5)

bkgd_path <- here::here("supplement", "goal_summaries", "EUT.Rmd")
data_path <- here::here("data", "CW", "eutrophication", version_year, "eut_data.rmd")
refs_path <- file.path(loc, "eut_references.Rmd")

dir_B <- file.path(dirname(dir_prep), "bhi-data", "BHI 2.0")
dir_rawdata <- file.path(dir_B, "Goals", "CW", "EUT")

# dir_lookup <- file.path(dir_prep, "supplement", "lookup_tabs")
basin_lookup <- file.path(dir_prep, "supplement", "lookup_tabs", "rgns_complete.csv") %>% 
  read_csv() %>%
  select(bhi_id = region_id, subbasin, rgn_nam = region_name, HELCOM_ID = helcom_id) %>%
  mutate(
    subbasin = as.character(subbasin),
    rgn_nam = as.character(rgn_nam)
  )
# add_lookup_table <- read.csv(file.path(dir_lookup, "basin_add_lookup_table.csv"), sep = ",")
# source(here::here("R", "spatial.R"))
# regions_shape()
# buffer_sf <- st_read(
#   file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile_25km_buffer"), 
#   "BHI_shapefile_25km_buffer"
# )
# bhi_rgns_simple <- rmapshaper::ms_simplify(input = BHI_rgns_shp) %>% sf::st_as_sf()

fullpal <- c(
  RColorBrewer::brewer.pal(8, "Dark2"),
  RColorBrewer::brewer.pal(9, "Set1")
)
```

## 1. Background {-}

```{r Background, child = bkgd_path, results = "asis", echo = FALSE}
```

<br/>

## 2. Data {-}

This prep document is used to generate and explore the following data layers:

- `cw_eut_status_bhi2019.csv` 
- `cw_eut_trend_bhi2019.csv` 

These are saved to the `layers/v2019` folder. Saved to `data/GOAL/v2019/intermediate` are intermediate datasets: `secchi_merged_rawdata.csv`, `ox_merged_rawdata.csv` and `DATASETINTEMED3.csv`. All these are derived from or informed by the raw datasets from ICES, SMHI and Baltic Nest database.

<br>

```{r Data, child = data_path, results = "asis", echo = FALSE}
```

<br/>

## 3. Prep: Wrangling & Derivations, Checks/Evaluation, Gapfilling {-}

```{r load eut datasets, echo = FALSE, include = FALSE}
## secchi, oxygen, and chlorophyl a  datasets
combined_secchi_rawdata <- read_csv(file.path(dirname(data_path), "intermediate", "secchi_merged_rawdata.csv"))
combined_ox_rawdata <- read_csv(file.path(dirname(data_path), "intermediate", "ox_merged_rawdata.csv"))
chla_rawdata <- read_csv(file.path(dirname(data_path), "intermediate", "chla_rawdata.csv"))

## eutrophication thresholds data
eut_thresholds_values <- read.delim(file.path(dir_rawdata, "eut_threshold_values.csv"), sep = ";")
eut_thresholds <- eut_thresholds_values %>% 
  rename(
    basin = Assessment.units, 
    winter_DIN = DIN.._mol.l.1., 
    winter_DIP = DIP.._mol.l.1., 
    summer_chla = Chla.._g.l.1., 
    summer_secchi = Water.clarity..m., 
    oxyg_debt = O2..mg.l.1.
  ) %>% 
  select(basin, winter_DIN, winter_DIP, summer_chla, summer_secchi, oxyg_debt) %>% 
  mutate(
    basin = str_replace_all(basin,"_",""),
    basin = str_trim(basin, side = "right"),
    ## ‘N’ means that the indicator is not applicable there, so it will be replaced as NA
    oxyg_debt = str_replace(oxyg_debt, "N", " "),
    oxyg_debt = as.numeric(oxyg_debt)
  ) 
```
<br/>

### 3.1 Secchi Indicator {-}

#### 3.1.1 Match BHI regions {-}

```{r assign BHI regions to Secchi data, echo = TRUE, message = FALSE, warning = FALSE}
## before assigning bhi basins to secchi data, run this function first, to load required shapefiles:
source(here::here("R", "spatial.R"))
regions_shape(sp_dir = file.path(dirname(dir_B), "Shapefiles"))

combined_secchi_rawdata <- combined_secchi_rawdata %>% 
  rename(lat = Latitude, lon = Longitude)

## import offshore helcom codes
offshore_codes <- sf::st_read(file.path(
  dir_B, "Goals", "CW", "EUT", 
  "HELCOM_subbasins_with_coastal_and_offshore_division_2018",
  "HELCOM_subbasins_with_coastal_and_offshore_division_2018.shp"
))
offshore_codes <- offshore_codes %>% 
  filter(country == "Opensea") %>% 
  rename(Subbasin = level_2, helcom_coastal_code = coastal) %>% 
  select(-level_3, -country)  

## assign helcom offshore codes
secchi_rgns_w_offshore <- sf::st_as_sf(
  combined_secchi_rawdata,
  crs = 4326,
  coords = c("lon","lat"),
  remove = FALSE) %>%  
  sf::st_join(sf::st_transform(offshore_codes, 4326)) %>% 
  sf::st_drop_geometry() %>% 
  select(-Subbasin, -HELCOM_ID)

## assign bhi basins to secchi data 
secchi_rgns_shp <- join_rgns_info(
  secchi_rgns_w_offshore, helcomID_col = "helcom_id", country_col = "country", 
  latlon_vars = c("^lat", "^lon"), return_spatial = FALSE, 
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefile"), 
  buffer_shp = NULL
) 
secchi_rgns <- secchi_rgns_shp %>% 
  ## select summer months (June-September) and Years >= 2000  
  filter(month == "6" | month == "7" | month == "8" | month == "9") %>% 
  filter(year >= 2000) 

```
<br/>

**Remove coastal observations**

```{r remove coastal data points,  results = "show", echo = TRUE, fig.width = 16, fig.height = 8}
## Select only data with coastal code "0"  
dim(secchi_rgns) # 45479   

## Do any observations have NA for coast_code
secchi_rgns %>% 
  filter(is.na(helcom_coastal_code) & is.na(BHI_ID)) %>% 
  dim() # 4803  

secchi_rgns %>% 
  filter(is.na(helcom_coastal_code) & !is.na(BHI_ID)) %>% 
  dim() # 32661

## 617 observations with no coast_code or BHI_ID
loc_no_coastcode_nobhi <- secchi_rgns %>% 
  filter(is.na(helcom_coastal_code) & is.na(BHI_ID))%>%
  dplyr::select(lat, lon)%>%
  distinct()
## check locations
library(ggmap)
map <- get_map(location = c(8.5, 53, 32, 67.5))
no_coastal_or_bhi_id <- ggmap(map) + 
  geom_point(aes(x = lon, y = lat), data = loc_no_coastcode_nobhi, size = 2) +
  labs(x = NULL, y = NULL)
## these locations are very coastal or outside of the Baltic Sea

## observations with NA for the coast_code but have BHI_ID
loc_no_coastcode_bhi <- secchi_rgns %>% 
  filter(is.na(helcom_coastal_code) & !is.na(BHI_ID)) %>% 
  dplyr::select(lat, lon) %>%
  distinct()
no_coastal_id <- ggmap(map) + 
  geom_point(aes(x = lon, y = lat), data = loc_no_coastcode_bhi, size = 2, alpha = 0.3) +
  labs(x = NULL, y = NULL)
## many coastal location

## Filter data that are only offshore, coast_code == 0
secchi_offshore <- filter(secchi_rgns, helcom_coastal_code == 0) 
dim(secchi_offshore) # 8015
secchi_offshore_spatial <- ggmap(map) + 
  geom_point(aes(x = lon, y = lat), data = secchi_offshore, colour = "tomato", size = 2, alpha = 0.3) +
  labs(x = NULL, y = NULL)
## This is a substantial reduction in the number of observations

gridExtra::grid.arrange(no_coastal_or_bhi_id, no_coastal_id, secchi_offshore_spatial, nrow = 1)
```
<br/>

**Spatial Visualization of Secchi data**
```{r secchi timeseries yearly and monthly by bhi regions and subbasins, results = "show", echo = TRUE, fig.width = 12.5}
## Plot by BHI regions and year
plot_secchi_bhi_ts <- ggplot(secchi_offshore) + 
  geom_point(aes(year, secchi_m, color = supplier), size = 0.3, alpha = 0.4) +
  facet_wrap(
      c("Subbasin", "rgn_nam"), 
      labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
      scales = "free_y"
  ) +
  labs(x = NULL, y = "Secchi depth (m)", fill = "Data Source") +
  ggtitle("Yearly Secchi by BHI regions")

## Month boxplots, by BHI region
plot_secchi_bhi_box <- ggplot(mutate(secchi_offshore, month = as.factor(month))) + 
  # geom_point(aes(month, secchi_m, colour = supplier), size = 0.3, alpha = 0.4) +
  geom_boxplot(aes(month, secchi_m, fill = supplier), outlier.size = 0.3, alpha = 0.6) +
  facet_wrap(
      c("Subbasin", "rgn_nam"), 
      labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
      scales = "free_y"
  ) +
  labs(x = "Month", y = "Secchi depth (m)", fill = "Data Source") +
  ggtitle("Monthly Secchi by BHI regions")

## Plot by subbasins and year
plot_secchi_basin_ts <- ggplot(secchi_offshore) + 
  geom_point(aes(year, secchi_m, colour = supplier), size = 0.3, alpha = 0.4) +
  # geom_point(aes(year, secchi_m), size = 0.3, alpha = 0.4) +
  facet_wrap(~Subbasin, scales ="free_y") +
  labs(x = NULL, y = "Secchi depth (m)") +
  ggtitle("Yearly Secchi by Subbasins")

## Month boxplots, by Subbasin region
plot_secchi_basin_box <- ggplot(mutate(secchi_offshore, month = as.factor(month))) + 
  # geom_point(aes(month, secchi_m, colour = supplier), size = 0.3, alpha = 0.4) +
  geom_boxplot(aes(month, secchi_m, fill = supplier), outlier.size = 0.3, alpha = 0.6) +
  facet_wrap(~Subbasin, scales = "free_y") +
  labs(x = "Month", y = "Secchi depth (m)", fill = "Data Source") +
  ggtitle("Monthly Secchi by Subbasins")

gridExtra::grid.arrange(plot_secchi_bhi_ts, plot_secchi_bhi_box, nrow = 1)
gridExtra::grid.arrange(plot_secchi_basin_ts, plot_secchi_basin_box, nrow = 1)
```

<br/>

#### 3.1.2 Mean secchi Calculation {-}

```{r calculate monthly mean secchi with target, results = "show", echo = TRUE, fig.width = 9.5}

for(r in c("Subbasin", "BHI_ID")){
  
  ## Calculate mean value for each summer month
  secchi_monthly_means <- secchi_offshore %>% 
    group_by(year, Subbasin, !!!syms(r)) %>%
    mutate(secchi_sd = round(sd(secchi_m, na.rm = TRUE), 1)) %>%
    group_by(year, month, secchi_sd, Subbasin, !!!syms(r)) %>%
    summarise(
      mean_secchi = round(mean(secchi_m, na.rm = TRUE), 1),
      n_pts = n()
    ) %>%
    ungroup() %>% 
    mutate(secchi_sd = ifelse(is.na(secchi_sd), 0, secchi_sd))
  # filter(secchi_monthly_means, is.na(mean_secchi)|is.nan(mean_secchi))
  ## what prop. of data where mean is based on <4 data points?
  # nrow(filter(secchi_monthly_means, n_pts <= 3))/nrow(secchi_monthly_means)
  
  ## Calculate summer mean secchi (subbasin)
  secchi_summer_months_mean <- secchi_monthly_means %>% 
    group_by(year, secchi_sd, Subbasin, !!!syms(r)) %>%
    summarise(
      mean_secchi = round(mean(mean_secchi, na.rm = TRUE), 1),
      n_pts = sum(n_pts)
    ) %>%
    mutate(
      secchi_min = mean_secchi-secchi_sd, 
      secchi_max = mean_secchi+secchi_sd
    ) %>% 
    ungroup() # in mean calculation some months have NA, ignore for that year's calculation
  
  secchi_summer_months_mean <- eut_thresholds %>% 
    select(Subbasin = basin, target_secchi = summer_secchi) %>% 
    right_join(secchi_summer_months_mean, by = "Subbasin")
  assign(paste0(str_to_lower(r), "_target_secchi"), secchi_summer_months_mean)
  
  ## Plot summer mean secchi
  secchimeansplot <- ggplot(secchi_summer_months_mean, aes(year, mean_secchi, group = 1)) + 
    geom_errorbar(
      aes(x = year, ymin = secchi_min, ymax = secchi_max), 
      alpha = 0.6,
      size = 0.2
    ) +
    geom_point() +
    geom_line() +
    geom_line(aes(y = target_secchi), colour = "tomato", size = 0.4) +
    facet_wrap(vars(!!!syms(r))) +
    scale_y_continuous(limits = c(0, 10)) +
    labs(x = NULL, y = "Secchi depth (m)") +
    ggtitle(sprintf("Mean Summer (June-Sept) Secchi by %s", r))
  assign(paste0("secchimeansplot", str_to_lower(r)), secchimeansplot)
}
```

<br>

**Plot summer secchi with target values indicated**

Horizontal lines are HELCOM target values 

```{r summer secchi with target, results = "show", echo = TRUE, fig.width = 9.5}
## adding onto/calling plots made in code chunk above
secchimeansplotsubbasin +
  ggtitle("Mean Summer Secchi against Target values (Offshore)") +
  theme(axis.text.x = element_text(
    colour = "grey20", 
    size = 8, angle = 90, 
    hjust = 0.5, vjust = 0.5, 
    face = "plain"
  ))
secchimeansplotbhi_id
```

<br>

#### 3.1.3 Status Calculation {-}

**Explore status years**

Only five basins have data for 2019, which will be used as the status year, eight basins have data for 2018 and four basins for 2017 and for these basins, their most recent year's data is used for current status calculations.

```{r what is the last year in secchi subbasin means dataframe, results = "hide"}
## get the last year of non-NA data
secchi_last_year <- subbasin_target_secchi %>%
  filter(!is.na(mean_secchi)) %>%
  group_by(Subbasin)%>%
  summarise(last_year = last(year)) %>%
  print(n = 15)

## which are not in 2019
filter(secchi_last_year, last_year < 2019)
```

**Status calculation with raw (non-modeled) mean summer secchi by basin** 

Status is calculated on the basin level and then applied to all regions. It is calculated in data prep for additional visualization and evaluation, but the final method of status calcualtion is also completed by the EUT function in functions.R of the relevant `bhi` repository assessment folder.

```{r eut secchi indicator status calculation, results = "show", echo = TRUE, fig.width = 9.5}

## Define constants for status and trend calculations
min_year <- 2010 # earliest year to use as a start for regr_length timeseries
regr_length <- 10 # number of years to use for regression
future_year <- 5 # the year at which we want the likely future status
min_regr_length <- 5 # min actual number of years with data to use for regression

## Basin data with target
subbasin_target_secchi <- filter(subbasin_target_secchi, year >= min_year)

## Calculate basin status as: basin_mean/basin_target, constraining values to 1 as maximum score
## joining to basin lookup to expand from subbasins to one row per BHI region
secchi_status_allyrs <- subbasin_target_secchi %>%
  rename(subbasin = Subbasin) %>% 
  mutate(status = pmin(1, mean_secchi/target_secchi)) %>%
  left_join(basin_lookup, by = "subbasin") %>% 
  mutate(region = paste(subbasin, rgn_nam, sep = ", "))

## select last year of data for status in each basin, this means status year differs by basin
secchi_status <- secchi_status_allyrs %>%
  group_by(subbasin) %>%
  filter(year == max(year)) %>% 
  mutate(status = round(status*100, 2)) %>% # keep decimal places, will round when combine eut indicators
  ungroup %>% 
  mutate(dimension = "status", indicator = "secchi") %>% 
  dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, dimension, score = status, region, indicator)

## Alternative status calculation: Status calculated using BHI region means
# secchi_status_allyrs <- bhi_id_target_secchi %>%
#   rename(subbasin = Subbasin, bhi_id = BHI_ID) %>%
#   mutate(status = pmin(1, mean_secchi/target_secchi)) %>%
#   left_join(basin_lookup, by = c("subbasin", "bhi_id")) %>%
#   mutate(region = paste(subbasin, rgn_nam, sep = ", "))
# secchi_status <- secchi_status_allyrs %>% 
#   group_by(bhi_id) %>%
#   filter(year == max(year)) %>%
#   mutate(status = round(status*100, 2)) %>% # keep decimal places, will round when combine eut indicators
#   ungroup %>%
#   mutate(dimension = "status", indicator = "secchi") %>%
#   dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, dimension, score = status, region, indicator)

## plot the status
## BHI region plots will look the same, as BHI status are taken from subbasin means
## unless alternative calculation is used, based on BHI region means rather than subbasin means
set.seed(2)
statuspal <- colorRampPalette(fullpal)(80)[sample(1:80, size = 18)]

ggplot(mutate(secchi_status, region = as.factor(region))) +
  geom_col(
    aes(region, score, fill = Subbasin),
    position = position_dodge(), 
    color = "grey", 
    alpha = 0.6,
    size = 0.2,
    show.legend = FALSE
  ) + 
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 10)) +
  scale_fill_manual(values = statuspal) +
  ggtitle("Secchi Status by Region")
```

#### 3.1.4 Calculate Trend {-}

```{r eut secchi indicator trend calculation, results = "hide", echo = TRUE}
## method 1, from the mean values ----

## basin trend
secchi_trend <- secchi_status_allyrs %>%
  group_by(subbasin) %>%
  ## calculate trend only if:
  ## have at least X yrs data (min_regr_length) in the last Y yrs (regr_length) of time series
  do(tail(., n = regr_length)) %>%  
  do({
    if(sum(!is.na(.$status)) >= min_regr_length){
      data.frame(trend_score = max(-1, min(1, coef(lm(status ~ year, .))["year"]*future_year)))
    } else {
      data.frame(trend_score = NA)
    }
  }) %>%
  ungroup() 

## method 2, from observation values ----

trendyrs <- min_year:(min_year + regr_length)
secchi_lm_estim <- secchi_offshore %>% 
  filter(year %in% trendyrs) %>% 
  group_by(Subbasin) %>% 
  mutate(trendcalc_nyrs = n_distinct(year), num_obs = n()) %>% 
  ## how much data is enough data to calculate short-term trends?
  filter((trendcalc_nyrs >= 6 & num_obs > 18)||trendcalc_nyrs > 8) %>%
  do(trend_mdl = lm(secchi_m ~ year, data = .)) %>%
  left_join(select(eut_thresholds, Subbasin = basin, threshold = summer_secchi)) %>% 
  mutate(
    ## change w.r.t. thresholds...
    expectedchange5yrs = coef(trend_mdl)["year"]*future_year,
    trend_score = -expectedchange5yrs/threshold,
    ## plotting variables, to visualize
    current = predict(trend_mdl, data.frame(year = max(trendyrs))),
    prj = predict(trend_mdl, data.frame(year = max(trendyrs) + future_year))
  )
ggplot(left_join(filter(secchi_offshore, year %in% trendyrs), select(secchi_lm_estim, Subbasin, current, prj))) +
  geom_point(aes(x = year, y = secchi_m), size = 0.2, alpha = 0.4) +
  geom_vline(xintercept = max(trendyrs), size = 0.2) +
  geom_vline(xintercept = max(trendyrs) + future_year, size = 0.2) +
  geom_hline(aes(yintercept = prj), color = "tomato") +
  geom_hline(aes(yintercept = current), alpha = 0.3) +
  facet_wrap(~Subbasin, scales = "free") +
  labs(x = NULL, y = NULL)

## basin trend
## alternative calculation, using relative change w.r.t. basin threshold
# secchi_trend <- secchi_lm_estim %>% 
#   rename(subbasin = Subbasin) %>% 
#   ungroup() %>% 
#   select(-trend_mdl) %>% 
#   group_by(subbasin) %>% 
#   summarize(trend = mean(trend_score, na.rm = TRUE) %>% round(3)) %>%
#   ## constrain trend values between one and negative one
#   mutate(trend = ifelse(-1 <= trend & trend <= 1, trend, trend*abs(1/trend)))

## trend score dataframe ----
## assign basin trend to BHI regions
secchi_trend <- secchi_trend %>% 
  right_join(basin_lookup, by = "subbasin") %>% 
  mutate(
    score = round(trend_score, 3),
    region = paste(subbasin, rgn_nam, sep = ", "),
    dimension = "trend",
    indicator = "secchi"
  ) %>%
  dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, region, dimension, score, indicator)
```

#### 3.1.5 Status and Trend Timeseries Plots {-}

**Basin status**

Basin status is initially a value between 0 and 1. Calculated for each year between 2000 and 2020.

```{r timeseries plot of basin eut secchi status, results = "show", echo = TRUE, fig.width = 9.5}
ggplot(secchi_status_allyrs) + 
  # geom_line((aes(year, status)), color = "grey80", alpha = 0.5) +
  # geom_smooth((aes(year, status)), color = "grey80", alpha = 0.1, size = 0.2) +
  geom_point((aes(year, status, size = n_pts)), color = "darkseagreen", alpha = 0.7, show.legend = FALSE) +
  facet_wrap(~subbasin) +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 8, angle = 90,
    hjust = 0.5, vjust = 0.5, face = "plain"
  )) +
  geom_hline(yintercept = 1) +
  labs(x = NULL, y = "Secchi Indicator Status\n")
```

**Plot region Status and Trend values**

Status values can range from 0-100 -- this is the status for the *most recent* year. In most cases this is 2019. No status or trend for 5 or 6 - these are The Sound, which had no data. 

```{r secchi status and trend for regions plot, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 4}
ggplot(rbind(secchi_status, secchi_trend)) + 
  geom_col(aes(region, score, fill = Subbasin), alpha = 0.5, show.legend = FALSE) +
  coord_flip() +
  facet_wrap(~dimension, scales = "free_x", nrow = 1) +
  labs(x = "BHI Region ID\n", y = NULL) +
  scale_fill_manual(values = statuspal)
```

<br>

### 3.2 Chl a Indicator {-}

#### 3.2.1 Match BHI regions {-}

```{r assign BHI regions to Secchi data, echo = TRUE, message = FALSE, warning = FALSE}
# before assigning bhi basins to secchi data, run this function first:
# library(stringr)
regions_shape(sp_dir = file.path(dirname(dir_B), "Shapefiles"))

# # nrow(filter(dataset, is.na(lat) | is.na(lon))) # check if any lat/lon have NAs

# # assign helcom offshore codes
chla_rgns_tmp <- chla %>% 
  filter(!is.na(lat) & !is.na(lon)) %>%
  sf::st_as_sf(
  crs = 4326,
  coords = c("lon", "lat"),
  remove = FALSE) %>%  
  sf::st_join(sf::st_transform(offshore_codes, 4326)) 
sf::st_geometry(chla_rgns_tmp) <- NULL

chla_rgns_tmp <- chla_rgns_tmp %>% 
  select(-Subbasin, -HELCOM_ID)

# assign bhi basins to chla data 
chla_rgns <- join_rgns_info(
  chla_rgns_tmp, helcomID_col = "helcom_id", country_col = "country", 
  latlon_vars = c("^lat", "^lon"), return_spatial = FALSE, 
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefile"), buffer_shp = NULL) %>% 
  # select summer months (June-September) and Years >= 2000  
  filter(month == "06" | month == "07" | month == "08" | month == "09") %>% 
  filter(year >=2000, 
         # filter surface layer (0 - 10 m depth)
         depth_m <= 10) 

##chla_rgns_shp <- join_rgns_info(
  ##chla_rawdata, helcomID_col = "helcom_id", country_col = "country", 
    ##                       latlon_vars = c("^lat", "^lon"), return_spatial = FALSE, 
      ##                     regions_shape(sp_dir = file.path(dirname(dir_B), "Shapefiles")), buffer_shp = NULL)

```
<br/>

**Distinguish coastal and offshore observations**
```{r  remove coastal data points, results = "hide"}
## Select only data with coastal code "0"  
dim(chla_rgns) # 58485  

## Do any observations have NA for coast_code
chla_rgns %>% 
  filter(is.na(helcom_coastal_code) & is.na(BHI_ID)) %>% 
  dim() # 15197

## observations with no coast_code or BHI_ID
loc_no_coastcode_nobhi <- chla_rgns %>% 
  filter(is.na(helcom_coastal_code) & is.na(BHI_ID))%>%
  dplyr::select(lat, lon)%>%
  distinct() # 790

## check locations
library('ggmap')
map <- get_map(location = c(8.5, 53, 32, 67.5))

ggmap(map) +
   geom_point(aes(x = lon, y = lat), data = loc_no_coastcode_nobhi, size = 0.5)
## these locations are only coastal or outside of the Baltic Sea

### observations with NA for the coast_code but have BHI_ID
loc_no_coastcode_bhi <- chla_rgns %>% 
  filter(is.na(helcom_coastal_code) & !is.na(BHI_ID)) %>% 
  dplyr::select(lat, lon) %>%
  distinct() # 2106

ggmap(map) +
   geom_point(aes(x = lon, y = lat), data = loc_no_coastcode_bhi, size = 0.7)
## seem all coastal stations

## Filter data that are only offshore, coast_code == 0
chla_offshore <- chla_rgns %>% 
  filter(helcom_coastal_code == 0)

dim(chla_offshore) # 9871

ggmap(map) +
   geom_point(aes(x = lon, y = lat, colour = supplier), data = chla_offshore, size = 0.8)
## This is a substantial reduction in the number of observations, especially in the northern Baltic 

## Check the difference with the complete dataset, including coast_code having NA
chla_coast <- chla_rgns %>% 
  filter(is.na(helcom_coastal_code) & !is.na(BHI_ID))

dim(chla_coast) # 33417

ggmap(map) +
   geom_point(aes(x = lon, y = lat, colour = supplier), data = chla_coast, size = 0.8)

## Look at the complete dataset, including both coastal and offshore locations
chla_whole <- chla_rgns %>% 
  filter(!is.na(BHI_ID))

dim(chla_whole) # 43278
# looks like there are some offshore locations in the Danish basins

ggmap(map) +
   geom_point(aes(x = lon, y = lat, colour = supplier), data = chla_whole, size = 0.8)

```
<br/>

#### 3.2.2 Chrorophyll a (all data) {-}

**Spatial Visualization of Chl a data (whole)**
```{r chl a timeseries yearly and monthly by bhi regions and subbasins, results = "show", echo = TRUE, fig.width = 12.5}
# Plot by bhi regions
# Dasets to be used: 'chla_whole', 'chla_coast' and 'chla_offshore'

ggplot(chla_coast) + 
  geom_point(aes(year, chla_ug_l), size = 0.3, alpha = 0.4) +
  facet_grid(cols = vars(rgn_nam), rows = vars(BHI_ID)) +
  labs(x = "Year", y = "Chl a (ug/L)") +
  ggtitle("Yearly Chl a by bhi regions")

ggplot(chla_coast) + 
  geom_point(aes(year, chla_ug_l, colour = supplier), size = 0.3, alpha = 0.4) +
  facet_wrap(~BHI_ID, scales ="free_y") +
  labs(x = "Year", y = "Chl a (ug/L)") +
  ggtitle("Yearly Chl a by bhi regions")

ggplot(chla_coast) + 
  geom_point(aes(month, chla_ug_l, colour = supplier), size = 0.3, alpha = 0.4) +
  facet_wrap(~BHI_ID, scales ="free_y") +
  labs(x = "Month", y = "Chl a (ug/L)") +
  ggtitle("Monthly Chl a by bhi regions")

# Plot by subbasins
ggplot(chla_coast) + 
  geom_point(aes(year, chla_ug_l), size = 0.3, alpha = 0.4) +
  facet_grid(cols = vars(Subbasin), rows = vars(rgn_nam)) +
  labs(x = "Year", y = "Chl a (ug/L)") +
  ggtitle("Yearly Chl a by subbasins")

ggplot(chla_offshore) + 
  geom_point(aes(year, chla_ug_l, colour = supplier), size = 0.3, alpha = 0.4) +
  facet_wrap(rgn_nam~Subbasin, scales ="free_y") +
  labs(x = "Year", y = "Chl a (ug/L)") +
  ggtitle("Yearly Chl a by subbasins (offshore)") +
  theme(axis.text.x = element_text(colour="grey20", size=8, angle=90, 
                                   hjust=.5, vjust=.5, face = "plain"))

ggplot(chla_coast) + 
  geom_point(aes(month, chla_ug_l, colour = supplier), size = 0.3, alpha = 0.4) +
  facet_wrap(~Subbasin, scales ="free_y") +
  labs(x = "Month", y = "Chl a (ug/L)") +
  ggtitle("Monthly Chl a by subbasins")

ggplot(chla_whole) + 
  geom_boxplot(aes(year, chla_ug_l), size = 0.3, alpha = 0.4) +
  facet_wrap(~Subbasin, scales ="free_y") +
  labs(x = "Year", y = "Chl a (ug/L)") +
  ggtitle("Yearly Chl a by subbasins") +
   theme(axis.text.x = element_text(colour="grey20", size=8, angle=90, 
                                   hjust=.5, vjust=.5, face = "plain"))

```

<br/>

**Mean Chl a Calculation**
```{r calculate monthly and summer mean chl a by subbasins}
# Calculate mean monthly value for each summer month (subbasin)
chla_subbasin_mean_months <- chla_whole %>% 
  dplyr::select(year, month, Subbasin, chla_ug_l)%>%
  group_by(year, month, Subbasin) %>%
  summarise(mean_chla = round(mean(chla_ug_l, na.rm=TRUE), 1)) %>%
  ungroup()

# Calculate summer mean chl a (subbasin)
chla_subbasin_mean_months_summer <- chla_subbasin_mean_months %>% 
  dplyr::select(year, Subbasin, mean_chla) %>%
  group_by(year, Subbasin) %>%
  summarise(mean_chla = round(mean(mean_chla, na.rm=TRUE), 1)) %>%
  filter(!is.na(Subbasin)) %>% 
  ungroup()  #in mean calculation all some months to have NA, ignore for that years calculation

```


```{r calculate monthly mean chl a by bhi regions, results = "show", echo = TRUE, fig.width = 9.5}
# Calculate mean monthly value for each summer month (bhi basins)
chla_bhi_mean_months <- chla_whole %>% 
  dplyr::select(year, month, BHI_ID, chla_ug_l)%>%
  group_by(year, month, BHI_ID) %>%
  summarise(mean_chla = round(mean(chla_ug_l, na.rm=TRUE), 1)) %>%
  ungroup()

# Calculate summer mean chl a (bhi basins)
chla_bhi_mean_months_summer <- chla_bhi_mean_months %>% 
  dplyr::select(year, BHI_ID, mean_chla) %>%
  group_by(year, BHI_ID) %>%
  summarise(mean_chla = round(mean(mean_chla, na.rm=TRUE), 1)) %>%
  ungroup()  #in mean calculation all some months to have NA, ignore for that years calculation

# Plot summer mean secchi
ggplot(chla_bhi_mean_months_summer, aes(year, mean_chla, group = 1)) + 
  geom_point() +
  geom_line() +
  facet_wrap(~BHI_ID)+
  scale_y_continuous(limits = c(0,10)) +
  ggtitle("Mean Summer Chl a")

## There might be some outlier to check (TO-DO)
```

<br/>

**Plot summer secchi with target values indicated**
Horizontal lines are HELCOM target values 
```{r summer chl a with target, results = "show", echo = TRUE, fig.width = 12.5}
target_chla <- eut_thresholds %>% 
  select(Subbasin = basin, target_chla = summer_chla)

subbasin_target_chla <- left_join(chla_subbasin_mean_months_summer, target_chla, 
                                  by = "Subbasin") 
# %>% filter(year >=2010)

## Basin data with target (mean by subbasin, as HELCOM)
subbasin_target_chla2 <- subbasin_target_chla %>% 
  group_by(Subbasin, target_chla) %>% 
  summarise(mean_chla_yrs = round(mean(mean_chla, na.rm=TRUE), 1)) %>% 
  left_join(subbasin_target_chla, by = c("Subbasin", "target_chla"))

ggplot(subbasin_target_chla, aes(year, mean_chla, group = 1)) + 
  geom_point() +
  geom_line() +
  geom_line(aes(year, target_chla), colour = "red") +
  facet_wrap(~Subbasin)+
  scale_y_continuous(limits = c(0,10)) +
  ggtitle("Mean Summer Chl a against Targe values (offshore)") +
  theme(axis.text.x = element_text(colour="grey20", size=8, angle=90, 
                                   hjust=.5, vjust=.5, face = "plain"))


ggplot(subbasin_target_chla2, aes(year, mean_chla, group = 1)) + 
  geom_col() +
  geom_line(aes(year, mean_chla_yrs), colour = "black") +
  geom_line(aes(year, target_chla), colour = "red") +
  facet_wrap(~Subbasin)+
  scale_y_continuous(limits = c(0,10)) +
  ggtitle("Mean Summer Chl a against Targe values (offshore)") +
  theme(axis.text.x = element_text(colour="grey20", size=8, angle=90, 
                                   hjust=.5, vjust=.5, face = "plain"))

```
<br/>

##### 3.2.2.1 Status Calculation (coastal & offshore) {-}

**Explore status years**

Only five (5) basins have data for 2019, which will be used as the status year, while six (6) have data for 2018 and two (4) for 2016. 
For these basins, their most recent year's data is used for current status calculations
```{r what is the last year, results = "hide"}

## get the last year of non-NA data
chla_last_year <- subbasin_target_chla %>%
  filter(!is.na(mean_chla))%>%
  group_by(Subbasin)%>%
  summarise(last_year = last(year)) %>%
  print(n=15)

##which are not in 2013
chla_last_year %>% filter(last_year < 2019)

```

**Status calculation with raw (non-modeled) mean summer chla by basin** 

Status must be calculated in data prep because it's calculated on the basin level and then applied to all regions
```{r Status calculation, results = "show", echo = TRUE, fig.width = 9.5}

## Define constants for status calculation

min_year = 2010        # earliest year to use as a start for regr_length timeseries
##data already filtered for 
regr_length = 10       # number of years to use for regression
future_year = 5        # the year at which we want the likely future status
min_regr_length = 5    # min actual number of years with data to use for regression.

## Calculate basin status = basin_target/basin_mean
chla_subbasin_status <- subbasin_target_chla2 %>%
  rename(subbasin = Subbasin) %>% 
  mutate(., status =  pmin(1, target_chla/mean_chla_yrs)) %>%
  left_join(basin_lookup, by = "subbasin") %>% 
  mutate(region = paste(subbasin, rgn_nam, sep = ", "))
#  dplyr::select(subbasin, year, status) 

## Assign basin status to BHI regions
chla_bhi_status <- chla_subbasin_status %>%
  group_by(subbasin) %>% 
#  filter(year == max(year)) %>% #select last year of data for status in each basin (this means status year differs by basin)
  mutate(status = round(status*100)) %>% #status is whole number 0-100
  ungroup() %>%
  mutate(dimension = 'status',
         indicator = "chla") %>%
  dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, dimension, score=status, region, indicator)

# Plot the status (by subbasin)
ggplot(chla_subbasin_status, aes(region, status, fill = subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7)) +
  ggtitle("Chl a Status by subbasins")

# Plot the status (by bhi regions)
ggplot(chla_bhi_status, aes(region, score, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "black", alpha = 0.7, show.legend = FALSE) + 
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7)) +
      ggtitle("Chl a Status by Subbasins (offshore) [average 2010-2020]")

```

##### 3.2.2.2 Calculate Trend {-}

**METHOD 1**
```{r trend calculation}
## Calculate basin trend
chla_subbasin_trend1 <- chla_subbasin_status %>%
  group_by(subbasin) %>%
  do(tail(. , n = regr_length)) %>%  # calculate trend only if there is at least X years of data (min_regr_length) in the last Y years of time serie (regr_length)
  do({if(sum(!is.na(.$status)) >= min_regr_length)
    data.frame(trend_score = 
                 max(-1, min(1, coef(lm(status ~ year, .))['year'] * future_year)))
    else data.frame(trend_score = NA)}) %>%
  ungroup() 

## Assign basin trend to BHI regions
chla_bhi_trend1 <- left_join(basin_lookup, chla_subbasin_trend1, by = "subbasin") %>%
  mutate(score = round(trend_score, 2),
         dimension = "trend",
         indicator = "chla",
         region = paste(subbasin, rgn_nam, sep = ", ")) %>%
  dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, dimension, score, region, indicator)

```

**METHOD 2 (Ellie)**
```{r trend calculation}
## Calculate basin trend
trendyrs <- min_year:(min_year + regr_length)

chla_lm_estim <- chla_offshore %>% 
  mutate(year = as.numeric(year)) %>% 
  filter(year %in% trendyrs) %>% 
  group_by(Subbasin) %>% 
  mutate(
    trendcalc_nyrs = n_distinct(year),
    num_obs = n()
  ) %>% 
  ## how much data is enough data to calculate short-term trends?
  do(trend_mdl = lm(chla_ug_l ~ year, data = .)) %>%
  mutate(
    projected = predict(trend_mdl, data.frame(year = max(trendyrs) + future_year)),
    current_estimated = predict(trend_mdl, data.frame(year = max(trendyrs))),
    trend_score = (projected-current_estimated)/current_estimated
  )

# filter(trendcalc_nyrs >= 6|(trendcalc_nyrs >= 4 & num_obs > 8)) %>% 

chla_subbasin_trend2 <- chla_lm_estim %>% 
  rename(subbasin = Subbasin) %>% 
  ungroup() %>% 
  select(-trend_mdl) %>% 
  group_by(subbasin) %>% 
  summarize(trend = mean(trend_score, na.rm = TRUE) %>% round(3)) %>%
  ## constrain trend values between one and negative one
  mutate(trend = ifelse(-1 <= trend & trend <= 1, trend, trend*abs(1/trend)))

## Assign basin trend to BHI regions

chla_bhi_trend2 <- left_join(basin_lookup, chla_subbasin_trend2, by = "subbasin") %>%
  mutate(score = round(trend, 2),
         dimension = "trend",
         indicator = "chla",
         region = paste(subbasin, rgn_nam, sep = ", ")) %>%
  dplyr::select(Subbasin = subbasin, BHI_ID = bhi_id, region, dimension, score, indicator)

```

##### 3.2.2.3 Plot Status and Trend {-}

**Plot basin status**
Basin status is initially a value between 0 - 1.  Calculated for each year between 2000 and 2020.  
```{r plot basin status, results = "show", echo = TRUE, fig.width = 9.5}
ggplot(chla_subbasin_status) + 
  geom_point((aes(year, status))) +
  facet_wrap(~subbasin) +
  theme(axis.text.x = element_text(colour="grey20", size=8, angle=90, 
                                   hjust=.5, vjust=.5, face = "plain"))

```

**Plot BHI region status and trend values**

Status values can range from 0-100 -- this is the status for the *most recent* year. In most cases this is 2019. No status or trend for 5 or 6 - these are The Sound, which had no data. 
```{r bhi status and trend plot, results = "show", echo = TRUE, fig.width = 9.5}
## Method 1
# chla_bhi_status <- as.data.frame(chla_bhi_status)
ggplot(rbind(chla_bhi_status, chla_bhi_trend1)) + 
  geom_point(aes(BHI_ID, score),size=2)+
  facet_wrap(~dimension, scales="free_y")+
  xlab("BHI region")

## Method 2
ggplot(rbind(chla_bhi_status, chla_bhi_trend2)) + 
  geom_point(aes(BHI_ID, score),size=2)+
  facet_wrap(~dimension, scales="free_y")+
  xlab("BHI region") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7)) +
      ggtitle("Chl a Status and Trend by bhi regions (offshore)")
```

<br>

### 3.3 Nutrients Indicator

#### 3.3.1 Match BHI regions

```{r read in eut nutrient data and match with BHI regions}

```

#### 3.3.2 Mean nutrients calculations

```{r}

```

<br>

### 3.4 Anoxia Data

For details on data preparation for oxygen debt layer, see [this github repository](https://github.com/OHI-Baltic/HEAT), forked from ICE HEAT assessment tool for fitting oxygen debt profiles to oxygen data measurements. Oxygen data measurements used were obtained from ICE and merged as documented in section 2.2.4.

<br>

## 4. Visualizing Data Layers

### 4.1 Map

**Secchi Status Maps**
```{r secchi status map, results = "show", echo = TRUE, fig.width = 9.5}
mapcols <- c("indianred", "coral", "goldenrod1", "khaki", "lightblue", "steelblue")

mapdf_secchi <- bind_rows(
  secchi_bhi_status %>% 
    select(-region),
  
  secchi_bhi_trend2 %>% 
    select(-region)
    )
  
mapsf_secchi <- left_join(bhi_rgns_simple, mapdf_secchi, by = c("Subbasin", "BHI_ID"))

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

status_secchi_map <- basemap + 
  geom_sf(data = filter(mapsf_secchi, indicator == "score"), aes(fill = score), size = 0.1, alpha = 0.85) +
  facet_wrap(~ indicator) +
  scale_fill_gradientn(colors = mapcols, limits = c(0, 1), na.value = "gainsboro") +
  theme(
    legend.background = element_rect(color = "grey"),
    legend.position = c(0.15, 0.75)
  ) +
  labs(fill = "Score")
```

**Chl a Status Maps**
```{r chla status map, results = "show", echo = TRUE, fig.width = 9.5}
mapcols <- c("indianred", "coral", "goldenrod1", "khaki", "lightblue", "steelblue")

mapdf_chla <- bind_rows(
  chla_bhi_status %>% 
    select(-region),
  
  chla_bhi_trend2 %>% 
    select(-region)
    )
  
mapsf_chla <- left_join(bhi_rgns_simple, mapdf_chla, by = c("Subbasin", "BHI_ID"))

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

status_chla_map <- basemap + 
  geom_sf(data = filter(mapsf_chla, indicator == "score"), aes(fill = score), size = 0.1, alpha = 0.85) +
  facet_wrap(~ indicator) +
  scale_fill_gradientn(colors = mapcols, limits = c(0, 1), na.value = "gainsboro") +
  theme(
    legend.background = element_rect(color = "grey"),
    legend.position = c(0.15, 0.75)
  ) +
  labs(fill = "Score")
```


**Secchi and Chl a Status Maps**
```{r eutrophication status map, results = "show", echo = TRUE, fig.width = 9.5}
mapcols <- c("indianred", "coral", "goldenrod1", "khaki", "lightblue", "steelblue")

mapdf <- bind_rows(
  secchi_bhi_status %>% 
    select(-region),
  
  secchi_bhi_trend2 %>% 
    select(-region),
  
  chla_bhi_status %>% 
    select(-region),
  
  chla_bhi_trend2 %>% 
    select(-region)
    )
  
mapsf <- left_join(bhi_rgns_simple, mapdf, by = c("Subbasin", "BHI_ID"))

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

statusmap <- basemap + 
  geom_sf(data = filter(mapsf, indicator == "score"), aes(fill = score), size = 0.1, alpha = 0.85) +
  facet_wrap(~ indicator) +
  scale_fill_gradientn(colors = mapcols, limits = c(0, 1), na.value = "gainsboro") +
  theme(
    legend.background = element_rect(color = "grey"),
    legend.position = c(0.15, 0.75)
  ) +
  labs(fill = "Score")
```
<br>

**Trend Maps**
```{r trend plots, results = "show", echo = TRUE, fig.width = 9.5}
trendsdf <- left_join(
  cw_con %>% 
    select(-rgn_nam) %>% 
    filter(dimension == "trend") %>% 
    tidyr::pivot_wider(names_from = indicator, values_from = score),
  cw_con_w_penalty %>% 
    filter(dimension == "trend") %>% 
    select(-proportion_monitored, -Subbasin),
  by = c("BHI_ID", "dimension")
)
trendsdf <- trendsdf %>% 
  tidyr::pivot_longer(
    cols = c("pcb", "pfos", "dioxin", "score"), 
    names_to = "indicator",
    values_to = "score"
  ) %>% 
  left_join(
    read_csv(here::here("supplement", "lookup_tabs", "rgns_complete.csv")) %>% 
      select(Subbasin = subbasin, subbasin_order, BHI_ID = region_id, subbasin_order),
    by = c("Subbasin", "BHI_ID")
  ) %>% 
  mutate(
    score_na = ifelse(is.na(score), 1, score),
    indicator = ifelse(indicator == "score", "average_trend", indicator)
  ) %>% 
  arrange(desc(subbasin_order))

trendsdf$Subbasin <- factor(
  trendsdf$Subbasin,
  levels = unique(trendsdf$Subbasin)
)

trendplots <- ggplot(trendsdf, aes(Subbasin, score_na, fill = score)) +
  geom_bar(stat = "identity", position = position_dodge(), show.legend = FALSE) +
  geom_hline(yintercept = 0, color = "grey") +
  scale_fill_gradientn(colors = rev(mapcols), limits = c(-1, 1), na.value = "gainsboro") +
  facet_wrap(~ indicator, nrow = 1) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  guides() +
  theme_bw()
```


```{r SOME MAAP, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5}
library(leaflet)
source(here::here("R", "spatial.R"))
regions_shape()

## join datalayers with simplified spatial data for mapping
plotshp <- rmapshaper::ms_simplify(input = BHI_rgns_shp) %>% 
  sf::st_as_sf() %>% 
  dplyr::select(rgn_nam, rgn_key, Subbasin, HELCOM_ID, region_id = BHI_ID, Area_km2) %>% 
  left_join(
    DATALAYERS,
    by = "region_id"
  )
  
pal <- leaflet::colorNumeric("RdYlBu", log10(seq(1, 5, 0.01)), "#fcfcfd", reverse = TRUE)

## create map
leaflet(data = plotshp) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  setView(18, 59, zoom = 5) %>% 
  addMapPane("popup", zIndex = 450) %>% 
  
  addPolygons(
    stroke = TRUE, opacity = 0.3, weight = 1, fillOpacity = 0.95,
    fillColor = ~palProd(DATALAYER),
    group = "GROUPNAME"
  ) %>% 
  
  ## layers controls, popup layer, and formatting
  addLayersControl(
    baseGroups = c(
      BASEGROUPS
    ),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% 
  addPolygons(
    popup = paste(
      "<h5><strong>", "Region:", "</strong>",
      plotshp$Name, "</h5>",
      "<h5><strong>", "BHI Region ID:", "</strong>",
      plotshp$region_id, "</h5>"
    ),
    fillOpacity = 0,
    stroke = FALSE,
    options = pathOptions(pane = "popup")
  )
```

<br>

## 5. Considerations for `BHI3.0`

<br>

## 6. References

```{r References, child = refs_path, results = "asis", echo = FALSE}
```

