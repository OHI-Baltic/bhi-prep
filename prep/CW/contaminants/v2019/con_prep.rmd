---
title: "Contaminants - Clean Water Subgoal"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: hide
---

<br>

```{r preamble prep including spatial functions and files, message = FALSE, warning = FALSE, include = FALSE}
loc <- here::here("prep", "CW", "contaminants")

source(here::here("R", "setup.R"))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, results = "hide", fig.width = 9.5)

bkgd_path <- here::here("supplement", "goal_summaries", "con_summary.Rmd")
data_path <- here::here("data", "CW", "contaminants", version_year, "con_data.rmd")
refs_path <- file.path(loc, "con_references.Rmd")

source(here::here("R", "spatial.R"))
regions_shape()
buffer_sf <- st_read(
  file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile_25km_buffer"), 
  "BHI_shapefile_25km_buffer"
)
bhi_rgns_simple <- rmapshaper::ms_simplify(input = BHI_rgns_shp) %>% sf::st_as_sf()
```

```{r css for tabset}
cat("
.btn {
    border-width: 0 0px 0px 0px;
    font-weight: normal;
    text-transform: ;
}
.btn-default {
    color: #2ecc71;
    background-color: #ffffff;
    border-color: #ffffff;
}
")
```

<br>

## 1. Background

```{r Background, child = bkgd_path, results = "asis", echo = FALSE}
```

<br/>

## 2. Data

```{r Data, child = data_path, results = "asis", echo = FALSE}
```

<br/>

## 3. Prep: Wrangling, Evaluation, and Gapfilling

```{r function to load datasets created in con_data, echo = TRUE, results = "hide", message = FALSE}
read_clean_df <- function(filename){
  read_csv(
    file.path(dirname(data_path), "intermediate", filename),
    ## ensure column types are read correctly...
    col_types = cols(
      bulk_id = col_character(),
      qflag = col_character(),
      `LIPIDWT%` = col_number(),
      `DRYWT%` = col_number(),
      `EXLIP%` = col_number(),
      WTMEA = col_number(),
      sub_samp_id = col_number()
    )
  )
}
```

---

**Station Impact Codes**

*Note: as of `BHI2.0` the original station library has been replaced by a new web application*

[Site monitoring purpose](https://vocab.ices.dk/?ref=42) `monit_purpose` vocabulary reference for codes.

Some sites have had the site type recorded in the ICES station dictionary ([see ICES vocabulary reference for codes](https://vocab.ices.dk/?ref=177). It is pertinent to know which sites are catagorized as:  

1. **RH** = WFD R(HZ) - Representative of general conditions in terms of hazardous substances  
2. **B** = WFD B - Baseline/Reference station  
3. **Any of the codes containing "I"** (Starting with IH or IP) which refers to a specific type of impact at the site.  
4. **RP** = WFD R(PHY) - Representative of general conditions for nutrients/organic matter 

It appears that only Swedish sites have this information entered. Given only Swedish sites have this information recorded, it seems difficult to use this information to include or exclude sites.  

From the station dictionary definitions:

- All_Biota_Data: Data type (DTYPE) CF - all parameters - contaminants and biological effects of contaminants including disease in biota  
- Contaminant_parameters_in_biota: Data type (DTYPE) CF - Contaminant parameter groups  

---

<br>

### 3.1 PCB Indicator

#### 3.1.1 Match BHI Regions

**Use Lat/Long to Match BHI Regions**
```{r assign BHI regions to PCB data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'read_clean_df' function from above to read cleaned data with correct data types for columns
## use 'join_rgns_info' helper function defined in R/spatial.R
pcb_bio <- join_rgns_info(
  read_clean_df("pcb_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
pcb_sed <- join_rgns_info(
  read_clean_df("pcb_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

#### 3.1.2 Filter PCBs to ICES6 Set or PCB7 for Sediment

The PCBs indicator uses only the ICES6 congeners: CB28, CB52, CB101, CB138, CB153, CB180.  Additionally, only herring are used from the biota dataset, as they are fairly equally spatially distributed across the baltic sea, while many other species are predominantly in the south.

```{r filter pcb data}
## for the PCBs indicator we use the ICE6 congeners:
ices6_congeners <- c("CB101", "CB138", "CB153", "CB180", "CB28", "CB52")
## for PCBs in sediment we use the seven from the Norwegian Environment Agency EQS in sediment for 28 EU priority substances
## note: this sum is also included in the raw dataset as 'SCB7' but as of BHI2.0 all such observations are for the UK 
pcb7sed_congeners <- c("CB28", "CB52", "CB101", "CB118", "CB138", "CB153", "CB180")

pcb_bio <- pcb_bio %>% 
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  filter(variable %in% ices6_congeners) %>% 
  ## check that rows are distinct: nrow(pcb_bio) == nrow(distinct(pcb_bio))...
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  )

pcb_sed <- pcb_sed %>% 
  filter(!is.na(value)) %>% 
  filter(variable %in% pcb7sed_congeners) %>% 
  ## check that rows are distinct: nrow(pcb_sed) == nrow(distinct(pcb_sed))...
  select(
    variable, value_dry_wgt, detect_lim_dry_wgt, quant_lim_dry_wgt,
    num_indiv_subsample, monit_program, monit_purpose, monit_year,
    samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) %>% 
  filter(!is.na(BHI_ID)|!is.na(Subbasin))
```

<br> 

##### Visualize flagged data in Timeseries {.tabset .tabset-fade .tabset-pills}

###### PCBs in Biota

Below the data are plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

```{r pcbs bio qflag adjustment congeners by basin, results = "show", fig.height = 22, fig.width = 9.5}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
plotdf <- pcb_bio %>% 
  mutate(value_adj = ifelse(qflagged, value_wet_wgt/2, NA)) %>% 
  group_by(date, variable, Subbasin) %>% 
  mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
  ungroup()

ggplot(plotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1) +
  geom_point(aes(date, value_wet_wgt, color = countObs), show.legend = FALSE, size = 0.6, alpha = 0.4) +
  geom_point(aes(date, value_adj), color = "red", shape = 4, size = 1, alpha = 0.6) +
  geom_line(aes(date, meanAdjww), size = 0.4, alpha = 0.6, show.legend = FALSE) +
  facet_wrap(
    c("variable", "Subbasin"), 
    labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
    scales = "free_y", 
    ncol = 4
  ) +
  labs(x = NULL, y = "Congener Concentration (ug/kg wet weight) measured in Clupea harengus") +
  theme_bw()
```

<br>

###### PCBs in Sediment

Same as timeseries plots for biota, but with fewer data points. Higher opacity and larger points used just so they are easier to see in the plots.

```{r pcbs sed qflag adjustment congeners by basin, results = "show", fig.height = 31, fig.width = 9.5}
plotdf <- pcb_sed %>% 
  mutate(value_adj = ifelse(qflagged, value_dry_wgt/2, NA)) %>% 
  group_by(date, variable, Subbasin) %>% 
  mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
  ungroup()

ggplot(plotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1) +
  geom_point(aes(date, value_dry_wgt, color = countObs), show.legend = FALSE, size = 0.8, alpha = 0.7) +
  geom_point(aes(date, value_adj), color = "red", shape = 4, size = 1, alpha = 0.6) +
  facet_wrap(
    c("variable", "Subbasin"), 
    labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
    scales = "free_y", 
    ncol = 4
  ) +
  labs(x = NULL, y = "Congener Concentration (ug/kg) measured in Sediments") +
  theme_bw()
```

<br>

#### 3.1.3 Evaluate flagged data, Station Impact, & sampling patterns

<br>

**What do the `qflags` indicate? Quantification limits, Flags Codes**

- **<** = less than  

- **>** = greather than  

- **D** = reported value is less than the detection limit (detect_lim)  

- **Q** = reported value is less than the limit of quantification (quant_lim)  

- **~** separates multiple flags  

<br>

```{r what do the qflags indicate, results = "show"}
## what do the qflags actually indicate?
chk_pcb_bio_qflags <- pcb_bio %>% 
  select_at(vars(matches("qflag|value|quant|detect"))) %>% 
  filter(qflagged) %>% 
  mutate(qflag = str_split(qflag, "~")) %>% 
  tidyr::unnest(qflag) %>%
  mutate(
    ## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
    ## < and Q flags indicates less than or equal to quantification limit, 
    ## D flag indicates less than detection limit
    chk = case_when(
      qflag == "D" ~ value_wet_wgt < detect_lim_wet_wgt,
      qflag == "Q" ~ value_wet_wgt <= quant_lim_wet_wgt,
      qflag == "<" ~ value_wet_wgt <= quant_lim_wet_wgt
    )
  )
## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
## < and Q flags indicates less than or equal to quantification limit, 
## D flag indicates less than detection limit
ggplot(chk_pcb_bio_qflags) +
  geom_bar(aes(chk, fill = chk), position = position_dodge()) +
  scale_fill_manual(values = c("firebrick", "paleturquoise3"), na.value = "whitesmoke") +
  facet_wrap(~qflag, nrow = 1, scales = "free") +
  labs(
    x = "\nConc. value â‰¤ Quantification Limit ('<' and 'Q'), Conc. value < Detection Limit ('D')", 
    y = NULL, 
    fill = NULL
  )  +
  theme_dark()
```

---

<br>

##### Compare two approaches to deal with flagged data, for BHI regions vs Basin  {.tabset .tabset-fade .tabset-pills}

1. Remove the flagged observations or adjust values using detect_lim/2; detect_lim values not always provided, so instead, apply transformation to the reported data value
2. Start with mean ICES6 conc. by date and location (our unique observations) 
3. Take mean of all unique obs. for past 5 years in either BHI region or basin
4. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing  

```{r function to adjust qflagged data}

qflag_adjust <- function(dataset, congeners = NULL, matrix = "bio", sumcongeners = TRUE, approach = "Adjusted"){
  ## Two alternative approaches for summarizing the data:
  ## Adjusted: sum the adjusted values, for the 6 ICES congeners
  ## NoQflag: sum only observation with no qflagged values
  if(approach == "NoQflag"){
    dataset <- filter(dataset, !qflagged)
  }
  
  if(matrix == "bio"){
    dataset <- dataset %>% 
      rename(value_plot = value_wet_wgt) %>% 
      select(-detect_lim_wet_wgt, -quant_lim_wet_wgt)
  } else {
    dataset <- dataset %>% 
      rename(value_plot = value_dry_wgt) %>% 
      select(-detect_lim_dry_wgt, -quant_lim_dry_wgt)
  }
  
  ## aggregate into single date-location values:
  ## sum concentration after flagged data adjustment and date-location averages per congener
  data_Qadjust_sums <- dataset %>% 
    ## adjust for qflags
    ## NOTE if all qflagged are removed, all adjusted values equal original values
    mutate(value_adj = ifelse(qflagged, value_plot/2, value_plot)) %>% 
    ## after dealing with flagged values, may have duplicates; take mean of these 
    select(-qflag, -qflagged, -value_plot) %>% 
    tidyr::pivot_wider(
      names_from = variable, 
      values_from = value_adj,
      values_fn = list(value_adj = mean)
    )
  ## sum congeners by date and location
  ## remove cases where not all congeners are observed by filtering nas
  if(sumcongeners & !is.null(congeners)){
    data_Qadjust_sums <- data_Qadjust_sums %>% 
      mutate(sum_congeners = select(., congeners) %>% rowSums()) %>% 
      filter(!is.na(sum_congeners))
  }
  
  return(data_Qadjust_sums)
}
pcb_bio_qflag_adjust <- qflag_adjust(pcb_bio, congeners = ices6_congeners)
pcb_sed_qflag_adjust <- qflag_adjust(pcb_sed, congeners = pcb7sed_congeners, matrix = "sed")
pcb_bio_noqflag <- qflag_adjust(pcb_bio, congeners = ices6_congeners, approach = "NoQflag")
pcb_sed_noqflag <- qflag_adjust(pcb_sed, congeners = pcb7sed_congeners, matrix = "sed", approach = "NoQflag")
```

<br>

<!-- To visualize by country versus basin give either "country" or "subbasin" respectively as the `cntry_or_basin` arguement  -->

```{r function for congeners timeseries monthly by basin, message = FALSE, echo = TRUE}

## timeseries plots, congeners by country
plot_cwcon_initial <- function(dataset, col_pal, contam_param = "OC-CB", matrix = "bio", cntry_or_basin = "subbasin"){
  
  ## one of OC-CB, OC-DX or O-FL; becomes OC, DX, or FL respectively
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  if(contam_param == "FL"){contam_param = "PF"}
  cntry_or_basin <- str_to_lower(cntry_or_basin)
  
  dat <- dataset %>% 
    rename(subbasin = Subbasin) %>% 
    select(month, Year = year, zone = cntry_or_basin, starts_with(contam_param)) %>% 
    filter(!is.na(zone), Year > 2000) %>% 
    tidyr::pivot_longer(
      cols = starts_with(contam_param), 
      names_to = "Congener", 
      values_to = "value_plot"
    ) %>%  
    group_by(Congener, month, Year, zone) %>%
    summarize(Value = mean(value_plot, na.rm = TRUE) %>% round(3)) %>%
    ungroup() %>%
    mutate(Date = as.Date(paste("1", month, Year, sep = "-"), tryFormats = "%d-%m-%Y"))
  
  if(contam_param == "CB"){
    if(matrix == "bio"){
      dat$Congener <- factor(
        dat$Congener, 
        levels = c("CB101", "CB138", "CB153", "CB180", "CB28", "CB52")
      )
    } else {
      dat$Congener <- factor(
        dat$Congener, 
        levels = c("CB101", "CB138", "CB153", "CB180", "CB28", "CB52", "CB118")
      )
    }
  }
  
  ## timeseries plots of all congeners by country
  plot <- ggplot(data = dat, aes(Date, Value, fill = Congener)) +
    geom_col(position = "stack", show.legend = FALSE) +
    scale_x_date(
      breaks = function(x){seq.Date(from = min(dat$Date), to = max(dat$Date), by = "3 months")},
      date_labels = "%b %Y"
    ) +
    scale_fill_manual(values = col_pal) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, size = 6)) +
    facet_wrap(~zone, scales = "free_y", ncol = 1)
  
  return(plotly::ggplotly(plot))
}
```


###### Congeners Monthly Sums, PCBs in Biota

```{r congeners timeseries monthly by basin for biota, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 9}
## create color palettes
fullpal <- c(
  RColorBrewer::brewer.pal(8, "Dark2"),
  RColorBrewer::brewer.pal(9, "Set1")
)
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 6)]
plot_cwcon_initial(pcb_bio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country")
```

###### Congeners Monthly Sums, PCBs in Sediments

```{r congeners timeseries monthly by basin for sediments, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 9}
cols <- c(cols, "turquoise")
plot_cwcon_initial(pcb_sed_qflag_adjust, cols, "OC-CB", "sed", "country")
```

<br>

##### Spatial distributions of PCB sampling Locations {.tabset .tabset-fade .tabset-pills}

```{r function for mapping spatial dist of data points}
map_cwcon_initial <- function(dataset, yr, matrix){
  
  if(!"Matrix" %in% names(dataset)){
    dataset <- dataset %>% 
      mutate(matrix = matrix)
  }
  
  df <- full_join(
    bhi_rgns_simple %>% 
      select(HELCOM_ID) %>% 
      mutate(HELCOM_ID = as.character(HELCOM_ID)),
    dataset %>% 
      filter(year %in% yr) %>% 
      group_by(Subbasin, HELCOM_ID, Matrix) %>% 
      summarize(ObservCount = n()),
    by = "HELCOM_ID"
  )
  
  # df <- full_join(
  #   bhi_rgns_simple %>% 
  #     select(BHI_ID) %>% 
  #     mutate(BHI_ID = as.character(BHI_ID)),
  #   dataset %>% 
  #     filter(year %in% yr) %>% 
  #     group_by(BHI_ID, Matrix) %>% 
  #     summarize(ObservCount = n()) %>% 
  #     ungroup() %>% 
  #     mutate(BHI_ID = as.character(BHI_ID)),
  #   by = "BHI_ID"
  # )
  
  map <- ggplot(df) + 
    geom_sf(aes(fill = ObservCount), color = "burlywood", size = 0.1, alpha = 0.9) +
    scale_fill_gradient(low = "navy", high = "skyblue", na.value = "white") +
    geom_sf(
      data = st_as_sf(dataset, coords = c("longitude", "latitude"), crs = 4326) %>% filter(year %in% yr), 
      mapping = aes(color = Matrix, shape = Matrix),
      size = 3
    ) +
    scale_color_manual(values = c("red", "green")) +
    scale_shape_manual(values = c(9, 7)) +
    theme_dark() +
    theme(legend.position = c(0.1, 0.85), plot.margin = grid::unit(c(0,0,0,0), "mm"))
  
  return(map)
}

pcb_all_obs <- bind_rows(
  pcb_bio_qflag_adjust %>% 
    select(Subbasin, HELCOM_ID, BHI_ID, year, latitude, longitude) %>% 
    mutate(Matrix = "biota"), 
  pcb_sed_qflag_adjust %>% 
    select(Subbasin, HELCOM_ID, BHI_ID, year, latitude, longitude) %>% 
    mutate(Matrix = "sediment")
)
```


###### With just year 2014

```{r map spatial dist of PCB bio year 2014, results = "show", fig.width = 10, fig.height = 9, out.width = "120%"}
map_cwcon_initial(pcb_all_obs, yr = 2014, matrix = "both")
```

---

###### With just year 2016

```{r map spatial dist of PCB bi0 year 2016, results = "show", fig.width = 10, fig.height = 9, out.width = "120%"}
map_cwcon_initial(pcb_all_obs, yr = 2016, matrix = "both")
```

---

###### With years 2014 to 2019

```{r map spatial dist of PCB bio multiple yrs, results = "show", fig.width = 10, fig.height = 9, out.width = "120%"}
map_cwcon_initial(pcb_all_obs, yr = 2014:2019, matrix = "both")
```

---

<br>

#### 3.1.4 Status and trend options and calculation

```{r calculations of indicators status and trend}
cwcon_indicators <- function(datalayer, yrs = 2010:2019, bio_thresh = 75, sed_thresh = 4.1, 
                             approach = "scaledObs", trendlag = 5){
  
  result <- list()
  
  joindf <- BHI_rgns_shp %>% 
    st_drop_geometry() %>% 
    select(-Area_km2) %>% 
    mutate(
      Subbasin = as.character(Subbasin), 
      HELCOM_ID = as.character(HELCOM_ID),
      rgn_nam = as.character(rgn_nam), 
      rgn_key = as.character(rgn_key)
    )
  
  ## STATUS CALCULATIONS
  ## calculate status by subbasins and by bhi regions
  
  result[["basin_status"]] <- datalayer %>%
    filter(year %in% yrs) %>% 
    group_by(HELCOM_ID, Subbasin, matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      mean_dateloc_pts = mean(sum_congeners_datemean, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>% 
    ungroup() %>% 
    mutate(
      health_threshold = ifelse(matrix == "bio", bio_thresh, sed_thresh),
      ratio = mean_dateloc_pts/health_threshold,
      ## using pmin to cap the status at one
      status = pmin(1, 1/ratio)
    ) %>% 
    group_by(HELCOM_ID, Subbasin) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
    right_join(joindf, by = c("Subbasin", "HELCOM_ID"))
  
  result[["bhirgn_status"]] <- datalayer %>%
    filter(year %in% yrs) %>% 
    group_by(BHI_ID, matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      mean_dateloc_pts = mean(sum_congeners_datemean, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>% 
    ungroup() %>% 
    mutate(
      health_threshold = ifelse(matrix == "bio", bio_thresh, sed_thresh),
      ratio = mean_dateloc_pts/health_threshold,
      ## using pmin to cap the status at one
      status = pmin(1, 1/ratio)
    ) %>% 
    group_by(BHI_ID) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
    right_join(joindf, by = c("BHI_ID"))


  ## TREND CALCULATIONS
  ## calculate trend by subbasins and by bhi regions; use method specified in function args
  ## three approaches to calculating trend: mixed-effects, linear model
  for(z in c("basin", "bhirgn")){
    
    if(z == "basin"){
      grpvars <- c("HELCOM_ID", "Subbasin")
      lstname <- "basin_trend"
    } else {
      grpvars <- c("BHI_ID")
      lstname <- "bhirgn_trend"
    }
    
    if(approach == "scaledObs"){
      ## trend approach 1: by observations scaled w.r.t. to reference point
      result[[lstname]] <- datalayer %>% 
        filter(year %in% yrs) %>% 
        group_by(!!!syms(grpvars), matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          health_threshold = ifelse(matrix == "bio", bio_thresh, sed_thresh),
          ratio = sum_congeners_datemean/health_threshold,
          sumcon_datemean_scaled = pmin(1, 1/ratio)
        ) %>% 
        group_by(!!!syms(grpvars), matrix) %>% 
        do(trend_mdl = lm(sumcon_datemean_scaled ~ year, data = .)) %>%
        mutate(trend = coef(trend_mdl)["year"]*trendlag) %>% 
        ungroup() %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trend, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 2: calculate trend with zscores of data
    if(approach == "zscores"){
      datalayer_zscore <- datalayer %>% 
        filter(year %in% yrs) %>% 
        group_by(!!!syms(grpvars), matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          mn = mean(sum_congeners_datemean),
          sd = sd(sum_congeners_datemean),
          zscore = (sum_congeners_datemean-mn)/sd
        )
      if(any(datalayer_zscore$trendcalc_nyrs < 5)){
        message("some trends calculated with fewer than five years")
      }
      if(any(is.na(datalayer_zscore$zscore))){
        message(sprintf(
          "zscore NAs (%s cases) caused trends calculation to fail", 
          nrow(filter(datalayer_zscore, is.na(zscore)))
        ))
      }
      result[[lstname]] <- datalayer_zscore %>% 
        filter(!is.na(zscore)) %>% 
        group_by(!!!syms(grpvars), matrix) %>% 
        do(trend_mdl = lm(zscore ~ year, data = .)) %>% # regression model to get trend from raw observations
        mutate(trend = coef(trend_mdl)["year"]*trendlag) %>% 
        ungroup() %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trend, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 3: mixed effects
    ## current error: not enough observations per group...
    ## number of levels of each grouping factor must be < number of observations 
    ## would use the following piece of code to fit model.....
    # do({
    #   if(distinct(., latitude) %>% nrow() > 1){
    #     (trend_mdl = lme4::lmer(zscore ~ year + (1|latitude), data = .))
    #   } else {(trend_mdl = lm(zscore ~ year, data = .))}
    # }) %>% 
  }
  
  return(result)
}
```

<br>

```{r investigate approaches to qflags and summarizing by region vs basin pcb biota indicator, fig.width = 9.5, fig.height = 18}
## using functions defined above, check effects of:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend

## bind resulting dataset to plot together and evaluate....
pcb_datalayer_qflagadjust <- bind_rows(
  pcb_bio_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(matrix = "bio"),
  pcb_sed_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(matrix = "sed")
)
pcb_datalayer_noqflag <- bind_rows(
  pcb_bio_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(matrix = "bio"),
  pcb_sed_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(matrix = "sed")
)
pcb_qflagadjust <- cwcon_indicators(pcb_datalayer_qflagadjust)
pcb_noqflag <- cwcon_indicators(pcb_datalayer_noqflag)

compare_df <- bind_rows(
  pcb_qflagadjust$basin_status %>% mutate(approach = "Adjusted_Basin"),
  pcb_qflagadjust$bhirgn_status %>% mutate(approach = "Adjusted_BHI"),
  pcb_noqflag$basin_status %>% mutate(approach = "NoQflag_Basin"),
  pcb_noqflag$bhirgn_status %>% mutate(approach = "NoQflag_BHI")
) %>% mutate(Region = paste(Subbasin, rgn_nam))

ggplot(compare_df, aes(Region, status, fill = approach)) +
  geom_col(position = position_dodge(), width = 1, color = "grey", alpha = 0.8, show.legend = FALSE) + 
  scale_fill_manual(values = c("navy", "steelblue", "maroon", "orchid")) +
  facet_grid(rows = vars(approach)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme(axis.text.y = element_text(size = 7))
```

```{r pcbs latest years for qflag adjust vs no flagged data approaches, results = "show"}
DT::datatable(
  full_join(
    pcb_datalayer_qflagadjust %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)),
    pcb_datalayer_noqflag %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)),
    by = "Subbasin"
  ) %>% filter(!is.na(Subbasin)),
  fillContainer = FALSE, 
  options = list(pageLength = 17, dom = 'Bfrtip', autoWidth = TRUE, scrollX = TRUE, election = "multiple")
)
```


*Conclusions:*

<!-- - Including the qflag-adjusted values lowers the mean concentration by date and location -->
<!-- - Including qflag-adjusted values also provides more observations in the Kattegat, The Quark, and W. Gotland Basin  -->
<!-- - Outlier in Eastern Gotland Basin is from Polish observations 2014. Have checked unit conversions etc, have found not error. -->

<!-- - When aggregating by BHI regions, more observations for Regions 1, 11,26,35,36,39,41,42 when including qflagged values -->

<!-- - Use data including qflag-adjusted (this could lower values)   -->
<!-- - Use 5 year mean ICES6 concentration  -->

<br>

```{r save useful intermediate datasets and pcbs contaminants layer}

```


The following pieces of code from data prep `BHI1.0` will be integrated into `functions.R`, to reduce numbers of steps in the more labor-intensive data preparation steps...

```{r calculation of ices6 status and trend}

```

<br>


#### 3.1.5 Methods discussion

**Status formula, ICES6 PCBs Biota**
$X_{\mbox{ICES6}} = \frac{1}{\mbox{mean_ICES6_region/reference_point} \times \mbox{penalty_factor}}$

$\mbox{reference_point} = 75ug/kg \times \mbox{health_threshold}$

Scale between 0 and 1.  If value is below 75, $\mbox{score} = 1$

**Only herring (not other species) used from biota dataset, because herring are most equally spatially spaced across the baltic sea, whereas others are mostly in the south**

<br>

**Notes on Status Calculation**

- Using data including qflag-adjusted (this could lower values for trend)  
- Using 5 year mean ICES6 concentration  
- Scale all observations relative to the human health threshold? **Why Scale?** If values are all below the threshold would not want an increase trend in observed values to suggest that the future status will be worse?? 
- **Need to have mixed-effects to account for different stations?**

<br>

**Trend Considerations**

1. Work on mixed effect model for trends?  
2. Need to think about the interpretation of the data treatment. (a) If use raw observations, then normalize (zscore data), then fit trend, if get increase or decrease but all values are below the threshold, does it make sense to apply a change in the trend to the status?  Would we really think the future status will be lower?  (b) If take all raw observations, calculate "status" as done for the mean value, then fit trend, is this more true to the idea that variation below the human health threshold should not affect the trajectory of the future status?  
3. Need to think if simple linear regression is okay, or if need to account for site?  

<br>

**`BHI1.0` discussions with Anna Sobek **

1. Indicator choice: We agreed that *ICES6 is the best* option  
2. Decision about use of qflagg-adjusted data: *use qflagged data with the adjustement* of (congener conc/2)  
3. Decision about spatial scale of the data: decide best approach is to *calculate for each basin*  
4. Trend decision: best approach is first convert individual observations to a "status" relative to the human health threshold, then fit linear model by basin for *10 year period*. (**TREND CHECK:** Does the trend value need to be rescaled to between -1 and 1? Does not exceed now but need to consider if method broadly works?)  

<!-- **`BHI2.0` discussions with Anna Sobek ** -->


---

<br>

### 3.2 PFOS Indicator
#### 3.2.1 Match BHI Regions

**Use Lat/Long to Match BHI Regions**
```{r assign BHI regions to PFOS data, echo = TRUE, message = FALSE, warning = FALSE}
# use 'join_rgns_info' helper function defined in spatial.R
pfos <- join_rgns_info(
  read_clean_df("pfos_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

<br>

#### 3.2.2 Evaluate flagged data & sampling patterns

```{r subset pfos data}
pfos <- pfos %>% 
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  )
```

<br> 

**Visualize PFOS flagged data in Timeseries**

Below the data are plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

```{r pfos qflag adjustment congeners by basin, results = "show", fig.height = 28.5, fig.width = 9.5}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
plotdf <- pfos %>% 
  mutate(value_adj = ifelse(qflagged, value_wet_wgt/2, NA)) %>% 
  group_by(date, variable, Subbasin) %>% 
  mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
  ungroup()

ggplot(plotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1) +
  geom_point(aes(date, value_wet_wgt, color = countObs), show.legend = FALSE, size = 0.8, alpha = 0.6) +
  geom_point(aes(date, value_adj), color = "red", shape = 4, size = 1, alpha = 0.6) +
  # geom_line(aes(date, meanAdjww), size = 0.4, alpha = 0.6, show.legend = FALSE) +
  facet_wrap(
    c("variable", "Subbasin"), 
    labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
    scales = "free_y", 
    ncol = 4
  ) +
  labs(x = NULL, y = "Congener Concentration (ug/kg wet weight) measured in Clupea harengus") +
  theme_bw()
```

<br>

**Congeners Monthly Sums PFOS**

```{r pfos initial visualizations, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 9}
pfos_qflag_adjust <- qflag_adjust(pfos, sumcongeners = FALSE)
pcb_noqflag <- qflag_adjust(pfos, sumcongeners = FALSE, approach = "NoQflag")

cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 19)]
plot_cwcon_initial(pfos_qflag_adjust, col_pal = cols, contam_param = "O-FL", cntry_or_basin = "country")
```

<br>

**Spatial distributions of PFOS sampling Locations**

```{r pfos map of data records, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 9}
map_cwcon_initial(pfos_qflag_adjust %>% mutate(Matrix = "biota"), yr = 2014:2019)
```

<br>

#### 3.2.3 Status and trend options and calculation

```{r check pfos calculation and approach}

```

<br>

```{r save pfos contaminants layers}

```

<br>

The following pieces of code from data prep `BHI1.0` will be integrated into `functions.R`, to reduce numbers of steps in the more labor-intensive data preparation steps...

```{r calculation of pfos status and trend}

```

#### 3.2.4 Methods discussion


**Trend Calculation**

Calculate the trend over five-year data period using unique date/location observations (mean of site samples) transformed to status values. Trend calculated per basin.

$X_{basin} = \mbox{slope }\times \mbox{year } + \mbox{intercept }$

$\mbox{Trend} = 5 \times \mbox{slope }$


---

<br>

### 3.3 Dioxin Indicator
#### 3.3.1 Match BHI Regions and Join with Dioxin-like PCBs

**Use Lat/Long to Match BHI Regions**

```{r assign BHI regions to Dioxin data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'join_rgns_info' helper function defined in spatial.R
dioxin_bio <- join_rgns_info(
  read_clean_df("dioxin_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
dioxin_sed <- join_rgns_info(
  read_clean_df("dioxin_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
## DATA POINTS WITH MISSING BHI IDS FILTERED OUT... SHOULD MANUALLY ADD INSTEAD?
```

```{r TEQ conversion lookup}
tef_pdf <- pdftools::pdf_text("https://www.who.int/ipcs/assessment/tef_values.pdf")[1] %>%
  stringr::str_split(pattern = "\n")
tef_lookup <- as.data.frame(tef_pdf[[1]][2:34])
colnames(tef_lookup) <- "singlecolumn"
tidyr::separate(tef_lookup, singlecolumn, c("WHO_compound_name", "TEF_1998", "TEF_2005"), "\\s\\s+")

## manually matched with ICES congeners names...
lookup_tef <- read_csv(here::here("supplement", "lookup_tabs", "tef_conversion_lookup.csv"))
```

<br>

**Filter PCB to keep only dioxin-like PCBs and convert units**

```{r filter dioxin like PCBs and convert units ug to pg per gram}
## get dioxin-like PCBs using TEF lookup table
dioxinlike_PCB <- pcb_bio %>%
  ## retain only congeners in both objects
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  ## filter out congeners without a TEF conversion
  filter(!is.na(TEF_2005)) %>%
  select(-congener_full, -WHO_compound_name, -congener_category)

## deal with qflags adjustment here....

```


**Use TEF conversion factor to convert to TEQ**
Dioxins and dioxin-like PCBs still separate objects here.

```{r convert to TEQ and plot by country}
## dioxin dataset
dioxin_teq <- dioxin_bio %>%
   ## retain only congeners in both objects
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
   ## filter out congeners without a TEF conversion
  filter(!is.na(TEF_2005)) %>%
  select(-congener_full, -WHO_compound_name, -congener_category)
  ## convert concentration to TEQ from qflag adjusted value
  # mutate(value_TEQ = value_adj*TEF_2005)


## dioxin-like pcb dataset
# dioxinlike_PCB_teq <- dioxinlike_PCB %>%
#   mutate(value_TEQ = value_adj*TEF_2005)
```


**Assess if Dioxins and dioxin-like PCBs share `sub_sample_ref`**
Were dioxins and PCBs measured from the same samples such that a total TEQ value per sample can be calculated?

```{r assess dioxin pcb overlaps}
## check unique and matching sub_sample_ref
## any cases where sub_samp_ref appears in dioxin and pcb datasets?
# intersect(unique(dioxinlike_PCB_teq$sub_samp_ref), unique(dioxin_teq$sub_samp_ref))
# full_join(
#   dioxin_teq %>%
#     select(sub_samp_ref) %>%
#     distinct() %>%
#     mutate(dioxin = TRUE),
#   dioxinlike_PCB_teq %>%
#     select(sub_samp_ref) %>%
#     distinct() %>%
#     mutate(pcb = TRUE),
#   by = "sub_samp_ref"
# ) %>% filter(dioxin & PCB)

## check any shared location and sample dates?
# intersect(unique(dioxinlike_PCB_teq$sub_samp_ref), unique(dioxin_teq$sub_samp_ref))
# full_join(
#   dioxin_teq %>%
#     select(country, station, date)%>%
#     distinct() %>%
#     mutate(dioxin = TRUE),
#   dioxinlike_PCB_teq %>%
#     select(country, station, date)%>%
#     distinct() %>%
#     mutate(pcb = TRUE),
#   by = "sub_samp_ref"
# ) %>% filter(dioxin & PCB)
```


```{r mean teq values by date and location map}

```


<br>

#### 3.3.2 Evaluate flagged data & sampling patterns

**Adjust Qflagged values**
Use $LOD/2$ approach to adjust values. Because we do not have the LOD in all cases, use: $adjustedValue = value / 2$

**Filter to keep only years where exists quality data**

<br>

#### 3.3.3 Indicator options and calculation

**Calculate the mean TEQ value by basin using just years 2009-2013 (?)**
<br>

**Total TEQ (pg/g) Dioxin**

Calculate the sum of the mean dioxin and the mean dioxin-like PCB TEQ value for each date and location. For observations averaged, also calculate mean, min, and max number of congeners in each of the observations, and also numbers of observations for each date and location.

Horizontal line is the EU human health threshold (6.5 TEQ pg/g ww) (equivalent to suggested HELCOM level of 0.0065 TEQ ug/kg ww)

<br>

#### 3.3.4 Methods discussion

**Dioxin status value**

$X_{TEQstatus} = \frac{1}{\mbox{dioxin + } \mbox{dioxin-like pcb teq value / teq threshold }}$


<br/>

## 4. Contaminant Indicator

```{r read in indicator layers and join into single object}

```

### 4.1 Plotting Indicators for Comparison

### 4.2 Number of Indicators per BHI Region and Subbasin

### 4.3 Trends by BHI Region

```{r plot basin trends for all indicators}

```


<br/>

## 5. Visualizing Data Layers

### 5.1 Timeseries Plots

```{r }

```

<br>

### 5.2 Contaminants by BHI Regions and by Subbasins

```{r}

```

<br/>

### 5.3 Contaminants data layers Map

```{r}

```

<br/>

---

<br>

## 6. Considerations for `BHI3.0`

---

<br>

## 7. References

<br>

```{r References, child = refs_path, results = "asis", echo = FALSE}
```

<br>
