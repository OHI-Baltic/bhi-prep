---
title: "Contaminants - Clean Water Subgoal"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: hide
---

<br>

```{r preamble prep including spatial functions and files, message = FALSE, warning = FALSE, include = FALSE}
loc <- here::here("prep", "CW", "contaminants")

source(here::here("R", "setup.R"))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, results = "hide", fig.width = 9.5)

bkgd_path <- here::here("supplement", "goal_summaries", "con_summary.Rmd")
data_path <- here::here("data", "CW", "contaminants", version_year, "con_data.rmd")
refs_path <- file.path(loc, "con_references.Rmd")

source(here::here("R", "spatial.R"))
regions_shape()
buffer_sf <- st_read(
  file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile_25km_buffer"), 
  "BHI_shapefile_25km_buffer"
)
bhi_rgns_simple <- rmapshaper::ms_simplify(input = BHI_rgns_shp) %>% sf::st_as_sf()
```

<br>

## 1. Background

```{r Background, child = bkgd_path, results = "asis", echo = FALSE}
```

<br/>

## 2. Data

```{r Data, child = data_path, results = "asis", echo = FALSE}
```

<br/>

## 3. Wrangling, Evaluation, and Gapfilling

```{r function to load datasets created in con_data, echo = TRUE, results = "hide", message = FALSE}
read_clean_df <- function(filename){
  read_csv(
    file.path(dirname(data_path), "intermediate", filename),
    ## ensure column types are read correctly...
    col_types = cols(
      bulk_id = col_character(),
      qflag = col_character(),
      `LIPIDWT%` = col_number(),
      `DRYWT%` = col_number(),
      `EXLIP%` = col_number(),
      WTMEA = col_number(),
      WTMIN = col_number(),
      WTMAX = col_number(),
      sub_samp_id = col_number(),
      LNMEA = col_number(), 
      LNMAX = col_number(),
      LNMIN = col_number(),
      unit = col_character()
    )
  )
}
```

<!-- **Station Impact Codes** -->

<!-- Note: as of `BHI2.0` the original station library has been replaced by a new web application -->

<!-- [Site monitoring purpose](https://vocab.ices.dk/?ref=42) `monit_purpose` vocabulary reference for codes. -->

<!-- Some sites have had the site type recorded in the ICES station dictionary ([see ICES vocabulary reference for codes](https://vocab.ices.dk/?ref=177). It is pertinent to know which sites are catagorized as:   -->

<!-- **RH** = WFD R(HZ) - Representative of general conditions in terms of hazardous substances   -->
<!-- **B** = WFD B - Baseline/Reference station   -->
<!-- **Any of the codes containing "I"** (Starting with IH or IP) which refers to a specific type of impact at the site.   -->
<!-- **RP** = WFD R(PHY) - Representative of general conditions for nutrients/organic matter  -->

<!-- It appears that only Swedish sites have this information entered. Given only Swedish sites have this information recorded, it seems difficult to use this information to include or exclude sites.   -->

<!-- From the station dictionary definitions: -->

<!-- All_Biota_Data: Data type (DTYPE) CF - all parameters - contaminants and biological effects of contaminants including disease in biota   -->
<!-- Contaminant_parameters_in_biota: Data type (DTYPE) CF - Contaminant parameter groups   -->

---

<br>

### 3.1 PCB Indicator

#### 3.1.1 Match BHI Regions

```{r assign BHI regions to PCB data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'read_clean_df' function from above to read cleaned data with correct data types for columns
## use 'join_rgns_info' helper function defined in R/spatial.R
pcb_bio <- join_rgns_info(
  read_clean_df("pcb_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
pcb_sed <- join_rgns_info(
  read_clean_df("pcb_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

#### 3.1.2 Filter PCBs to ICES6 Set or PCB7 for Sediment

The PCBs indicator uses only the ICES6 congeners: CB28, CB52, CB101, CB138, CB153, CB180.  Additionally, only herring are used from the biota datasets, as they are fairly equally spatially distributed across the baltic sea, while many other species are predominantly in the south.

```{r filter pcb data}
## for the PCBs indicator we use the ICE6 congeners:
ices6_congeners <- c("CB101", "CB138", "CB153", "CB180", "CB28", "CB52")
## for PCBs in sediment we use the seven from the Norwegian Environment Agency EQS in sediment for 28 EU priority substances
## note: this sum is also included in the raw dataset as 'SCB7' but as of BHI2.0 all such observations are for the UK 
pcb7sed_congeners <- c("CB28", "CB52", "CB101", "CB118", "CB138", "CB153", "CB180")

all_pcb_bio <- pcb_bio %>% 
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  ## check that rows are distinct: nrow(pcb_bio) == nrow(distinct(pcb_bio))...
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  )
pcb_bio <- filter(all_pcb_bio, variable %in% ices6_congeners)

all_pcb_sed <- pcb_sed %>% 
  filter(!is.na(value_dry_wgt)) %>%
  ## check that rows are distinct: nrow(pcb_sed) == nrow(distinct(pcb_sed))...
  select(
    variable, value_dry_wgt, detect_lim_dry_wgt, quant_lim_dry_wgt,
    num_indiv_subsample, monit_program, monit_purpose, monit_year,
    samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) %>% 
  filter(!is.na(BHI_ID)|!is.na(Subbasin))

pcb_sed <- filter(all_pcb_sed, variable %in% pcb7sed_congeners)
```

<br> 

##### Visualize flagged data in Timeseries {.tabset .tabset-fade .tabset-pills}

###### PCBs in Biota

Below the data are plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

```{r pcbs bio qflag adjustment congeners by basin, results = "show", fig.height = 22, fig.width = 9.5}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
qflag_timeseries_plot <- function(data, valvarname, ylabel){
  
  plotdf <- data %>% 
    mutate(value_adj = ifelse(qflagged, !!sym(valvarname)/2, !!sym(valvarname))) %>% 
    mutate(value_adj_original = ifelse(qflagged, !!sym(valvarname), NA)) %>% 
    group_by(date, variable, Subbasin) %>% 
    mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
    ungroup()
  
  ggplot(plotdf) + 
    scale_color_distiller(palette = "GnBu", direction = -1) +
    geom_point(aes(date, value_adj, color = countObs), show.legend = FALSE, size = 0.7, alpha = 0.5) +
    geom_point(aes(date, value_adj_original), color = "red", shape = 4, size = 1, alpha = 0.6) +
    facet_wrap(
      c("variable", "Subbasin"), 
      labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
      scales = "free_y", 
      ncol = 4
    ) +
    labs(x = NULL, y = ylabel) +
    theme_bw()
}

qflag_timeseries_plot(pcb_bio, "value_wet_wgt", "Congener Concentration (ug/kg wet weight) measured in Clupea harengus")
```

<br>

###### PCBs in Sediment

Same as timeseries plots for biota, but with fewer data points.

```{r pcbs sed qflag adjustment congeners by basin, results = "show", fig.height = 31, fig.width = 9.5}
qflag_timeseries_plot(pcb_sed, "value_dry_wgt", "Congener Concentration (ug/kg) measured in Sediments")
```

<br>

#### 3.1.3 Evaluate Flagged Data, Station Impact, & Sampling Patterns

<br>

**What do the `qflags` indicate? Quantification limits, Flags Codes**

- **<** = less than  

- **>** = greather than  

- **D** = reported value is less than the detection limit (detect_lim)  

- **Q** = reported value is less than the limit of quantification (quant_lim)  

- **~** separates multiple flags  

<br>

```{r what do the qflags indicate, results = "show", fig.width = 9.5, fig.height = 3}
## what do the qflags actually indicate?
chk_pcb_bio_qflags <- pcb_bio %>% 
  select_at(vars(matches("qflag|value|quant|detect"))) %>% 
  filter(qflagged) %>% 
  mutate(qflag = str_split(qflag, "~")) %>% 
  tidyr::unnest(qflag) %>%
  mutate(
    ## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
    ## < and Q flags indicates less than or equal to quantification limit, 
    ## D flag indicates less than detection limit
    chk = case_when(
      qflag == "D" ~ value_wet_wgt < detect_lim_wet_wgt,
      qflag == "Q" ~ value_wet_wgt <= quant_lim_wet_wgt,
      qflag == "<" ~ value_wet_wgt <= quant_lim_wet_wgt
    )
  )
## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
## < and Q flags indicates less than or equal to quantification limit, 
## D flag indicates less than detection limit
ggplot(chk_pcb_bio_qflags) +
  geom_bar(aes(chk, fill = chk), position = position_dodge()) +
  scale_fill_manual(values = c("firebrick", "paleturquoise3"), na.value = "whitesmoke") +
  facet_wrap(~qflag, nrow = 1, scales = "free") +
  labs(
    x = "\nConc. value â‰¤ Quantification Limit ('<' and 'Q'), Conc. value < Detection Limit ('D')", 
    y = NULL, 
    fill = NULL
  )  +
  theme_dark()
```

---

<br>

**Defining two approaches to deal with flagged data, for BHI regions vs Basin**

```{r function to adjust qflagged data}

qflag_adjust <- function(dataset, indicator, congeners = NULL, matrix = "bio", sumcongeners = TRUE, approach = "Adjusted"){
  
  ## Two alternative approaches for summarizing the data:
  ## Adjusted: sum the adjusted values, for the 6 ICES congeners
  ## NoQflag: sum only observation with no qflagged values
  if(approach == "NoQflag"){
    dataset <- filter(dataset, !qflagged)
  }
  
  if(indicator != "dioxin"){
    if(matrix == "bio"){
      dataset <- dataset %>% 
        rename(value_plot = value_wet_wgt) %>% 
        select(-detect_lim_wet_wgt, -quant_lim_wet_wgt)
    } else {
      dataset <- dataset %>% 
        rename(value_plot = value_dry_wgt) %>% 
        select(-detect_lim_dry_wgt, -quant_lim_dry_wgt)
    }
  } else {
    dataset <- dataset %>% 
      rename(value_plot = value_teq) %>% 
      select(-ends_with("_lim_wet_wgt"))
  }
  
  ## aggregate into single date-location values:
  ## sum concentration after flagged data adjustment and date-location averages per congener
  data_Qadjust_sums <- dataset %>% 
    ## adjust for qflags
    ## NOTE if all qflagged are removed, all adjusted values equal original values
    mutate(value_adj = ifelse(qflagged, value_plot/2, value_plot)) %>% 
    ## after dealing with flagged values, may have duplicates; take mean of these 
    select(-qflag, -qflagged, -value_plot) %>% 
    tidyr::pivot_wider(
      names_from = variable, 
      values_from = value_adj,
      values_fn = list(value_adj = mean)
    )
  
  if(indicator == "dioxin"){
    data_Qadjust_sums <- data_Qadjust_sums %>% 
      mutate(sum_congeners = select(., congeners) %>% rowSums(na.rm = TRUE)) %>% 
      mutate(num_congener_in_sum = rowSums(!is.na(select(., congeners))))
  } else {
    ## sum congeners by date and location
    ## remove cases where not all congeners are observed by filtering NAs
    if(sumcongeners & !is.null(congeners)){
      data_Qadjust_sums <- data_Qadjust_sums %>% 
        mutate(sum_congeners = select(., congeners) %>% rowSums()) %>% 
        filter(!is.na(sum_congeners))
    }
  }
  
  return(data_Qadjust_sums)
}

pcb_bio_qflag_adjust <- qflag_adjust(pcb_bio, "pcb", congeners = ices6_congeners)
pcb_sed_qflag_adjust <- qflag_adjust(pcb_sed, "pcb", congeners = pcb7sed_congeners, matrix = "sed")

pcb_bio_noqflag <- qflag_adjust(pcb_bio, "pcb", congeners = ices6_congeners, approach = "NoQflag")
pcb_sed_noqflag <- qflag_adjust(pcb_sed, "pcb", congeners = pcb7sed_congeners, matrix = "sed", approach = "NoQflag")
```

<br>

<!-- To visualize by country or basin pass "country" or "subbasin" respectively to `cntry_or_basin` arguement  -->

```{r function for congeners timeseries monthly by basin, echo = TRUE}
## timeseries plots, congeners by country
plot_cwcon_initial <- function(dataset, col_pal, contam_param = "OC-CB", matrix = "bio", cntry_or_basin = "subbasin"){
  
  ## one of OC-CB, OC-DX or O-FL; becomes OC, DX, or FL respectively
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  if(contam_param == "FL"){contam_param <- "PF"}
  if(contam_param == "DX"){contam_param <- "CD"}
  cntry_or_basin <- str_to_lower(cntry_or_basin)
  
  dat <- dataset %>% 
    rename(subbasin = Subbasin) %>% 
    select(month, Year = year, zone = cntry_or_basin, contains(contam_param)) %>% 
    filter(!is.na(zone), Year > 2000) %>% 
    tidyr::pivot_longer(
      cols = starts_with(contam_param), 
      names_to = "Congener", 
      values_to = "value_plot"
    ) %>%  
    group_by(Congener, month, Year, zone) %>%
    summarize(Value = mean(value_plot, na.rm = TRUE) %>% round(3)) %>%
    ungroup() %>%
    mutate(Date = as.Date(paste("1", month, Year, sep = "-"), tryFormats = "%d-%m-%Y"))
  
  ## reorder factor levels of congeners so colors will match across plots for same congeners
  if(contam_param == "CB"){
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), ices6_congeners))){
      dat$Congener <- factor(dat$Congener, levels = ices6_congeners)
    }
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), pcb7sed_congeners))){
      dat$Congener <- factor(dat$Congener, levels = c(ices6_congeners, "CB118"))
    }
    dioxinlike_pcbs <- c("CB118","CB156","CB105","CB169","CB167","CB77","CB157")
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), dioxinlike_pcbs))){
      dat$Congener <- factor(dat$Congener, levels = dioxinlike_pcbs)
    }
  }
  if(contam_param == "CD"){
    sed_dioxins <- c(
      "CDD1N","CDD4X","CDD6P","CDD6X","CDD9X","CDDO","CDF2N","CDF2T",
      "CDF4X","CDF6P","CDF6X","CDF9P","CDF9X","CDFO","TCDD"
    )
    if(matrix == "sed"){
      dat$Congener <- factor(dat$Congener, levels = sed_dioxins)
    } else {dat$Congener <- factor(dat$Congener, levels = c(sed_dioxins, "CDFDN"))}
  }
  
  
  ## timeseries plots of all congeners by country
  plot <- ggplot(data = dat, aes(Date, Value, fill = Congener)) +
    geom_col(position = "stack", show.legend = FALSE) +
    scale_x_date(
      breaks = function(x){seq.Date(from = min(dat$Date), to = max(dat$Date), by = "3 months")},
      date_labels = "%b %Y"
    ) +
    scale_fill_manual(values = col_pal) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, size = 6)) +
    facet_wrap(~zone, scales = "free_y", ncol = 1)
  
  return(plotly::ggplotly(plot))
}
```

<br>

##### Congeners Timeseries by Basin {.tabset .tabset-fade .tabset-pills}

###### Congeners Monthly Sums, PCBs in Biota

```{r congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
## create color palettes
fullpal <- c(
  RColorBrewer::brewer.pal(8, "Dark2"),
  RColorBrewer::brewer.pal(9, "Set1")
)
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 6)]
plot_cwcon_initial(pcb_bio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country")
```

###### Congeners Monthly Sums, PCBs in Sediments

```{r congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
plot_cwcon_initial(pcb_sed_qflag_adjust, c(cols, "turquoise"), "OC-CB", "sed", "country")
```

<br>

##### Spatial distributions of PCB sampling Locations {.tabset .tabset-fade .tabset-pills}

```{r function for mapping spatial dist of data points}
map_cwcon_initial <- function(dataset, yr, obs_count_limits, matrix = NULL){
  
  if(!"Matrix" %in% names(dataset)){
    dataset <- dataset %>% 
      mutate(Matrix = matrix)
  } else {
    dataset <- dataset %>% 
      mutate(Matrix = ifelse(
        str_detect(Matrix, "bio"), "biota",
        ifelse(str_detect(Matrix, "sed"), "sediment", NA))
      )
    if(nrow(filter(dataset, is.na(Matrix))) > 0){
      message("missing matrix value (bio or sed) in some rows")
    }
  }
  
  df <- left_join(
    bhi_rgns_simple %>% 
      # select(BHI_ID) %>% 
      # mutate(BHI_ID = as.character(BHI_ID)),
      select(HELCOM_ID) %>% 
      mutate(HELCOM_ID = as.character(HELCOM_ID)),
    dataset %>% 
      filter(year %in% yr) %>% 
      # group_by(BHI_ID, Matrix) %>% 
      group_by(Subbasin, HELCOM_ID, Matrix) %>% 
      summarise(
        meanVal = mean(sum_congeners_datemean, na.rm = TRUE),
        matrix_ObservCount = n(),
        numLocation = n_distinct(latitude, longitude)
      ) %>% 
      # group_by(BHI_ID) %>% 
      group_by(Subbasin, HELCOM_ID) %>% 
      mutate(ObservCount = sum(matrix_ObservCount)),
    # by = "BHI_ID"
    by = "HELCOM_ID"
  )
  
  map <- ggplot(df) + 
    geom_sf(aes(fill = ObservCount), color = "burlywood", size = 0.2, alpha = 0.95) +
    scale_fill_gradient(
      low = "midnightblue", 
      high = "lightcyan", 
      na.value = "whitesmoke", 
      limits = obs_count_limits
    ) +
    geom_sf(
      data = st_as_sf(dataset, coords = c("longitude", "latitude"), crs = 4326) %>% filter(year %in% yr), 
      mapping = aes(color = Matrix, shape = Matrix),
      size = 3
    ) +
    scale_color_manual(values = c("limegreen", "brown1")) +
    scale_shape_manual(values = c(13, 13)) +
    theme_linedraw() +
    theme(legend.position = c(0.1, 0.85), legend.background = element_rect(color = "grey")) +
    guides(fill = guide_legend(order = 2))
  
  df <- df %>% 
    st_drop_geometry() %>% 
    filter(!is.na(Matrix)) %>% 
    distinct() %>% 
    right_join(
      tidyr::expand_grid(
        Subbasin = as.character(unique(bhi_rgns_simple$Subbasin)), 
        Matrix = c("biota", "sediment")
      ), 
      by = c("Subbasin", "Matrix")
    )
  
  basinplot <- ggplot(df) +
    geom_point(
      aes(Subbasin, meanVal, fill = matrix_ObservCount, size = numLocation),
      color = "burlywood", shape =  21
    ) +
    labs(x = NULL, y = "Mean concentration (ug/kg)\n", color = NULL) +
    scale_fill_gradient(
      low = "midnightblue", 
      high = "lightcyan", 
      na.value = "whitesmoke", 
      limits = obs_count_limits
    ) +
    facet_grid(rows = vars(Matrix), scales = "free") +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1), 
      legend.position = c(0.85, 0.9),
      legend.background = element_rect(color = "grey"),
      strip.text.y = element_text(size = 8, angle = 0)
    ) +
    guides(fill = FALSE)
  
  return(list(map = map, basinplot = basinplot))
}

## bind resulting dataset to plot together and evaluate....
pcb_qflag_adjust_datemeans <- bind_rows(
  pcb_bio_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "bio"),
  pcb_sed_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "sed")
) %>% ungroup()

pcb_noqflag_datemeans <- bind_rows(
  pcb_bio_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "bio"),
  pcb_sed_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "sed")
) %>% ungroup()
```

###### With just year 2014

```{r map spatial dist of PCBs year 2014, results = "show", fig.width = 9.5, out.width = "120%"}
pcb2014 <- map_cwcon_initial(pcb_qflag_adjust_datemeans, c(0, 10), yr = 2014, matrix = "both")
gridExtra::grid.arrange(pcb2014$map, pcb2014$basinplot, nrow = 1, widths = c(1.2, 1))
```

###### With just year 2016

```{r map spatial dist of PCBs year 2016, results = "show", fig.width = 9.5, out.width = "120%"}
pcb2016 <- map_cwcon_initial(pcb_qflag_adjust_datemeans, c(0, 10), yr = 2016, matrix = "both")
gridExtra::grid.arrange(pcb2016$map, pcb2016$basinplot, nrow = 1, widths = c(1.2, 1))
```

###### With years 2014 to 2019

```{r map spatial dist of PCBs multiple years, results = "show", fig.width = 9.5, out.width = "120%"}
pcb2014to2019 <- map_cwcon_initial(pcb_qflag_adjust_datemeans, c(0, 10), yr = 2014, matrix = "both")
gridExtra::grid.arrange(pcb2014to2019$map, pcb2014to2019$basinplot, nrow = 1, widths = c(1.2, 1))
```

---

<br>

#### 3.1.4 Status and Trend Options

```{r calculations of indicators status and trend}
cwcon_indicators <- function(datalayer, yrs, bio_thresh = 75, sed_thresh = 4.1, approach = "scaledObs", trendlag = 5){
  
  result <- list()
  
  joindf <- BHI_rgns_shp %>% 
    st_drop_geometry() %>% 
    select(-Area_km2) %>% 
    mutate(
      Subbasin = as.character(Subbasin), 
      HELCOM_ID = as.character(HELCOM_ID),
      rgn_nam = as.character(rgn_nam), 
      rgn_key = as.character(rgn_key)
    )
  
  ## STATUS CALCULATIONS
  ## calculate status by subbasins and by bhi regions
  
  result[["basin_status"]] <- datalayer %>%
    filter(year %in% yrs) %>% 
    ## NOTE: CHANGE METHOD FROM BHI1.0
    ## compare to reference point and cap at one before averaging concentrations,
    ## effectively giving more weight to the few higher-concentration values
    mutate(
      health_threshold = ifelse(str_detect(Matrix, "^bio"), bio_thresh, sed_thresh),
      ratio = sum_congeners_datemean/health_threshold,
      ## using pmin to cap the status at one
      dateloc_status = pmin(1, 1/ratio)
    ) %>%
    group_by(HELCOM_ID, Subbasin, Matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      status = mean(dateloc_status, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    
    ## original approach:
    # group_by(HELCOM_ID, Subbasin, Matrix) %>% 
    # summarize(
    #   ## number of date-location specific (aggregated) data points contributing to status
    #   ## plus some other summary statisics of interest
    #   num_dateloc_pts = n(),
    #   mean_dateloc_pts = mean(sum_congeners_datemean, na.rm = TRUE),
    #   max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
    #   min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    # ) %>%
    # ungroup() %>%
    # mutate(
    #   health_threshold = ifelse(str_detect(Matrix, "^bio"), bio_thresh, sed_thresh),
    #   ratio = mean_dateloc_pts/health_threshold,
    #   ## using pmin to cap the status at one
    #   status = pmin(1, 1/ratio)
    # ) %>%
    group_by(HELCOM_ID, Subbasin) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
    right_join(joindf, by = c("Subbasin", "HELCOM_ID"))
  
  result[["bhirgn_status"]] <- datalayer %>%
    filter(year %in% yrs) %>% 
    mutate(
      health_threshold = ifelse(str_detect(Matrix, "^bio"), bio_thresh, sed_thresh),
      ratio = sum_congeners_datemean/health_threshold,
      ## using pmin to cap the status at one
      dateloc_status = pmin(1, 1/ratio)
    ) %>%
    group_by(BHI_ID, Matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      status = mean(dateloc_status, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    group_by(BHI_ID) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
    right_join(joindf, by = c("BHI_ID"))


  ## TREND CALCULATIONS
  ## calculate trend by subbasins and by bhi regions; use method specified in function args
  ## three approaches to calculating trend: mixed-effects, linear model
  for(z in c("basin", "bhirgn")){
    
    if(z == "basin"){
      grpvars <- c("HELCOM_ID", "Subbasin")
      lstname <- "basin_trend"
    } else {
      grpvars <- c("BHI_ID")
      lstname <- "bhirgn_trend"
    }
    
    if(approach == "scaledObs"){
      ## trend approach 1: by observations scaled w.r.t. to reference point
      result[[lstname]] <- datalayer %>% 
        filter(year %in% yrs) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          health_threshold = ifelse(Matrix == "bio", bio_thresh, sed_thresh),
          ratio = sum_congeners_datemean/health_threshold,
          sumcon_datemean_scaled = pmin(1, 1/ratio)
        ) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        do(trend_mdl = lm(sumcon_datemean_scaled ~ year, data = .)) %>%
        mutate(trend = coef(trend_mdl)["year"]*trendlag) %>% 
        ungroup() %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trend, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 2: calculate trend with zscores of data
    if(approach == "zscores"){
      datalayer_zscore <- datalayer %>% 
        filter(year %in% yrs) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          mn = mean(sum_congeners_datemean),
          sd = sd(sum_congeners_datemean),
          zscore = (sum_congeners_datemean-mn)/sd
        )
      if(any(datalayer_zscore$trendcalc_nyrs < 5)){
        message("some trends calculated with fewer than five years")
      }
      if(any(is.na(datalayer_zscore$zscore))){
        message(sprintf(
          "zscore NAs (%s cases) caused trends calculation to fail", 
          nrow(filter(datalayer_zscore, is.na(zscore)))
        ))
      }
      result[[lstname]] <- datalayer_zscore %>% 
        filter(!is.na(zscore)) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        do(trend_mdl = lm(zscore ~ year, data = .)) %>% # regression model to get trend from raw observations
        mutate(trend = coef(trend_mdl)["year"]*trendlag) %>% 
        ungroup() %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trend, na.rm = TRUE)) %>% ## HOW TO INCLUDE SEDIMENT DATA... EQUAL WEIGHT??????
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 3: mixed effects
    ## current error: not enough observations per group...
    ## number of levels of each grouping factor must be < number of observations 
    ## would use the following piece of code to fit model.....
    # do({
    #   if(distinct(., latitude) %>% nrow() > 1){
    #     (trend_mdl = lme4::lmer(zscore ~ year + (1|latitude), data = .))
    #   } else {(trend_mdl = lm(zscore ~ year, data = .))}
    # }) %>% 
  }
  
  return(result)
}
```

<br>

```{r pcbs latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    pcb_qflag_adjust_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)),
    pcb_noqflag_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)),
    by = "Subbasin"
  ) %>% filter(!is.na(Subbasin)),
  align = "lcc", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5.75em; padding-right: 1.5em", 2),
    "padding-left: 10em; padding-right: 1.5em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

**Compare two approaches to deal with flagged data, for BHI regions vs Basin**

1. Remove the flagged observations or adjust values using detect_lim/2; detect_lim values not always provided, so instead, apply transformation to the reported data value
2. Start with mean ICES6 conc. by date and location (our unique observations) 
3. Take mean of all unique obs. for past 5 years in either BHI region or basin
4. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing  

```{r investigate approaches to qflags and summarizing by region vs basin pcb biota indicator, fig.width = 9.5, fig.height = 9}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
pcb_qflag_adjust_indicators <- cwcon_indicators(pcb_qflag_adjust_datemeans, yrs = 2010:2019)
pcb_noqflag_indicators <- cwcon_indicators(pcb_noqflag_datemeans, yrs = 2010:2019)

pcb_status <- bind_rows(
  pcb_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  pcb_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  pcb_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  pcb_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
pcb_status <- pcb_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))

pcb_status$spatialunits <- factor(pcb_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

ggplot(pcb_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = colorRampPalette(fullpal)(42)[sample(1:42, size = 18)]) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```

<br>

**Conclusions:**

<!-- - Including the qflag-adjusted values lowers the mean concentration by date and location -->
<!-- - Including qflag-adjusted values also provides more observations in the Kattegat, The Quark, and W. Gotland Basin  -->
<!-- - Outlier in Eastern Gotland Basin is from Polish observations 2014. Have checked unit conversions etc, have found not error. -->

<!-- - When aggregating by BHI regions, more observations for Regions 1, 11,26,35,36,39,41,42 when including qflagged values -->

<!-- - Use data including qflag-adjusted (this could lower values)   -->
<!-- - Use 5 year mean ICES6 concentration  -->

<br>

```{r save useful intermediate datasets and pcbs contaminants layer}

```


The following pieces of code from data prep `BHI1.0` will be integrated into `functions.R`, to reduce numbers of steps in the more labor-intensive data preparation steps...

```{r calculation of ices6 status and trend}

```

<br>


#### 3.1.5 Methods discussion

**Status formula, ICES6 PCBs Biota**
$X_{\mbox{ICES6}} = \frac{1}{\mbox{mean_ICES6_region/reference_point} \times \mbox{penalty_factor}}$

$\mbox{reference_point} = 75ug/kg \times \mbox{health_threshold}$

Scale between 0 and 1.  If value is below 75, $\mbox{score} = 1$

**Only herring (not other species) used from biota dataset, because herring are most equally spatially spaced across the baltic sea, whereas others are mostly in the south**

<br>

**Notes on Status Calculation**

- Using data including qflag-adjusted (this could lower values for trend)  
- Using 5 year mean ICES6 concentration  
- Scale all observations relative to the human health threshold? **Why Scale?** If values are all below the threshold would not want an increase trend in observed values to suggest that the future status will be worse?? 
- **Need to have mixed-effects to account for different stations?**

<br>

**Trend Considerations**

1. Work on mixed effect model for trends?  
2. Need to think about the interpretation of the data treatment. (a) If use raw observations, then normalize (zscore data), then fit trend, if get increase or decrease but all values are below the threshold, does it make sense to apply a change in the trend to the status?  Would we really think the future status will be lower?  (b) If take all raw observations, calculate "status" as done for the mean value, then fit trend, is this more true to the idea that variation below the human health threshold should not affect the trajectory of the future status?  
3. Need to think if simple linear regression is okay, or if need to account for site?  

<br>

**`BHI1.0` discussions with Anna Sobek **

1. Indicator choice: We agreed that *ICES6 is the best* option  
2. Decision about use of qflagg-adjusted data: *use qflagged data with the adjustement* of (congener conc/2)  
3. Decision about spatial scale of the data: decide best approach is to *calculate for each basin*  
4. Trend decision: best approach is first convert individual observations to a "status" relative to the human health threshold, then fit linear model by basin for *10 year period*. (**TREND CHECK:** Does the trend value need to be rescaled to between -1 and 1? Does not exceed now but need to consider if method broadly works?)  

<!-- **`BHI2.0` discussions with Anna Sobek ** -->


---

<br>

### 3.2 PFOS Indicator

#### 3.2.1 Match BHI Regions

**Use Lat/Long to Match BHI Regions**

```{r assign BHI regions to PFOS data, echo = TRUE, message = FALSE, warning = FALSE}
# use 'join_rgns_info' helper function defined in spatial.R
pfos <- join_rgns_info(
  read_clean_df("pfos_bio_cleaned.csv"),
  helcomID_col = "HELCOM_ID",
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

#### 3.2.2 Filter Organofluorines Data keeping only PFOS in Clupea harengus

Only herring (Clupea harengus) are used from the biota datasets, as they are fairly equally spatially distributed across the baltic sea, while many other species are predominantly in the south. Also, heerring are . In the raw organofluorine dataset, matrix analyzed for most measurements was liver but there were some also where muscle was analyzed. In the initial data cleaning (see `bhi-prep/data/CW/contaminants/v2019/con_data.rmd`), the concentrations from liver measurements were converted to muscle equivalent using the report: [Distribution of PFAS in liver and muscle of herring, perch, cod, eelpout, arctic char, and pike from limnic and marine environments in Sweden. Faxneld et al 2014](https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf).

```{r subset pfos data}
pfos <- pfos %>% 
  filter(!is.na(value_pfos_muscle_equiv_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  filter(variable == "PFOS") %>% 
  select(
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day,
    variable, 
    ## rename variables so functions defined earlier in the script can be applied
    value_wet_wgt = value_pfos_muscle_equiv_wet_wgt, 
    detect_lim_wet_wgt = detect_lim_pfos_muscle_equiv_wet_wgt, 
    quant_lim_wet_wgt = quant_lim_pfos_muscle_equiv_wet_wgt
  )
```

<br>

#### 3.2.3 Evaluate Flagged Data & Sampling Patterns

##### Visualize PFOS flagged data in Timeseries {.tabset .tabset-fade .tabset-pills}

Below the PFOS data are plotted by subbasin. Colorscale in plot one corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination. Plot 2 shows the same information in boxplot format, with data grouped by year. 

###### Concentrations Timeseries with Observation Counts

```{r pfos qflag adjustment values by basin, results = "show", fig.width  = 9.5, fig.height = 8}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
plotdf <- pfos %>% 
  mutate(value_adj = ifelse(qflagged, value_wet_wgt/2, value_wet_wgt)) %>% 
  mutate(value_adj_original = ifelse(qflagged, value_wet_wgt, NA)) %>% 
  group_by(date, variable, Subbasin) %>% 
  mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
  ungroup()

ggplot(plotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1, limits = c(0, 15)) +
  geom_point(aes(date, value_adj, color = countObs), show.legend = FALSE, size = 1.5, alpha = 0.8) +
  ## no flagged values that needed adjustment as of BHI2.0
  # geom_point(aes(date, value_adj_original), color = "red", shape = 4, size = 1, alpha = 0.6) +
  facet_wrap(~ Subbasin, scales = "free_y", ncol = 3) +
  labs(x = NULL, y = "Congener Concentration (ug/kg wet weight) measured in Clupea harengus") +
  theme_bw()
```

###### Concentrations (muscle equivalent) Boxplots by Year

```{r pfos qflag adjusted values basin boxplots, results = "show", fig.width  = 9.5, fig.height = 8}
boxplotdf <- plotdf %>%
  mutate(year = as.factor(year)) %>% 
  group_by(year, variable, Subbasin) %>% 
  mutate(countObs = sum(countObs)) %>% 
  select(year, date, variable, Subbasin, meanAdjww, countObs) %>% 
  distinct()

ggplot(boxplotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1, limits = c(0, 155)) +
  scale_fill_distiller(palette = "GnBu", direction = -1, limits = c(0, 155)) +
  geom_boxplot(
    aes(year, meanAdjww, color = countObs, fill = countObs), 
    show.legend = FALSE, 
    alpha = 0.4, 
    outlier.size = 0.3
  ) + 
  facet_wrap(~ Subbasin, ncol = 3) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = NULL, y = "Congener Concentration (daily mean, ug/kg wet weight) measured in Clupea harengus") +
  theme_bw()
```

***

<br>

**Spatial distributions of PFOS sampling Locations, Years 2014-2019**

```{r pfos map of data records, results = "show", fig.width = 9.5, out.width = "150%"}
pfos_qflag_adjust <- qflag_adjust(pfos, sumcongeners = FALSE)
pfos_qflag_adjust_datemeans <- pfos_qflag_adjust %>% 
  group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
  summarize(sum_congeners_datemean = mean(PFOS, na.rm = TRUE)) %>%
  mutate(Matrix = "bio") %>% 
  ungroup()

pfos_noqflag <- qflag_adjust(pfos, sumcongeners = FALSE, approach = "NoQflag")
pfos_noqflag_datemeans <- pfos_noqflag %>% 
  group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
  summarize(sum_congeners_datemean = mean(PFOS, na.rm = TRUE)) %>% 
  mutate(Matrix = "bio") %>% 
  ungroup()

pfos2008to2019 <- map_cwcon_initial(pfos_qflag_adjust_datemeans, c(0, 40), yr = 2008:2019)
gridExtra::grid.arrange(pfos2008to2019$map, pfos2008to2019$basinplot, nrow = 1, widths = c(1.2, 1))
```

<br>

#### 3.2.4 Status and Trend Options

```{r pfos latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    pfos_qflag_adjust_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)),
    pfos_noqflag_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)),
    by = "Subbasin"
  ) %>% filter(!is.na(Subbasin)),
  align = "lcc", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5.75em; padding-right: 1.5em", 2),
    "padding-left: 10em; padding-right: 1.5em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

```{r investigate approaches to qflags and summarizing by region vs basin pfos indicator, fig.width = 9.5, fig.height = 9}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
pfos_qflag_adjust_indicators <- cwcon_indicators(pfos_qflag_adjust_datemeans, yrs = 2010:2019, bio_thresh = 9.1)
pfos_noqflag_indicators <- cwcon_indicators(pfos_noqflag_datemeans, yrs = 2010:2019, bio_thresh = 9.1)

pfos_status <- bind_rows(
  pfos_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  pfos_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  pfos_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  pfos_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
pfos_status <- pfos_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))

pfos_status$spatialunits <- factor(pfos_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

ggplot(pfos_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = colorRampPalette(fullpal)(42)[sample(1:42, size = 18)]) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```


**Conclusions:**

<br>

```{r save pfos contaminants layers}

```

<br>

The following pieces of code from data prep `BHI1.0` will be integrated into `functions.R`, to reduce numbers of steps in the more labor-intensive data preparation steps...

```{r calculation of pfos status and trend}

```

#### 3.2.5 Methods discussion


**Trend Calculation**

Calculate the trend over five-year data period using unique date/location observations (mean of site samples) transformed to status values. Trend calculated per basin.

$X_{basin} = \mbox{slope }\times \mbox{year } + \mbox{intercept }$

$\mbox{Trend} = 5 \times \mbox{slope }$


---

<br>

### 3.3 Dioxin Indicator
#### 3.3.1 Match BHI Regions

**Match BHI Regions**

```{r assign BHI regions to Dioxin data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'join_rgns_info' helper function defined in spatial.R
dioxin_bio <- join_rgns_info(
  read_clean_df("dioxin_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
dioxin_sed <- join_rgns_info(
  read_clean_df("dioxin_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

<br>

Dioxins and dioxin-like PCBs still separate objects for these next steps.

<br>

#### 3.3.2 Filter Dioxin-like PCBs to join with Dioxins dataset, and Convert all to Toxic Equivalents

**Filter PCB to keep only dioxin-like PCBs, convert units, and convert to TEQ**

To convert dioxin and dioxin-like PCB congener concentrations to toxic equivalents we use the [IPCS Reference Table](https://www.who.int/ipcs/assessment/tef_values.pdf), taken from The 2005 World Health Organization Re-evaluation of Human and Mammalian Toxic Equivalency Factors for Dioxins and Dioxin-like Compounds (Van den Berg et al, 2005).

```{r TEQ conversion lookup, results = "hide"}
tef_pdf <- pdftools::pdf_text("https://www.who.int/ipcs/assessment/tef_values.pdf")[1] %>%
  stringr::str_split(pattern = "\n")
tef_lookup <- as.data.frame(tef_pdf[[1]][2:34])
colnames(tef_lookup) <- "singlecolumn"
tidyr::separate(tef_lookup, singlecolumn, c("WHO_compound_name", "TEF_1998", "TEF_2005"), "\\s\\s+")

## manually matched with ICES congeners names...
## congeners in the tablee without a TEF value are not dioxin-like
lookup_tef <- read_csv(here::here("supplement", "lookup_tabs", "tef_conversion_lookup.csv"))
```

<br>

```{r filter dioxin like PCBs and convert units ug to pg per gram}
## get dioxin-like PCBs by joining TEF lookup table
## filter out congeners without a TEF conversion
## convert from micrograms/kilogram to picograms/gram and calculate TEQs
## ug/kg equivalent to 1000 pg/g
dioxinlike_pcbbio_teq <- all_pcb_bio %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_wet_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("wet_wgt"))

dioxinlike_pcbsed_teq <- all_pcb_sed %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_dry_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("dry_wgt"))
```

<br>

**Use TEF conversion factor to convert Dioxin concentrations to TEQ**

```{r subset dioxin data}
dioxin_bio <- dioxin_bio %>%
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  ## check that rows are distinct: nrow(dioxin_bio) == nrow(distinct(dioxin_bio))...
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) 

dioxin_sed <- dioxin_sed %>%
  filter(!is.na(value_dry_wgt)) %>%
  ## check that rows are distinct: nrow(dioxin_sed) == nrow(distinct(dioxin_sed))...
  select(
    variable, value_dry_wgt, detect_lim_dry_wgt, quant_lim_dry_wgt,
    num_indiv_subsample, monit_program, monit_purpose, monit_year,
    samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) %>% 
  filter(!is.na(BHI_ID)|!is.na(Subbasin))
```


```{r convert to TEQ and plot by country}
dioxinbio_teq <- dioxin_bio %>%
  ## filter out congeners without a TEF conversion
  ## convert from micrograms/kilogram to picograms/gram and calculate TEQs
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_wet_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("wet_wgt"))

dioxinsed_teq <- dioxin_sed %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_dry_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("dry_wgt"))
```


##### Checking Outliers/Questionable Measurements {.tabset .tabset-fade .tabset-pills}

###### Dioxin-like PCBs in Biota

```{r checking dioxinlike pcb bio data and outliers, results = "show", fig.width = 9.5, fig.height = 8}
## something funky with some stations are these outliers or incorrectly recorded data??
dioxinlike_pcbbio_teq <- dioxinlike_pcbbio_teq %>% 
  mutate(
    ## points in 2014 in poland highlighted in BHI1.0 as questionable...
    ## for some reason it is the nonflagged data that are the problem?
    chk0 = (country == "Poland" & year == 2014 & !qflagged),
    ## additional points to investigate...
    chk1 = (station == "473" & year == 2015 & month == 7),
    chk2 = (station %in% c("SJB1454000", "SJB1455000", "SJB1453000") & year == 2018 & month == 10),
    chk3 = (station == "SJB1453000" & year == 2017 & month == 10),
    chk = !chk0&!chk1&!chk2&!chk3
  )
plotdf <- mutate(dioxinlike_pcbbio_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 

makeplot <- function(data){
  ggplot(data) + 
    geom_point(aes(date, value_adj), show.legend = FALSE, size = 0.5, alpha = 0.5, color =  "grey") +
    facet_wrap(~variable, scales = "free_y", nrow = length(unique(data$variable))) +
    labs(x = NULL, y = NULL)
}
gridExtra::grid.arrange(
  makeplot(plotdf) + 
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk1)) + 
    geom_point(data = filter(plotdf, !chk1&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O station 473 July2015"),
  makeplot(filter(plotdf, !chk1&!chk2)) + 
    geom_point(data = filter(plotdf, !chk1&!chk2&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O SJB1454000/5000/3000, Oct2018"),
  makeplot(filter(plotdf, chk)) +
    ggtitle("All questionable points removed"),
  ncol = 4
)
dioxinlike_pcbbio_teq <- filter(dioxinlike_pcbbio_teq, chk) %>% select(-starts_with("chk"))
```

###### Dioxin-like PCBs in Sediment

```{r checking dioxinlike pcb sed data and outliers, results = "show", fig.width = 9.5, fig.height = 8}
dioxinlike_pcbsed_teq <- dioxinlike_pcbsed_teq %>% 
  mutate(
    chk0 = (station == "FYN 3" & samp_ref == 293730),
    chk1 = (country == "Estonia" & qflag == "<" & variable %in% c("CB157", "CB167", "CB169")),
    chk = !chk0&!chk1
  )
plotdf <- dioxinlike_pcbsed_teq %>% 
  mutate(value_adj = ifelse(qflagged, value_teq/2, value_teq), country = as.factor(country))
plotdf$country <- factor(plotdf$country, levels = unique(plotdf$country)) # estonia last for matching palettes!

gridExtra::grid.arrange(
  makeplot(plotdf) +
    geom_point(aes(date, value_adj, color = country), alpha = 0.5, size = 0.5, show.legend = FALSE) +
    scale_color_manual(values = c(rep("grey", 7), "coral")) +
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk0)) + 
    geom_point(data = filter(plotdf, !chk0&!chk), aes(date, value_adj), shape = 1) +
    geom_point(aes(date, value_adj, color = country), alpha = 0.5, size = 0.5, show.legend = FALSE) +
    scale_color_manual(values = c(rep("grey", 7), "coral")) +
    ggtitle("W/O station FYN 3 sample #293730 Oct2000"),
  makeplot(filter(plotdf, chk)) + 
    ggtitle("All questionable points removed"),
  ncol = 3
)
dioxinlike_pcbsed_teq <- filter(dioxinlike_pcbsed_teq,chk) %>% select(-starts_with("chk"))
```

###### Dioxins in Biota

```{r checking dioxin biota data and outliers, results = "show", fig.width = 9.5, fig.height = 18}
## something funky with some stations are these outliers or incorrectly recorded data??
dioxinbio_teq <- dioxinbio_teq %>% 
  mutate(
    chk0 = (station == "473" & year == 2015 & month == 7),
    chk1 = (station %in% c("SJB1454000", "SJB1455000", "SJB1453000") & year == 2018 & month == 10),
    chk = !chk0&!chk1
    # chk2 = (station == "UtlÃ¤ngan" & year == 2014 & month == 6),
    # chk = !chk0&!chk1&!chk2
  )
plotdf <- mutate(dioxinbio_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 

gridExtra::grid.arrange(
  makeplot(plotdf) + 
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk0)) + 
    geom_point(data = filter(plotdf, !chk0&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O station 473 July2015"),
  makeplot(filter(plotdf, !chk0&!chk1)) + 
    geom_point(data = filter(plotdf, !chk0&!chk1&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O SJB1454000/5000/3000, Oct2018"),
  makeplot(filter(plotdf, chk)) +
    ggtitle("All questionable points removed"),
  ncol = 4
)
dioxinbio_teq <- filter(dioxinbio_teq, chk) %>% select(-starts_with("chk"))
```

###### Dioxins in Sediment

```{r checking dioxin sediment data and outliers, results = "show", fig.width = 9.5, fig.height = 5.7}
## something funky with some stations are these outliers or incorrectly recorded data??
dioxinsed_teq <- dioxinsed_teq %>% 
  mutate(
    chk0 = (station == "NORS-AlsMole" & year == 2007 & month == 12),
    chk1 = (station == "STO0501059" & year == 2007 & month == 11),
    chk2 = (station == "NORS-Blaakilde" & year == 2014 & month == 12),
    chk = !chk0&!chk1&!chk2
  )
plotdf <- mutate(dioxinsed_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 
## no apparent patterns in outliers to raise concern here
makeplot(plotdf) +
  facet_wrap(~variable, scales = "free_y", nrow = 5) +
  geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
  ggtitle("All Data")
```

<br>

##### Visualize flagged data in Timeseries {.tabset .tabset-fade .tabset-pills}

Below the data are plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

###### Dioxin-like PCBs in Biota

```{r pcbs bio qflag adjustment congeners by basin, results = "show", fig.width = 9.5, fig.height = 18}
qflag_timeseries_plot(dioxinlike_pcbbio_teq, "value_teq", "Congener Concentration (ug/kg TEQ wet weight) in Clupea Harengus")
```

###### Dioxin-like PCBs in Sediment

```{r pcbs sed qflag adjustment congeners by basin, results = "show", fig.width = 9.5, fig.height = 20.7}
qflag_timeseries_plot(dioxinlike_pcbsed_teq, "value_teq", "Congener Concentration (ug/kg TEQ dry weight) in Sediments")
```

###### Dioxins in Biota

```{r pcbs bio qflag adjustment congeners by basin, results = "show", fig.width = 9.5, fig.height = 38.7}
qflag_timeseries_plot(dioxinbio_teq, "value_teq", "Congener Concentration (ug/kg TEQ wet weight) in Clupea Harengus")
```

###### Dioxins in Sediment

```{r pcbs sed qflag adjustment congeners by basin, results = "show", fig.width = 9.5, fig.height = 45.9}
qflag_timeseries_plot(dioxinsed_teq, "value_teq", "Congener Concentration (ug/kg TEQ dry weight) in Sediments")
```

<br>

#### 3.3.3 Evaluate Flagged Data & Sampling Patterns

**Adjust Qflagged values**

Use $LOD/2$ approach to adjust values. Because we do not have the LOD in all cases, use: $adjustedValue = value / 2$

<br>

**TEQ concentrations per Sample**

1. Sum TEQ concentration values for each `sub_samp_ref` in dioxin and dioxin-like PCBs in biota separately, and count number of congeners included in that sum
2. Sum TEQ concentration values for each `samp_ref` in dioxin and dioxin-like PCB in sediment separately, and count number of congeners included in that sum
3. Mean TEQ values by date and location, for each of the four datasets: dioxin-like pcbs in biota and sediments, and dioxins in biota and sediments. For observations averaged, track the mean/min/max number of congeners in each of the observations, and count the number of observations for each date and location grouping.

```{r adjust qflagged data for dioxin and dioxinlike pcbs teq data}
lapply(
  list(
    ## dioxin-like PCBs in biota, two approaches to handling qflags
    list(df = "dioxinlike_pcbbio_teq", mat = "bio", apr = "Adjusted"),
    list(df = "dioxinlike_pcbbio_teq", mat = "bio", apr = "NoQflag"),
    ## dioxin-like PCBs in sediment, two approaches to handling qflags
    list(df = "dioxinlike_pcbsed_teq", mat = "sed", apr = "Adjusted"),
    list(df = "dioxinlike_pcbsed_teq", mat = "sed", apr = "NoQflag"),
    ## Dioxins in biota, two approaches to handling qflags
    list(df = "dioxinbio_teq", mat = "bio", apr = "Adjusted"),
    list(df = "dioxinbio_teq", mat = "bio", apr = "NoQflag"),
    ## Dioxins in sediment, two approaches to handling qflags
    list(df = "dioxinsed_teq", mat = "sed", apr = "Adjusted"),
    list(df = "dioxinsed_teq", mat = "sed", apr = "NoQflag")
  ),
  function(x){
    congeners <- unique(get(x$df)$variable)
    result <- qflag_adjust(get(x$df), indicator = "dioxin", congeners, matrix = x$mat, approach = x$apr)
    assign(
      str_replace(x$df, "teq", ifelse(x$apr == "Adjusted", "qflag_adjust", "noqflag")), 
      result, 
      envir = .GlobalEnv
    )
  }
)
```

<br>

<!-- To visualize by country or basin pass "country" or "subbasin" respectively to `cntry_or_basin` arguement  -->

##### Congeners Timeseries by Basin {.tabset .tabset-fade .tabset-pills}

###### Congeners Monthly Sums, Dioxin-like PCBs in Biota

```{r congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 7)]
plot_cwcon_initial(dioxinlike_pcbbio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country")
```

###### Congeners Monthly Sums, Dioxin-like PCBs in Sediments

```{r congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
plot_cwcon_initial(dioxinlike_pcbsed_qflag_adjust, cols, "OC-CB", "sed", "country")
```

###### Congeners Monthly Sums, Dioxins in Biota

```{r congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 16)]
plot_cwcon_initial(dioxinbio_qflag_adjust, col_pal = cols, contam_param = "OC-DX", cntry_or_basin = "country")
```

###### Congeners Monthly Sums, Dioxins in Sediments

```{r congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 9}
plot_cwcon_initial(dioxinsed_qflag_adjust, col_pal = cols[-16], contam_param = "OC-DX", cntry_or_basin = "country")
```

---

<br>

**Get mean TEQs by Date and Location for Plotting**

Calculate the sum of the mean dioxin and the mean dioxin-like PCB TEQ value for each date and location. For observations averaged, also calculate mean, min, and max number of congeners in each of the observations, and also numbers of observations for each date and location.

```{r mapping spatial distribution of dioxin and dioxinlike pcbs data}
lapply(
  list(
    list("dioxinlike_pcbbio_qflag_adjust", "dioxinlike_pcbsed_qflag_adjust"),
    list("dioxinlike_pcbbio_noqflag", "dioxinlike_pcbsed_noqflag"),
    list("dioxinbio_qflag_adjust", "dioxinsed_qflag_adjust"),
    list("dioxinbio_noqflag", "dioxinsed_noqflag")
  ),
  function(x){
    datemeandf <- bind_rows(
      get(x[[1]]) %>% 
        group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
        summarize(
          sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE),
          mean_congener_in_sum = mean(num_congener_in_sum, na.rm = TRUE),
          min_congener_in_sum = min(num_congener_in_sum, na.rm = TRUE),
          max_congener_in_sum = max(num_congener_in_sum, na.rm = TRUE)
        ) %>% 
        mutate(Matrix = "bio"),
      get(x[[2]]) %>% 
        group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
        summarize(
          sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE),
          mean_congener_in_sum = mean(num_congener_in_sum, na.rm = TRUE),
          min_congener_in_sum = min(num_congener_in_sum, na.rm = TRUE),
          max_congener_in_sum = max(num_congener_in_sum, na.rm = TRUE)
        ) %>% 
        mutate(Matrix = "sed")
    ) %>% ungroup()
    
    dfname <- paste(str_remove(x[[1]], "bio"), "datemeans", sep = "_")
    assign(dfname, datemeandf, envir = .GlobalEnv)
  }
)
```

<br>

##### Spatial distributions of Dioxin and Dioxin-like PCBs sampling Locations {.tabset .tabset-fade .tabset-pills}

###### Dioxin-like PCBs years 2016-2019

```{r map spatial dist of PCBs year 2014, results = "show", fig.width = 9.5, out.width = "120%"}
mapdioxinlikepcb <- map_cwcon_initial(dioxinlike_pcb_qflag_adjust_datemeans, c(0, 15), yr = 2016:2019, matrix = "both")
gridExtra::grid.arrange(
  mapdioxinlikepcb$map + labs(y = "Mean concentration (pg/g)\n"), 
  mapdioxinlikepcb$basinplot, 
  nrow = 1, 
  widths = c(1.2, 1)
)
```

###### Dioxins years 2016-2019

```{r map spatial dist of PCBs year 2016, results = "show", fig.width = 9.5, out.width = "120%"}
mapdioxins <- map_cwcon_initial(dioxin_qflag_adjust_datemeans, c(0, 15), yr = 2016:2019, matrix = "both")
gridExtra::grid.arrange(
  mapdioxins$map + labs(y = "Mean concentration (pg/g)\n"), 
  mapdioxins$basinplot, 
  nrow = 1, 
  widths = c(1.2, 1)
)
```

---

<br>

**Assess if Dioxins and dioxin-like PCBs data overlap**

Were dioxins and PCBs measured from the same samples such that a total TEQ value per sample can be calculated?

1. Join dioxins and dioxin-like PCBs by `sub_samp_ref` or `samp_ref`, `date`, `latitude`, `longitude`
2. Get TEQ concentration for each sample reference
3. Take mean to get single TEQ value per date-location

```{r assess dioxin pcb overlaps in biota data, eval = FALSE}
## check unique and matching sub_sample_ref
## any cases where sub_samp_ref appears in dioxin and pcb datasets? yes...
length(intersect(
  unique(dioxinlike_pcbbio_teq$sub_samp_ref), 
  unique(dioxinbio_teq$sub_samp_ref)
))

## check any shared location and sample dates?
full_join(
  dioxinlike_pcbbio_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(dioxin = TRUE),
  dioxinbio_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(pcb = TRUE),
  by = c("country", "station", "date")
) %>% filter(dioxin & pcb)
```

<br>

```{r assess dioxin pcb overlaps in sediments data, eval = FALSE}
## check unique and matching sub_sample_ref
## any cases where sub_samp_ref appears in dioxin and pcb datasets? yes...
length(intersect(
  unique(dioxinlike_pcbsed_teq$samp_ref), 
  unique(dioxinsed_teq$samp_ref)
))

## check any shared location and sample dates?
full_join(
  dioxinlike_pcbsed_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(dioxin = TRUE),
  dioxinsed_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(pcb = TRUE),
  by = c("country", "station", "date")
) %>% filter(dioxin & pcb)
```

<br>

**Join dioxin and dioxin-like PCB observations**

Join dioxin and dioxin-like PCB observations by shared date and location. Use `inner_join` to retain only observations where both dioxin and dioxin-like PCBs were measured.

```{r sum dioxin and dioxinlike pcb mean teq values by date and location and plot, results = "show", fig.width = 9.5}
dioxins_qflag_adjust_teqs_total <- inner_join(
  dioxinlike_pcb_qflag_adjust_datemeans %>% 
    rename(
      sum_congeners_datemean_pcb = sum_congeners_datemean, 
      mean_congener_in_sum_pcb = mean_congener_in_sum,
      min_congener_in_sum_pcb = min_congener_in_sum,
      max_congener_in_sum_pcb = max_congener_in_sum
    ), 
  dioxin_qflag_adjust_datemeans %>% 
    rename(
      sum_congeners_datemean_dioxin = sum_congeners_datemean, 
      mean_congener_in_sum_dioxin = mean_congener_in_sum,
      min_congener_in_sum_dioxin = min_congener_in_sum,
      max_congener_in_sum_dioxin = max_congener_in_sum
    )
) %>% mutate(total_teq = sum_congeners_datemean_pcb + sum_congeners_datemean_dioxin)

dioxins_noqflag_teqs_total <- inner_join(
  dioxinlike_pcb_noqflag_datemeans %>% 
    rename(
      sum_congeners_datemean_pcb = sum_congeners_datemean, 
      mean_congener_in_sum_pcb = mean_congener_in_sum,
      min_congener_in_sum_pcb = min_congener_in_sum,
      max_congener_in_sum_pcb = max_congener_in_sum
    ), 
  dioxin_noqflag_datemeans %>% 
    rename(
      sum_congeners_datemean_dioxin = sum_congeners_datemean, 
      mean_congener_in_sum_dioxin = mean_congener_in_sum,
      min_congener_in_sum_dioxin = min_congener_in_sum,
      max_congener_in_sum_dioxin = max_congener_in_sum
    )
) %>% mutate(total_teq = sum_congeners_datemean_pcb + sum_congeners_datemean_dioxin)
```

---

<br>

#### 3.3.3 Status and Trend Options

```{r dioxins latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    dioxins_qflag_adjust_teqs_total %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)),
    dioxins_noqflag_teqs_total %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)),
    by = "Subbasin"
  ) %>% filter(!is.na(Subbasin)),
  align = "lcc", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5.75em; padding-right: 1.5em", 2),
    "padding-left: 10em; padding-right: 1.5em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

<br>

**Compare two approaches to deal with flagged data, for BHI regions vs Basin**

1. Start with total TEQs: congeners summed per sample, means by date and location, dioxin and dioxin-like PCB summes added together per unique date and location  
2. Take mean of all unique obs. for latest 5 years in either BHI region or basin
3. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing

```{r investigate approaches to qflags and summarizing by region vs basin pcb biota indicator, fig.width = 9.5, fig.height = 9}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
dioxin_qflag_adjust_indicators <- cwcon_indicators(
  dioxins_qflag_adjust_teqs_total %>% rename(sum_congeners_datemean = total_teq), 
  bio_thresh = 6.5, sed_thresh = 0.86, 
  yrs = 2014:2018
)
dioxin_noqflag_indicators <- cwcon_indicators(
  dioxins_noqflag_teqs_total %>% rename(sum_congeners_datemean = total_teq), 
  bio_thresh = 6.5, sed_thresh = 0.86, 
  yrs = 2014:2018
)
dioxin_status <- bind_rows(
  dioxin_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  dioxin_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  dioxin_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  dioxin_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
dioxin_status <- dioxin_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))

dioxin_status$spatialunits <- factor(dioxin_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

ggplot(dioxin_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = colorRampPalette(fullpal)(42)[sample(1:42, size = 18)]) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```

<br>

**Conclusions:**

<br>

---

#### 3.3.4 Methods discussion

**Dioxin indicator status**

$X_{TEQstatus} = \frac{1}{\mbox{dioxin + } \mbox{dioxin-like pcb teq value / teq threshold }}$

**Dioxin indicator trend**

<br/>

## 4. Visualizing Contaminants Data Layers

```{r read in indicator layers and join into single object}

```

### 4.1 Plotting Indicators for Comparison

### 4.2 Number of Indicators per BHI Region and Subbasin

### 4.3 Trends by BHI Region

```{r plot basin trends for all indicators}

```

### 4.4 Status Timeseries Plots

### 4.5 Contaminants data layers Map

<br>

<br>

## 5. Considerations for `BHI3.0`

<br>

## 6. References

<br>

```{r References, child = refs_path, results = "asis", echo = FALSE}
```

<br>