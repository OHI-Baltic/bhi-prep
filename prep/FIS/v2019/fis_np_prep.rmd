---
title: "Wild-Caught Fisheries - Food Provision Subgoal"
output:
  html_document:
    toc: true
    toc_depth: 4
---

```{r preamble prep}
loc <- file.path(here::here(), "prep", "FIS")

source(file.path(here::here(), "R", "setup.R"))
source(file.path(here::here(), "R", "prep.R"))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, results = "hide", fig.width=9.5)

bkgd_path <- file.path(here::here(), "supplement", "goal_summaries", "FIS.Rmd")
data_path <- file.path(here::here(), "data", "FIS", version_year, "fis_np_data.rmd")
refs_path <- file.path(loc, "fis_references.Rmd")

dir_layer <- file.path(here::here(), "layers")
```

## 1. Background

```{r background, child = bkgd_path, results = "asis", echo = FALSE}
```

<br/>

<!-- ## 2. Data --- header in the child  document -->
```{r data, child = data_path, results = "asis", echo = FALSE}
```

<br/>

## 3. Prep: Wrangling & Derivations, Checks/Evaluation, Gapfilling

### 3.1 Reorganizing/wrangling

This section prepares data layers for FIS and NP at the same time, separating the fish stocks for each:

- FIS stocks: cod_22-24, cod_25-32, her_28.1, her_20-24, her_25-29,32, her_30-31
- NP stocks: spr_22-32

<br>

#### 3.1.1 Load datasets

Each assessed stock has its own raw datafile. Cod and herring data are saved under `Goals/FP/FIS` and sprat data are saved in the `Goals/NP` folder.

The MSY values (FMSY and BMSY for each assessed stock) are taken from the ICES advice reports, linked in the `standardgraphs.ices.dk` aspx pages. No table is saved with these values- they are entered directly into a dataframe in the code below.

```{r load raw data, message = FALSE, warning = FALSE}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "FP", "FIS") # list.files(dir_rawdata)

## Fisheries data from ICES
## if csvs are saved w/ semicolons:
# source(file.path(here::here(), "R", "semicolon_to_comma.R"))
# lapply(
#   list("cod_SDs22_24", "cod_SDs24_32",
#        "herring_SD_28.1", "herring_SDs20_24",
#        "herring_SDs25_29_32", "herring_SDs30_31"),
#   function(x){
#      fp <- file.path(dir_rawdata, x, paste0(x, "_reformat.csv"))
#      semicolon_to_comma(fp, remove_na_cols = TRUE, overwrite = TRUE)
#   }
# )
# semicolon_to_comma(file.path(dir_B, "Goals", "NP", "sprat_SDs22_32", "sprat_SDs22_32_reformat.csv"), TRUE, TRUE)


## cod data
cod1raw <- read_csv(file.path(dir_rawdata, "cod_SDs22_24", "cod_SDs22_24_reformat.csv"))
cod2raw <- read_csv(file.path(dir_rawdata, "cod_SDs24_32", "cod_SDs24_32_reformat.csv"))

## herring data
herring1raw <- read_csv(file.path(dir_rawdata, "herring_SD_28.1", "herring_SD_28.1_reformat.csv"))
herring2raw <- read_csv(file.path(dir_rawdata, "herring_SDs20_24", "herring_SDs20_24_reformat.csv"))
herring3raw <- read_csv(file.path(dir_rawdata, "herring_SDs25_29_32", "herring_SDs25_29_32_reformat.csv"))
herring4raw <- read_csv(file.path(dir_rawdata, "herring_SDs30_31", "herring_SDs30_31_reformat.csv"))

## sprat data
sprat1raw <- read_csv(file.path(dir_B, "Goals", "NP", "sprat_SDs22_32", "sprat_SDs22_32_reformat.csv"))


## make MSY values table
## these values are obtained from ICES reports, see data/FIS/fis_np_data.rmd for more details
msy_data <- t(data.frame(
  c("cod", "22-24", "cod_SDs22_24", 21876, 0.26),
  c("cod", "24-32", "cod_SDs24_32", 108035, 0.3),
  c("herring", "28.1", "herring_SD_28.1", 60000, 0.32),
  c("herring", "20-24", "herring_SDs20_24", 150000, 0.31),
  c("herring", "25-29,32", "herring_SDs25_29_32", 600000, 0.22),
  c("herring", "30-31", "herring_SDs30_31", 140998, 0.15),
  c("sprat", "22-32", "sprat_SDs22_32", 570000, 0.26)
))
## for testing effect of using 2013 values...
# msy_2013_data <- t(data.frame(
#   c("cod", "22-24", "cod_SDs22_24", 36400, 0.26),
#   c("cod", "24-32", "cod_SDs24_32", 88200, 0.46),
#   c("herring", "28.1", "herring_SD_28.1", 60000, 0.35),
#   c("herring", "20-24", "herring_SDs20_24", 110000, 0.28),
#   c("herring", "25-29,32", "herring_SDs25_29_32", 600000, 0.26),
#   c("herring", "30-31", "herring_SDs30_31", 316000, 0.15),
#   c("sprat", "22-32", "sprat_SDs22_32", 570000, 0.29)
# ))
# msy_data <- msy_2013_data
colnames(msy_data) <- c("species", "SDs", "stockname", "BMSY", "FMSY")
rownames(msy_data) <- NULL
msy_data <- as_tibble(msy_data)
```

<br>

#### 3.1.2 Merge datasets and calculate F/FMSY and B/BMSY ratios

```{r merge datasets and calculate ffmsy bbmsy ratios}
combined_rawdata <- rbind(
  ## cod
  cod1raw %>% 
    dplyr::select(
      year, ssb, 
      fis_mort = fishing_mortality_age3_5, 
      landings = landings_tonnes
    ) %>%
    mutate(stockname = "cod_SDs22_24"),
  cod2raw %>% 
    dplyr::select(
      year, ssb, 
      fis_mort = fishing_mortality_age4_6, 
      landings = landings_tonnes
    ) %>% 
    mutate(stockname = "cod_SDs24_32"),
  ## herring
  herring1raw %>% 
    dplyr::select(
      year, ssb = ssb_tonnes, 
      fis_mort = `F`, 
      landings = catches_tonnes
    ) %>% 
    mutate(stockname = "herring_SD_28.1"),
  herring2raw %>% 
    dplyr::select(
      year, ssb = ssb_tonnes, 
      fis_mort = F_age3_6, 
      landings = catches_tonnes
    ) %>% 
    mutate(stockname = "herring_SDs20_24"),
  herring3raw %>% 
    dplyr::select(
      year, ssb = ssb_tonnes, 
      fis_mort = F_age3_6, 
      landings = catches_tonnes
    ) %>% 
    mutate(stockname = "herring_SDs25_29_32"),
  herring4raw %>% 
    dplyr::select(
      year, ssb = ssb, 
      fis_mort = F_age3_7, 
      landings = catches_tonnes
    ) %>% 
    mutate(stockname = "herring_SDs30_31"),
  ## sprat
  sprat1raw %>% 
    dplyr::select(
      year, ssb = ssb_tonnes, 
      fis_mort = F_age3_5, 
      landings = catches_tonnes
    ) %>% 
    mutate(stockname = "sprat_SDs22_32")) %>% 
  ## join with msy data
  filter(!is.na(year)) %>% 
  left_join(msy_data, by = c("stockname")) %>% 
  mutate(bbmsy = ssb/as.numeric(BMSY), ffmsy = fis_mort/as.numeric(FMSY)) %>% 
  arrange(species, stockname, year)
```

<br>

#### 3.1.3 Convert from ICES Fisheries Subdivisions to BHI Regions

[Map of ICES regions.](ICES regions map https://www.ices.dk/marine-data/Documents/Maps/ICES-Ecoregions-hybrid-statistical-areas.png)
The map below shows the overlap between ICES subdivisions and the BHI regions:

```{r how the ICES and BHI regions overlap, results = "show"}
source(file.path(here::here(), "R", "spatial.R"))
regions_shape() # loads spatial features objects

## ICES shapefile has crs EPSG:3035
## https://spatialreference.org/ref/epsg/etrs89-etrs-laea/
## transform to match BHI crs of EPSG:4326, and simplify

ices_transform <- rmapshaper::ms_simplify(input = ICES_rgns_shp) %>% 
  sf::st_as_sf() %>% 
  sf::st_transform(crs = 4326)

bhi_rgns_simple <- rmapshaper::ms_simplify(input = BHI_rgns_shp) %>% 
  sf::st_as_sf() # also simplify BHI shp for plotting
baltic <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
  st_crop(xmin = -5, xmax = 35, ymin = 48, ymax = 70)

ggplot2::ggplot() + 
  ## baltic countries borders
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      st_crop(xmin = 5, xmax = 32, ymin = 52, ymax = 67),
    fill = "ivory2", 
    size = 0.1
  ) +
  ## ICES areas
  geom_sf(
    data = ices_transform, 
    aes(fill = ICES_area), 
    color = NA
  ) +
  scale_fill_manual(values = colorRampPalette(RColorBrewer::brewer.pal(9, "Pastel1"))(14)) +
  labs(fill = "ICES Subdivisions", x = NULL, y = NULL) +
  ## BHI regions with ID numbers
  geom_sf(data = bhi_rgns_simple, fill = NA, color = "grey70") +
  geom_sf_text(data = bhi_rgns_simple, aes(label = BHI_ID))
```


```{r converting ICES fisheries regions to Baltic regions}
## based on 'prep/FIS/raw/DataOrganization.R' by Melanie Frazier March 16 2016, in bhi-1.0-archive
## table for matching ICES to BHI regions
regions <- read_csv(
  file.path(here::here(), "supplement", "lookup_tabs", "ices_to_bhi_lookup.csv"), 
  col_types = cols()) %>% 
  mutate(ices_numeric = ifelse(ices_numeric == 3, 21, ices_numeric)) # 3a.21 overlaps BHI rgn 1 & 2

## areas of BHI regions in km2
bhi_ices_areas <- regions %>% dplyr::select(region_id, area_km2)


## convert ICES stock assessments to BHI regions
combined_w_rgns <- combined_rawdata %>% 
  
  ## expand ices subdivisions categories to one row per subdiv
  rowwise() %>% 
  mutate(
    ## check unique(combined_rawdata$SDs) to make sure this string parsing will work
    sd_from = as.numeric(str_split(SDs, "-|,")[[1]][1]),
    sd_to = as.numeric(str_split(SDs, "-|,")[[1]][2]),
    sd_extra = as.numeric(str_split(SDs, "-|,")[[1]][3])
  ) %>% 
  mutate(
    sd_to = ifelse(is.na(sd_to), sd_from, sd_to),
    sd_extra = ifelse(is.na(sd_extra), sd_from, sd_extra),
    incl28.2 = sd_from <= 28 & sd_to >= 28,
    incl28.1 = sd_from <= 28 & sd_to >= 28 & species != "herring"
  ) %>% 
  ## ICES regions 28.1 for Riga and 28.2 elsewhere but no 28
  mutate(SDs = list(
    unique(
      c(sd_from:sd_to, sd_extra)[c(sd_from:sd_to, sd_extra)!=28] %>% 
        c(ifelse(incl28.2, 28.2, sd_from)) %>% 
        c(ifelse(incl28.1, 28.1, sd_from))
    )
  )) %>% 
  tidyr::unnest(ices_subdiv = SDs) %>% 
  dplyr::select(-sd_from, -sd_to, -sd_extra, -incl28.1, -incl28.2) %>% 
  filter(ices_subdiv != 20) %>% # filter because no BHI region assigned to SD 20 and will cause NA means...
  
  ## add BHI regions info using ices_to_bhi_lookup
  left_join(dplyr::select(regions, region_id, ices_numeric), by = c("ices_subdiv" = "ices_numeric")) %>%
  
  ## without better information, assuming landings are uniform across stock assessment area, 
  ## then landings within BHI rgn are proportional to rgn area fraction of total stock area
  left_join(bhi_ices_areas, by = "region_id") %>% # area information
  group_by(stockname, year) %>% 
  mutate(
    assessArea = sum(area_km2), # stocks assessment areas
    landings_rate = landings/assessArea # per unit area
  ) %>%  
  group_by(region_id) %>% 
  mutate(rgn_landings = landings_rate*area_km2) %>% 
  ungroup() %>% 
  
  ## save intermediate dataset
  rename(stock = stockname, area_rgn_km2 = area_km2) %>% 
  filter(year < assess_year) # current yr fish. mort. data won't be complete

## ICES subdivs 20 and 21 are North Sea and left out of BHI1.0, but herring in 3a.21 for rgn 1 & 2
# combined_w_rgns <- combined_w_rgns %>% filter(!ices_subdiv %in% c(20, 21))

## full merged dataset with MSY and raw data, as well as calculated ratios
## this will be used for the shiny app among other things!
write_csv(combined_w_rgns, file.path(loc, version_year, "intermediate", "fis_full_merged_dataset.csv"))
```

<br>

#### 3.1.4 Wrangle and save layers for FIS and NP Goals

The F/FMSY, B/BMSY, and landings data are the ICES stock assessment area values, expanded to have all years rows per BHI region within the stock assessment area, and row-bound to include all stocks in one table.

```{r fis_ffmsy_bbmsy and fis_landings plots, out.width = "850px"}

## full dataset in long format with calculated ratios, for plotting
plot_format_msy_metrics <- combined_w_rgns %>% 
  dplyr::select(region_id, stock, species, year, bbmsy, ffmsy) %>% 
  tidyr::gather(key = metric, value = value, -year, -stock, -species, -region_id) %>% 
  filter(year >= 1970)

msy_metrics_plot <- ggplot(data = plot_format_msy_metrics)  +
  geom_abline(slope = 0, intercept = 1, color = "grey40") +
  geom_line(aes(x = year, y = value, color = stock), size = 0.5) +
  scale_color_brewer(palette = "Paired") +
  ylab("value \n")+
  facet_grid(vars(species), vars(metric)) + 
  theme(legend.position = "none")

## landings data formatted for plotting
plot_format_landings <- combined_w_rgns %>% 
  dplyr::select(region_id, stock, species,  year, landings, rgn_landings) %>% 
  tidyr::gather(key = "metric", value = "value", -year, -stock, -species, -region_id) %>% 
  filter(year >= 1970)

landings_plot <- ggplot(filter(plot_format_landings, metric == "landings")) +
  geom_line(aes(x = year, y = value, color = stock), size = 0.5) +
  scale_color_brewer(palette = "Paired") +
  ylab(NULL) +
  facet_grid(vars(species), vars(metric)) 
# landings_plot <- ggplot(filter(plot_format_landings, metric == "rgn_landings")) +
#   geom_point(aes(x = year, y = value, color = stock), size = 2, alpha = 0.1) +
#   geom_line(
#     data = summarize(filter(landings_all, metric == "rgn_landings"), mn = mean(value)),
#     aes(x = year, y = mn, color = stock)) +
#   scale_color_brewer(palette = "Paired") +
#   ylab(NULL) +
#   facet_grid(vars(stock))


## TIMESERIES PLOT
## F/FMSY, B/BMSY, and Landings (msy_metrics_plot and landings_plot)
gridExtra::grid.arrange(msy_metrics_plot, landings_plot, nrow = 1, widths = c(1.1, 1))
```

```{r create and save FIS and NP layers}
## same preparation of data for fis and np, just different stocks used:
## cod and herring are used in the FIS goal
## sprat are used for the NP goal
long_format <- combined_w_rgns %>% 
  dplyr::select(region_id, stock, species, year, landings, rgn_landings, bbmsy, ffmsy) %>% 
  tidyr::gather(key = "metric", value = "value", -year, -stock, -species, -region_id) %>% 
  filter(year >= 1970)

goal_stocks <- c("FIS", "NP")
for(g in goal_stocks){
  if(g == "FIS"){
    fis_data <- long_format %>% filter(!str_detect(stock, "spr"))
    msy_dat <- fis_data %>% filter(metric %in% c("ffmsy", "bbmsy"))
    landings <- fis_data %>% filter(metric %in% c("landings", "rgn_landings"))
    
  } else {
    np_data <- long_format %>% filter(str_detect(stock, "spr"))
    msy_dat <- np_data %>% filter(metric %in% c("ffmsy", "bbmsy"))
    landings <- np_data %>% filter(metric %in% c("landings", "rgn_landings"))
  }
  ## filter to save by metric: bbmsy, ffmsy, landings
  msy_dat %>% 
    filter(metric == "bbmsy") %>% 
    dplyr::select(-metric, -species) %>% 
    write_csv(
      file.path(dir_layer, sprintf(
        "%s_bbmsy_bhi%s.csv", 
        str_to_lower(g), 
        assess_year
      ))
    )
  msy_dat %>% 
    filter(metric == "ffmsy") %>% 
    dplyr::select(-metric, -species) %>% 
    write_csv(
      file.path(dir_layer, sprintf(
        "%s_ffmsy_bhi%s.csv", 
        str_to_lower(g), 
        assess_year
      ))
    )
  landings <- landings %>%
    filter(metric == "rgn_landings") %>% 
    # filter(metric == "landings") %>%
    rename(landings = value) %>% 
    dplyr::select(-metric, -species) %>% 
    write_csv(
      file.path(dir_layer, sprintf(
        "%s_landings_bhi%s.csv", 
        str_to_lower(g), 
        assess_year 
      ))
    )
}
```


### 3.2 Evaluate data & sampling patterns

#### 3.2.1 Comparing with previous BHI Assessment

The code below loads FIS layers from current and prior BHI assessments so the raw metrics can be compared before scores are calculated-- an early check which can help catch data quality issues, and helpful to suss out how changes in original data might be reflected in final goal scores.

This involves matching current and prior ICES stock assessment areas, joining the datasets, and plotting values of one BHI version against the other, per metric and stock. These plots can be used to e.g. identify outliers. Values for which the ICES areas changed are highlighted so as to effects of this can be visually inspected.


```{r compare to data used in last assessment}

## load layers
fis_bbmsy <- read_csv(file.path(dir_layer, sprintf("fis_bbmsy_bhi%s.csv", assess_year))) %>% 
  rename(bbmsy = value)
fis_ffmsy <- read_csv(file.path(dir_layer, sprintf("fis_ffmsy_bhi%s.csv", assess_year))) %>% 
  rename(ffmsy = value)
fis_landings <- read_csv(file.path(dir_layer, sprintf("fis_landings_bhi%s.csv", assess_year)))

## previous assessment layers
prev_fis_bbmsy <- read_csv(
  file.path(dirname(dir_assess), "bhi-1.0-archive", "baltic2015", "layers",
            sprintf("fis_bbmsy_bhi%s.csv", 2015))) %>% 
  rename(prev_bbmsy = score, region_id = rgn_id)

prev_fis_ffmsy <- read_csv(
  file.path(dirname(dir_assess), "bhi-1.0-archive", "baltic2015", "layers",
            sprintf("fis_ffmsy_bhi%s.csv", 2015))) %>% 
  rename(prev_ffmsy = score, region_id = rgn_id)

prev_fis_landings <- read_csv(
  file.path(dirname(dir_assess), "bhi-1.0-archive", "baltic2015", "layers",
            sprintf("fis_landings_bhi%s.csv", 2015))) %>% 
  rename(prev_landings = landings, region_id = rgn_id)


## join and plot to identify differences
## ICES assessment areas for each stock change sometimes between ICES and BHI Assessments...
matchtab <- data.frame(
  from = c("cod_SDs22_24", "cod_SDs24_32", "herring_SD_28.1", "herring_SDs20_24", "herring_SDs25_29_32", "herring_SDs30_31"),
  to = c("cod_2224", "cod_2532", "her_riga", "her_3a22", "her_2532", "her_30")
)
matchtab$from <- as.character(matchtab$from)
matchtab$to <- as.character(matchtab$to)

## mapping between/matching previous CES stock assess. areas and most recent
stockareas_match <- function(tab, jointab, matchtab){
  for(i in 1:nrow(matchtab)){
    tab <- tab %>% 
      mutate(stock = str_replace(stock, pattern = matchtab[i, "from"], replacement = matchtab[i, "to"]))
  }
  revisedtab <- tab %>% 
    left_join(jointab, by = c("stock", "year", "region_id")) %>% 
    ## create logical column highlighting where stock assessment area changes occured
    mutate(changed_assess_area = ifelse(stock %in% c("cod_2532", "her_3a22", "her_30"), TRUE, FALSE)) %>% 
    dplyr::select(-region_id) %>% 
    distinct()
  return(revisedtab)
}
compare_bbmsy <- stockareas_match(fis_bbmsy, prev_fis_bbmsy, matchtab)
compare_ffmsy <- stockareas_match(fis_ffmsy, prev_fis_ffmsy, matchtab)


## plot to investigate effects of these changes...
compare_bbmsy_plot <- ggplot(compare_bbmsy) +
  geom_abline(slope = 1, intercept = 0, color = "grey85", alpha = 0.5)  + 
  geom_point(
    aes(x = prev_bbmsy, y = bbmsy, color = changed_assess_area, shape = stock), 
    size = 2, alpha = 0.6
  ) + 
  labs(
    shape = "ICES Stocks, \n previous ICES categories", 
    color = "ICES Stock Areas Changed \n between current and previous assessments",
    x = "B/BMSY from Previous Assessment", 
    y = "B/BMSY from Current Assessment"
  )
compare_ffmsy_plot <- ggplot(compare_ffmsy) +
  geom_abline(slope = 1, intercept = 0, color = "grey85", alpha = 0.5)  + 
  geom_point(
    aes(x = prev_ffmsy, y = ffmsy, color = changed_assess_area, shape = stock), 
    size = 2, alpha = 0.6
  ) + 
  labs(
    x = "F/FMSY from Previous Assessment", 
    y = "F/FMSY from Current Assessment"
  ) + 
  theme(legend.position = "none")

gridExtra::grid.arrange(compare_ffmsy_plot, compare_bbmsy_plot, nrow = 1, widths = c(0.4, 1))
```

#### 3.2.2 Proportions of total catch over time

Of all the fisheries landings that occurred in a given area and year, what proportion is made up by each stock?  
How have these proportions changed over time?

Note: different stocks are assessed in different groupings of ICES areas/subdivisions and do not neatly overlap. Without more information (regardless of how catches may in reality be spatially distributed across the assessment areas and BHI regions), the partitioning of catches by BHI regions assumed uniform catch rate over the area, and thus regional:total catch fraction was assumed to be the same as rgn area:total stock area fraction. 

```{r catch proportions plots}
## proportions of stocks by BHI region and year
yearly_rgn_props <- combined_w_rgns %>% 
  dplyr::select(region_id, stock, year, landings, rgn_landings, landings_rate, area_rgn_km2) %>% # ices_subdiv, area_rgn_km2, assessArea
  filter(!str_detect(stock, "spr")) %>%
  group_by(region_id, year) %>% 
  mutate(
    rgn_yr_totCatch = sum(rgn_landings),
    landings_rateCumulative = sum(landings_rate) # same as rgn_yr_totCatch/area_rgn_km2
  ) %>% 
  ungroup() %>%
  ## proportion a given stock makes up of total catch in region, by year
  mutate(rgn_yr_propCatch = rgn_landings/rgn_yr_totCatch)

# ggplot(
#   yearly_rgn_props %>% 
#     filter(year >= 2008) %>% 
#     filter(region_id %in% c(1, 3, 11, 14, 27, 37)) # rep. 6 distinct zones created by assessment overlap
#   ) + 
#   geom_area(aes(x = year, y = rgn_yr_propCatch, fill = stock),  position = "stack", alpha =  0.5) +
#   scale_fill_brewer(palette = "Set3") +
#   facet_wrap(~region_id, nrow = 2) +
#   ylab("proportion of stock catch to total catch per BHI region \n") + xlab(NULL)
ggplot(filter(yearly_rgn_props, year >= 1990)) +
  geom_area(aes(x = year, y = rgn_yr_totCatch, fill = stock),  position = "stack", alpha =  0.5) +
  scale_fill_brewer(palette = "Set3") +
  facet_wrap(~region_id, nrow = 3) +
  ylab("cumulative catches, by region and stock \n") + xlab(NULL)
```

<br>

#### 3.2.3 Regions map for stock proportions of total catch

These proportions are the weights used for combining statuses of multiple stock into one status value for the region.


```{r map values by bhi and ICES regions, results = "show"}
## wrangle mapping data
map_raw_data <- yearly_rgn_props %>% 
  filter(year == max(yearly_rgn_props$year)) %>%
  dplyr::select(-year, -landings_rate, -rgn_landings) %>% 
  spread(key = "stock", value = "rgn_yr_propCatch")

## combine with spatial info for mapping
bhi_rgns_shp <- bhi_rgns_simple %>% 
  mutate(Name = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  left_join(map_raw_data, by = c("BHI_ID" = "region_id"))

## create color palettes
pal <- colorNumeric(
  palette = c(
    colorRampPalette(colors = c("#fffed8", "#c8e9b4"))(10),  
    colorRampPalette(colors = c("#c8e9b4", "#40b6c4"))(50),
    colorRampPalette(colors = c("#40b6c4", "#225ea8"))(15)
  ),
  na.color = "#fcfcfd",
  domain = seq(0.02, 0.98, 0.001)
)
pal_catch_rate <- colorNumeric(
    palette = colorRampPalette(colors = c("grey80", "grey40"))(40),
    na.color = "#fcfcfd",
    domain = c(0.5, 2)
)

## make map
props_catch_map <- leaflet::leaflet(data = bhi_rgns_shp) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  setView(18, 59, zoom = 5)

## add layers for all fisheries
groups <- c(
  "Cod SDs 22-24", "Cod SDs 24-32", 
  "Herring SDs 28.1 (Riga)", "Herring SDs 20-24", 
  "Herring SDs 25-29, 32","Herring SDs 30-31"
)
for(i in 1:6){
  vars <- sym(c(
    "cod_SDs22_24", "cod_SDs24_32", 
    "herring_SD_28.1", "herring_SDs20_24", 
    "herring_SDs25_29_32", "herring_SDs30_31"
  )[i])
  props_catch_map <- props_catch_map %>% 
    addPolygons(
      stroke = TRUE, opacity = 0.3, weight = 1, fillOpacity = 0.8,
      fillColor = ~pal(bhi_rgns_shp[[vars]]), group = groups[i]
    ) %>% 
    addPolygons(
    popup = paste(
      "<h5><strong>", "Proportion of Total Catch:", "</strong>",
      round(bhi_rgns_shp[[vars]], 3), "</h5>", sep = " "
    ),
    fillOpacity = 0,
    stroke = FALSE,
    group =  groups[i]
  )
}
## add total catches layer and more formatting
props_catch_map %>%
  ## Catch Rate
  addPolygons(
    stroke = TRUE, opacity = 0.3, weight = 1, fillOpacity = 0.9,
    fillColor = ~pal_catch_rate(bhi_rgns_shp$landings_rateCumulative), group = "Region Estim. (tonnes/km2) Catch Rate"
  ) %>% 
  addPolygons(
    popup = paste(
      "<h5><strong>", bhi_rgns_shp$Name, "</strong>", "</h5>",
      "<h5><strong>", "ICES subdivision ", bhi_rgns_shp$ices_subdiv, "</h5>",
      "<h5><strong>", "Region Estim. (tonnes/km2) Catch Rate: ", "</strong>",
      format(round(bhi_rgns_shp$landings_rateCumulative, 3), big.mark = ","), "</h5>", sep = " "
    ),
    fillOpacity = 0,
    stroke = FALSE,
    group = "Region Estim. (tonnes/km2) Catch Rate"
  ) %>%
  
  ## layer controls and legend
  addLayersControl(
    baseGroups = c(
      "Cod SDs 22-24", "Cod SDs 24-32",
      "Herring SDs 28.1 (Riga)", "Herring SDs 20-24", "Herring SDs 25-29, 32", "Herring SDs 30-31",
      "Region Estim. (tonnes/km2) Catch Rate"
    ),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% 
  addLegend("bottomright", pal, seq(0.02, 0.98, 0.001))


# ggplot2::ggplot(bhi_rgns_shp) +
#   geom_sf() +
#   ## https://www.r-bloggers.com/scatterpie-for-plotting-pies-on-ggplot/, install.packages("scatterpie")
#   scatterpie::geom_scatterpie()
```

<br>

### 3.3 Status and trend

Calculating status and trend consists of the following steps:
- derive Eastern Baltic cod penalty factor
- calculate F-scores and B-scores
- take mean of F and B scores, with data grouped by region_id, stock, year
- derive weights from landings data (proportions of catch made up of different stocks in each region)
- apply penalty for cod condition in the Eastern Baltic
- calculate status as a geometric mean weighted by proportion of catch in each region

The formulas for calculating F and B scores are based on [this paper](https://doi.org/10.1371/journal.pone.0098995).


#### 3.3.1 Eastern Baltic cod condition penalty factor

Biomass and mortality are not sufficient to characterize the status of the Eastern Baltic cod, as it is condition not just populations which have significantly declined. Fulton's K is used as a measure of condition. The following method based on [Casini et al. 2016](https://doi.org/10.1098/rsos.160416) :

- Individual body condition (Fulton's K) estimated as K = W/(L^3) × 100 
- W = the total weight (g) of the fish
- L = total length (cm) of the fish
- condition averaged per length-class for each region, year
- lengths < 10 cm and ≥60 cm excluded-- not enough data
- focused on quarter 4 as it corresponds to the main feeding season


The original metric considered for this penalty factor was proportion of surveyed cod in length category 40-60cm (the most commercially important) with Fulton's K less than 0.8. However, due to small sample sizes per survey area in this length class (n = 1 some cases, increasingly common in more recent years), this metric will not suffice. Including smaller size classes 20-30cm and 30-40cm will help increase sample size, especially for future asssessments as fewer larger fish may be caught in the future.

Within ICES survey areas, country was found to have significant effect on condition. So, rather than grouping by ICES area and matching resulting penalty factors to BHI regions in the same way as with mortality and biomass data, country information was retained and used in matching to BHI regions.


```{r derive eastern baltic cod penalty factor}

surveyBITS_cod <- read_csv(file.path(dir_rawdata, "SMALK_2019-10-22 16_34_01", "SMALK_2019-10-22 16_34_01.csv"))
# unique(surveyBITS_cod$Country) # no data for Finland!?

q4_fultonsK <- surveyBITS_cod %>%
  mutate(length_cm = LngtClass/10) %>% 
  dplyr::select(year = Year, ices_subdiv = Area, eez = Country, length_cm, wgt_gram = IndWgt) %>% 
  mutate(
    ## revise country EEZ codes to be consistent with codes used elsewhere by BHI
    eez = ifelse(eez == "GFR", "DEU", ifelse(eez == "DEN", "DNK", ifelse(eez == "LAT", "LVA", eez))),
    ## calculate fultons K and assign length classes
    fultonsK = wgt_gram/(length_cm^3)*100,
    length_group = floor(length_cm/10)
  ) %>% 
  filter(!is.na(fultonsK), fultonsK < 2) %>% 
  ## per Casini et al exclude lengths < 10cm and ≥60cm-- not enough data:
  filter(length_group %in% 1:5) %>% 
  mutate(
    length_group = ifelse(
      length_group == 1, "10-20cm", ifelse(
         length_group == 2, "20-30cm", ifelse(
           length_group == 3, "30-40cm", "40-60cm"
         )
      )
    )
  ) %>% 
  ## join BHI regions
  ## area 28 includes both 28.2 and gulf of Riga 28.1 
  ## http://www.ices.dk/marine-data/Documents/DATRAS/Survey_Maps_Datras.pdf
  mutate(ices_subdiv = ifelse(ices_subdiv == 28, list(28.1, 28.2), ices_subdiv)) %>% 
  tidyr::unnest(ices_subdiv = ices_subdiv) %>% 
  right_join(
    regions %>% 
      dplyr::select(region_id, eez, ices_subdiv = ices_numeric) %>% 
      filter(ices_subdiv %in% c(unique(surveyBITS_cod$Area), 28.1, 28.2)),
    by = c("ices_subdiv", "eez")
  )

filter(q4_fultonsK, is.na(fultonsK)) # NA check
q4_fultonsK <- filter(q4_fultonsK, !is.na(fultonsK))
## will give BHI region 1 have same penalty as 2, BHI 5 same as 6, and BHI 29 same as 26
## as these regions are small, close, and/or share overlapping ICES areas; see ICES vs BHI regions map above

## are K values significantly different within ICES areas by country/eez?
## i.e. is it ok to calculate these penalties by ICES area and assign to BHI regions in the same way as w/ F and B data?
## consistency is preferable and also,
## taking only lengths 40-60, grouping by region (vs ICES area) and yr leaves few data pts in each group
## e.g in last 10 years, 27% (vs 10%) have 1 or2, 35% (vs 18%) with <6, 45% (vs 38%) <11
n_eez <- dplyr::select(q4_fultonsK, ices_subdiv, eez) %>% distinct() %>% count(ices_subdiv)

for(i in filter(n_eez, n > 1)$ices_subdiv){
  tmp <- filter(q4_fultonsK, ices_subdiv == i, length_group != "10-20cm")
  # print(count(tmp, year, eez) %>% spread(eez, n) %>% filter(year > 2008))
  print(summary.aov(aov(fultonsK ~ year + eez, data = tmp)))
  
  ggplot(q4_fultonsK %>% filter(ices_subdiv == i, length_group != "10-20cm", year > 2008)) + 
    geom_histogram(aes(fultonsK)) + 
    facet_grid(rows = vars(eez), scales =  "free_y")
}
## conclusion: eez has signif. effect on K except for rgn 28.1 and 28.2, so should group by BHI not ICES areas...


## further evaluating effect of grouping by BHI region vs ICES subdivisions,
## test with both region_id and ices_subdiv...
spatial_group <- "region_id" # "ices_subdiv"
spID <- sym(spatial_group)

## averages per region, year, and length group
## aggregate length classes 20-40 and 40-60cm
q4_fultonsK_avgs <- q4_fultonsK %>% 
  group_by(!!spID, year, length_group) %>% 
  summarize(avg_cond = mean(fultonsK)) %>% 
  mutate(length_group = as.character(length_group))
## !! notation https://shipt.tech/https-shipt-tech-advanced-programming-and-non-standard-evaluation-with-dplyr-e043f89deb3d

## trends per length class in each region
q4K_wTrends <- q4_fultonsK_avgs %>% 
  group_by(!!spID, length_group) %>%
  do(
    yr_coeff = lm(avg_cond ~ year, data = .)$coefficients["year"] %>% unlist(),
    yr_int = lm(avg_cond ~ year, data = .)$coefficients["(Intercept)"] %>% unlist()
  ) %>% 
  unnest(yr_coeff, yr_int) %>% 
  right_join(q4_fultonsK_avgs, by = c(spatial_group, "length_group")) %>% 
  group_by(year) %>% 
  mutate(mean_yr_condition = mean(avg_cond)) %>% 
  ungroup()
q4K_wTrends$length_group <- as.factor(q4K_wTrends$length_group)

## plot of trends by region and length group
ggplot(data = q4K_wTrends) +
  geom_abline(aes(slope = yr_coeff, intercept = yr_int, color = length_group), size = 0.2) +
  geom_point(aes(x = year, y = avg_cond, color = length_group, shape = length_group), size = 1.2, alpha = 0.8) +
  # geom_line(aes(x = year, y = avg_cond, color = length_group), size = 0.3) +
  scale_color_manual(values = RColorBrewer::brewer.pal(9, "Spectral")[c(4,5,7,9)]) +
  geom_abline(slope = 0, intercept = 1, alpha = 0.5) +
  geom_abline(slope = 0, intercept = 0.8, alpha = 0.5) +
  facet_wrap(vars(!!spID), nrow = 3) +
  theme_grey() +
  labs(
    title = sprintf(
      "Condition trends of Eastern Baltic Cod by %s Region", 
      ifelse(spatial_group == "region_id", "BHI", "ICES")
    ), 
    x = NULL, y = "Condition (Fulton's K)\n", 
    color = "Length Group", shape = "Length Group"
  )

## all together with yearly average K
ggplot(q4K_wTrends, aes(x = year, y = avg_cond)) +
  geom_point(size = 2, alpha = 0.5, aes(color = length_group, shape = length_group)) +
  geom_line(aes(x = year, y = mean_yr_condition), size = 0.5) +
  scale_color_manual(values = RColorBrewer::brewer.pal(9, "Spectral")[c(4,5,7,9)]) +
  labs(
    title = sprintf(
      "Average Condition of Eastern Baltic Cod by %s Region", 
      ifelse(spatial_group == "region_id", "BHI", "ICES")
    ),
    x = NULL, y = "Condition (Fulton's K)\n", 
    color = "Length Group", shape = "Length Group"
  )

## penalty factor as proportion of fish in class 40-60cm with K > 0.8
cod_penalty <- q4_fultonsK %>% 
  filter(length_group != "10-20cm") %>%
  dplyr::select(!!spID, year, fultonsK) %>% 
  group_by(!!spID, year) %>% 
  summarize(prop_above_pt8 = sum(fultonsK > 0.8)/n(), num_samp = n()) %>% 
  ungroup() %>% 
  mutate(stock = "cod_SDs24_32")

ggplot(cod_penalty) + 
  geom_line(aes(x = year, y = prop_above_pt8)) + 
  facet_wrap(vars(!!spID),  nrow = 3) +
  labs(
    title = sprintf(
      "Proportion of Eastern Baltic Cod with K > 0.8 by %s Region",
      ifelse(spatial_group == "region_id", "BHI", "ICES")
    ),
    x = "Year", y = "Proportion in Length Classes 20-60cm with K > 0.8\n"
  )
```


#### 3.3.2 Calculating Status and Trend

Status and trend are calculated by `functions.R` when the full BHI index is calculated. The calculations are included here also, so that parameters and results can be explored.

```{r calculate score components F and B}
## bind data layers
metric_scores <- left_join(fis_bbmsy, fis_ffmsy,  by = c("region_id", "stock", "year"))

## B-SCORES
## calculate B-scores

## note: these parameters can be changed!
## view Bscores plot to evaluate/test different parameter values...
lowerB <- 0.8
upperB1 <- 1.2
upperB2 <- 3

B_scores <- metric_scores %>%
  mutate(
    score_type = "B_score",
    
    score = ifelse(
      bbmsy < lowerB, (1/lowerB)*bbmsy,
      ifelse(
        lowerB <= bbmsy & bbmsy < upperB1, 1, 
        ifelse(
          bbmsy >= upperB1, 
          (bbmsy - upperB2)/(upperB1-upperB2), NA
        )
      )
    )
  ) %>% 
  mutate(
    score = ifelse(
      score <= 0.1, 0.1, 
      ifelse(score > 1, 1, score)
    )
  )
ggplot(data = B_scores, aes(bbmsy, score, color = bbmsy)) + geom_line() + 
  labs(title = "B-scores vs. B/BMSY values") + ylab(NULL) + xlab(NULL) +
  theme(legend.position = "none")


## F-SCORES
## calculate F-scores

## note: these parameters can be adjusted, as can the B-score parameters above 
## view Bscores and Fscores plots to evaluate/test different parameter values...
## low lowerF ~ tolerance for low catch: doesn't differentiate whether to allow recovery, or despite high effort...
lowerF <- 0.8
upperF1 <- 1.1
upperF2 <- 2

## make this a function so it's easier to explore parameters...
calcFscores <- function(input_data, lowB = 0.8, lowF = 0.8, uppF1 = 1.2, uppF2 = 2.5){
  
  # install.packages("pracma")
  norm1 = pracma::cross(
    c(lowB, uppF1, 1) - c(0, 1, 0),
    c(lowB, uppF2, 0) - c(0, 1, 0)
  )
  norm2 = pracma::cross(
    c(lowB, 0, (uppF2-lowF-1)/(uppF2-1)) - c(lowB, lowF, 1),
    c(0, 1-(uppF2-lowF), 1) - c(lowB, lowF, 1)
  )
  
  ## PIECEWISE FORMULA...
  ## note input_data must have bbmsy and ffmsy columns
  m = (uppF2-1)/lowB
  result <- input_data %>%
    mutate(
      score_type = "F_score",
      
      score = ifelse(
        ## when bbmsy < lowB :
        bbmsy < lowB,
        
        ## will be space near zero where scores start going back down from 1:
        ## on y-axis towards zero if uppF2-lowF < 1, on x-axis towards zero if uppF2-uppF1 > 1
        ifelse(
          ffmsy > m*bbmsy + 1, 0,
          ifelse(
            m*bbmsy + 1 >= ffmsy & ffmsy > m*bbmsy + (1-(uppF2-uppF1)),
            ## http://mathworld.wolfram.com/Plane.html n1x + n2y + n3z - (n1x0 + n2y0 + n3z0) = 0
            (norm1[2] - norm1[1]*bbmsy - norm1[2]*ffmsy)/norm1[3],
            ifelse(
               m*bbmsy + (1-(uppF2-uppF1)) >= ffmsy & ffmsy > m*bbmsy + (1-(uppF2-lowF)), 1,
               ((norm2[1]*lowB + norm2[2]*lowF + norm2[3]) - (norm2[1]*bbmsy + norm2[2]*ffmsy))/norm2[3]
            )
          )
        ),
        ## when bbmsy >= lowB :
        ifelse(
           ffmsy > uppF1,
           (uppF2-ffmsy)/(uppF2-uppF1),
           ifelse(
             uppF1 >= ffmsy & ffmsy > lowF, 
             1,
             ffmsy/(uppF2-1) + (uppF2-lowF-1)/(uppF2-1)
           )
        )
      )
    ) %>% 
    ## set scores less than 0.1 to 0.1, greater than 1 to 1
    mutate(
      score = ifelse(
        score <= 0.1, 0.1,
        ifelse(score > 1, 1, score)
      )
    )
  return(result)
}

## create heatplot showing now ffmsy and bbmsy map to scores
ffmsy_bbmsy_score <- calcFscores(
  input_data = expand.grid(
    ffmsy = seq(0, 6, length.out = 100), 
    bbmsy = seq(0, 5, length.out = 100)
  ),
  lowB = lowerB, lowF = lowerF, uppF1 = upperF1, uppF2 = upperF2
)

## calculate F-scores
F_scores <- calcFscores(metric_scores, lowB = lowerB, lowF = lowerF, uppF1 = upperF1, uppF2 = upperF2)

ggplot(data = ffmsy_bbmsy_score) +
  geom_tile(aes(bbmsy, ffmsy, fill = score), alpha = 0.8) +
  # geom_point(aes(bbmsy, ffmsy), F_scores, , shape = 22, alpha = 0.1) + 
  xlab("B/BMSY") + ylab("F/FMSY") + labs(fill = "F-Score\n")
```


```{r calculate scores and trend from weights and score components}

## average B-scores and F-scores to get overall score
## these averages will be weighted by stock landings and have cod condition penalty applied
scores <- rbind(B_scores, F_scores) %>%
  group_by(region_id, stock, year) %>%
  summarize(score = mean(score, na.rm = TRUE)) %>% # hist(scores$score)
  left_join(
    spread(rbind(B_scores, F_scores), key = "score_type", value = "score"),
    by = c("year", "stock", "region_id")
  )

## WEIGHTS
## calculate weights with landing data
## we use the average catch for each stock/region across all years to obtain weights

weights <- landings_all %>%
  filter(metric == "rgn_landings") %>% # ALTERNATE METHOD TO GET WEIGHTS FROM LANDINGS
  # filter(metric == "all_landings") %>% # BHI1.0 METHOD FOR LANDINGS -> WEIGHTS
  filter(year > max(year) - 10) %>% 
  dplyr::select(-ices_subdiv, landings = value, -metric) %>% 
  group_by(region_id, stock) %>% # each region/stock will have same avg catch across years
  mutate(avgCatch = mean(landings)) %>% # timeseries mean, considering last 10 years
  group_by(region_id, year) %>%
  mutate(totCatch = sum(avgCatch)) %>% # total (ie all stock) catch on average (across years)
  ungroup() %>%
  mutate(propCatch = avgCatch/totCatch) # proportion of catch each stock accounts for
## total proportion of landings for each region/year will sum to one
# chk <- weights_orig %>%
#   group_by(region_id, year) %>%
#   summarise(sumProps = sum(propCatch))
# unique(chk$sumProps)


## STATUS
## geometric mean weighted by proportion of catch in each region
status_with_penalty <- weights %>% 
  left_join(scores, by = c("region_id", "year", "stock")) %>%
  filter(!is.na(score)) %>% # remove missing data
  dplyr::select(region_id, year, stock, propCatch, score) %>% 
  
  ## apply penalty because bad cod condition in eastern baltic
  left_join(cod_penalty, by = c("year", "region_id", "stock")) %>% 
  mutate()
  
  
  
  mutate(
    score = ifelse(
      str_detect(stock, "cod") & str_detect(stock, "32"),
      score*filter(cod_penalty, year == assess_year-1)$penalty_factor, score
    )
  )
status <- status_with_penalty %>% 
  group_by(region_id, year) %>%
  summarize(status_prop = prod(score^propCatch), status_avg = mean(score)) %>%
  ungroup()
```


```{r evaluate goal model and data}
## visualize scores/status results
ggplot(scores, aes(x = year)) + 
  geom_ribbon(aes(ymin = F_score, ymax = B_score, fill = stock), alpha = 0.4) + 
  geom_line(aes(y = score, color = stock)) +
  facet_wrap(vars(region_id)) + 
  labs(color = "Stock", fill = "Stock")
```



### 3.4 Gapfilling

The F/FMSY and B/BMSY data processing for FIS and NP goals do not include any gapfilling or interpolation. However, the matching ICES subdivisions to BHI regions is not exact, and...

The calculation of the Eastern Baltic Cod penalty factor does involve some gapfilling. Specifically, no data was reported in for cod in the [Baltic International Trawl survey (BITS)](https://datras.ices.dk/Data_products/Download/Download_Data_public.aspx) for ICES areas 30, 31, 32 or in ICES area 29 except for Estonia. 


### 3.5 Methods discussion

<br>

#### 3.5.1 Adjustment of Cod scores Based on Body Weight and Length

Source: [Casini M et al. 2016](http://dx.doi.org/10.1098/rsos.160416)


#### 3.5.2 Matching ICES stock assessment areas to  BHI Regions

![Splitting catch by BHI Region](fis-stocks-rgn-props.png)


#### 3.5.3 Setting F-Score and B-score parameters


## 4. Visualizing Data Layers

Below are some maps visualizing a few of the intermediate datasets.  
Spatially, data inputs are the same value per year per stock, across the BHI regions in which the stock exists.  
BHI status and trend scores differ spatially across regions as they are combinations of multiple stocks status weighted by landings proportions.

### 4.1 Goal Status Map

```{r goal status map, results = "show"}
## combine with spatial info for mapping
bhi_rgns_shp <- bhi_rgns_shp %>% 
  dplyr::select(rgn_nam, rgn_key, Subbasin, HELCOM_ID, BHI_ID, Area_km2, Name) %>% 
  left_join(filter(status, year == max(scores$year)), by = c("BHI_ID" = "region_id"))
pal <- colorNumeric(
  palette = "RdYlBu", na.color = "#fcfcfd",
  domain = seq(0.4, 1, 0.005))

leaflet::leaflet(data = bhi_rgns_shp) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  setView(18, 59, zoom = 5) %>% 
  addPolygons(
    stroke = TRUE, opacity = 0.3, weight = 1, fillOpacity = 0.7,
    fillColor = ~pal(status_prop)
  ) %>% 
  addPolygons(
    popup = paste(
      "<h5><strong>", "Region:", "</strong>",
      bhi_rgns_shp$Name, "</h5>",
      "<h5><strong>", "Status:", "</strong>",
      round(bhi_rgns_shp$status_prop, 2), "</h5>", sep = " "
    ),
    fillOpacity = 0,
    stroke = FALSE
  ) %>% 
  addPolygons(
    stroke = TRUE, opacity = 0.3, weight = 1, fillOpacity = 0.7,
    fillColor = ~pal(status_avg)
  ) %>% 
  addPolygons(
    popup = paste(
      "<h5><strong>", "Region:", "</strong>",
      bhi_rgns_shp$Name, "</h5>",
      "<h5><strong>", "Status:", "</strong>",
      round(bhi_rgns_shp$status_avg, 2), "</h5>", sep = " "
    ),
    fillOpacity = 0,
    stroke = FALSE
  ) %>% 
  ## layer controls and legend
  addLayersControl(
    baseGroups = c("Status weighted avg by catches", "Status weighted equally"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% 
  addLegend("bottomright", pal, seq(0.4, 1, 0.005))
```

<br>

```{r References, child = refs_path, results = "asis", echo = FALSE}
```
