
## 2. Data

```{r preamble data, echo = FALSE, include = FALSE, error = FALSE}
source(here::here("R", "setup.R"))
```


### 2.1 Datasets with Sources
<br/>

#### 2.1.1 PCB Data

**PCB Data in Biota**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_PCBs.csv -->
```{r PCB biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2017"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**PCB Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26983 -->
```{r PCB congeners table, echo = FALSE}
pcb_congeners <- t(data.frame(
  c("CB180", "2,2',3,4,4',5,5'-heptachlorobiphenyl"),
  c("SCB7", "sum of CBs.- Sum of"),
  c("CB28", "2,4,4'-trichlorobiphenyl"),
  c("CB52", "2,2',5,5'-tetrachlorobiphenyl"),
  c("CB101", "2,2',4,5,5'-pentachlorobiphenyl"),
  c("CB118", "2,3',4,4',5-pentachlorobiphenyl"),
  c("CB153", "2,2',4,4',5,5'-hexachlorobiphenyl"),
  c("CB138", "2,2',3,4,4',5'-hexachlorobiphenyl"),
  c("PCB", "polychlorinated biphenyls - Deprecated- Report as single PCBs"),
  c("CB194", "2,2',3,3',4,4',5,5'-octachlorobiphenyl"),
  c("CB105", "2,3,3',4,4'-pentachlorobiphenyl"),
  c("CB110", "2,3,3',4',6-pentachlorobiphenyl"),
  c("CB126", "3,3',4,4',5-pentachlorobiphenyl"),
  c("CB128", "2,2',3,3',4,4'-hexachlorobiphenyl"),
  c("CB149", "2,2',3,4',5',6-hexachlorobiphenyl"),
  c("CB151", "2,2',3,5,5',6-hexachlorobiphenyl"),
  c("CB156", "2,3,3',4,4',5-hexachlorobiphenyl"),
  c("CB157", "2,3,4,3',4',5'-hexachlorobiphenyl"),
  c("CB170", "2,2',3,3',4,4',5-heptachlorobiphenyl"),
  c("CB44", "2,2',3,5'-tetrachlorobiphenyl"),
  c("CB49", "2,2',4,5'-tetrachlorobiphenyl"),
  c("CB99", "2,2',4,4',5-pentachlorobiphenyl"),
  c("CB77", "3,3',4,4'-tetrachlorobiphenyl"),
  c("CB169", "3,3',4,4',5,5'-hexachlorobiphenyl"),
  c("CB31", "2,4',5-trichlorobiphenyl"),
  c("CB81", "3,4,4',5-tetrachlorobiphenyl"),
  c("SCB", "sum of CBs.- Specify in method data"),
  c("CB189", "2,3,3',4,4',5,5'-heptachlorobiphenyl"),
  c("CB114", "2,3,4,4',5-pentachlorobiphenyl"),
  c("CB123", "1,1'-Biphenyl, 2,3',4,4',5'-pentachloro-"),
  c("CB167", "2',3,4,4',5,5'-hexachlorobiphenyl"),
  c("CB187", "2,2',3,4',5,5',6-heptachlorobiphenyl"),
  c("CB66", "2,3',4,4'-tetrachlorobiphenyl"),
  c("CB60", "1,1'-Biphenyl, 2,3,4,4'-tetrachloro-"),
  c("CB141", "2,2',3,4,5,5'-hexachlorobiphenyl"),
  c("CB74", "2,4,4',5-tetrachlorobiphenyl"),
  c("CB206", "2,2',3,3',4,4',5,5',6-nonachlorobiphenyl"),
  c("CB33", "2',3,4-trichlorobiphenyl"),
  c("CB18", "2,2',5-trichlorobiphenyl"),
  c("CB183", "2,2',3,4,4',5',6-heptachlorobiphenyl"),
  c("CB47", "2,2',4,4'-tetrachlorobiphenyl"),
  c("CB209", "2,2',3,3',4,4',5,5',6,6'-decachlorobiphenyl"),
  c("CB51", "2,2',4,6'-Tetrachlorobiphenyl"),
  c("CB122", "1,1'-Biphenyl, 2,3,3',4',5'-pentachloro-"),
  c("CB138+163", "2,2',3,4,4',5'-hexachlorobiphenyl")))

colnames(pcb_congeners) <- c("Data Code", "")
rownames(pcb_congeners) <- NULL
htmlTable::htmlTable(pcb_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br/>

**PCBs in Sediment**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_PCBs/ContaminantsSediment_PCBs.csv -->
```{r PCB sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All8"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.2 PFOS Data

**PFOS in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_PFOS.csv -->

```{r PFOS biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "2005-2017  (2005 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Organofluorines"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```
<br/>

#### 2.1.3 Dioxin Data

**Dioxins in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_Dioxins.csv -->
```{r dioxin biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1998-2017  (1998 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**Dioxin Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26986 -->
```{r dioxin congeners table, echo = FALSE}
dioxin_congeners <- t(data.frame(
  c("CDD1N", "1 2 3 7 8-pentachlorodibenzo-p-dioxin"),  
  c("CDD4X", "1 2 3 4 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD6P", "1 2 3 4 6 7 8-heptachlorodibenzo-p-dioxin"), 
  c("CDD6X", "1 2 3 6 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD9X", "1 2 3 7 8 9-hexachlorodibenzo-p-dioxin"), 
  c("CDDO", "1 2 3 4 6 7 8 9-octachlorodibenzo-p-dioxin"),   
  c("CDF2N", "2 3 4 7 8-pentachlorodibenzofuran"),   
  c("CDF2T", "2 3 7 8-tetrachloro-dibenzofuran"),   
  c("CDF4X", "2 3 4 6 7 8-hexachlorodibenzofuran"),   
  c("CDF6P", "1 2 3 4 6 7 8-heptachlorodibenzofuran"),   
  c("CDF6X", "1 2 3 6 7 8-hexachlorodibenzofuran"),   
  c("CDF9P", "1 2 3 4 7 8 9-heptachlorodibenzofuran"),   
  c("CDF9X", "1 2 3 7 8 9-hexachlorodibenzofuran"),   
  c("CDFDN", "1 2 3 7 8/1 2 3 4 8-pentachloro-dibenzofuran"),   
  c("CDFO", "octachloro-dibenzofuran (group)"),    
  c("TCDD", "2 3 7 8-tetrachlorodibenzo-p-dioxin")))   

colnames(dioxin_congeners) <- c("Data Code", "")
rownames(dioxin_congeners) <- NULL
htmlTable::htmlTable(dioxin_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br>

**Dioxins in Sediment**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_Dioxins/ContaminantsSediment_Dioxins.csv -->
```{r dioxin sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.4 ICES Station Dictionary and Impacts

**ICES Station Dictionary**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_dictionary.csv -->
```{r ices station dictionary, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("", "")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES](SOURCE...) <br/> Downloaded [DATE...] February 2020 by Ellie Campbell")
```
<br/>

**ICES Station Impacts Codes**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_impacts.csv -->
```{r ices station dictionary, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Data theme:", "Environmental"),
  c("Keyword:", "Station"),
  c("Code Types:", "MSTAT")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES vocabulary](https://vocab.ices.dk/?ref=177) <br/> Downloaded 7 February 2020 by Ellie Campbell")
```
<br/>


#### 2.1.5 TEQ values for dioxin-like PCBs and Dioxins in Biota

Dioxin and dioxin-like compounds. Target is set at 0.0065 TEQ ug/kg ww fish, crustaceans or molluscs (source of target: EQS biota human health). Secondary GES boundary: CB-118 24 ug/kg lw fish liver or muscle (source: EAC).  

This threshold was agreed upon as GES indicator at the most recent meeting of the [Working Group on the State of the Environment and Nature Conservation](http://helcom.fi/helcom-at-work/groups/state-and-conservation) April 11-15, 2016. *Recevied the draft report from Elisabeth Nyberg.*  

This is consistent with the [EU human health thresholds for dioxin and dioxin-like compounds - 6.5 pg/g](http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2011:320:0018:0023:EN:PDF)  

TEQ values from the [World Health Organization 2005](http://www.who.int/ipcs/assessment/tef_values.pdf)  

<br/>

#### 2.1.6 PFOS Indicator in Biota

According to [HELCOM PFOS core indicator document, p.3](http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf), the "GES boundary is set to 9.1 μg/kg wet weight (or 9.1 ng/g ww) with the protection goal of human health".

"The GES boundary is an environmental quality standard (EQS), derived at EU level as a substance included on the list of priority substances under the Water Framework Directive (European Commission 2000, 2013). GES, in accordance with the MSFD is defined as 'concentrations of contaminants at levels not giving rise to pollution effects'. 

EQS are derived from ecotoxicological studies to protect freshwater and marine ecosystems from potential adverse effects of chemicals, as well as adverse effects on human health via drinking water and food from aquatic environments. Quality Standards (QS) are derived for different protection goals, i.e.: pelagic and benthic communities, top-predators in these ecosystems, and human health. The most stringent of these QS is the basis for the EQS. The EQS boundary for PFOS is based on the QS set for biota to protect human health (9.1 μg/ kg fish ww), defined for edible parts in fish. For harmonization purposes the EC Guidance Document No. 32 on biota monitoring (the implementation of EQS biota) under the WFD was developed (European Commission 2014). This guidance document recommends that the results from the monitoring should be standardized to represent fish at a trophic level of 4, which is an estimate of the general trophic level in commercial fish in Europe. The recommendation to obtain PFOS data in fish at a trophic level of 4 is to adjust the values from monitoring in accordance with trophic magnification factors and trophic level."[HELCOM PFOS core indicator document, p.8](http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf)  

**HELCOM core indicator report uses liver PFOS concentrations converted to muscle equivalent values** as in [Faxneld et al. 2014b](https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf).  

<br/>

#### 2.1.7 TEQ values for PCBs in Sediment

Only a few environmental quality standards (EQS) are to date defined in the Baltic Sea for marine surface sediments. The Norwegian threshold values are often used when a comparison with ecotoxicological effects is needed. In particular, the [Norwegian Environment Agency](https://www.miljodirektoratet.no/globalassets/publikasjoner/m1132/m1132.pdf) has defined EQS in sediment for 28 EU priority substances.

PCB7 (sum PCB 28, 52, 101, 118, 138, 153, and 180): Target is set at 4.1 TS ug/kg dw. [Environmental quality classification of water bodies](http://www.vannportalen.no/globalassets/nasjonalt/dokumenter/veiledere-direktoratsgruppa/Klassifisering-av-miljotilstand-i-vann-02-2018.pdf)

**Recommended threshold values are given only for total PCB7, and not for each individual congener. This is because toxicity data are available for only a minority of congeners.**

<br/>

#### 2.1.8 TEQ values for Dioxins in Sediment

Dioxin and dioxin-like compounds. Target is set at 0.00086 TEQ ug/kg dw (Total TEQ).
[Norwegian Environment Agency](https://www.miljodirektoratet.no/globalassets/publikasjoner/m1132/m1132.pdf)
TEQ values from the [World Health Organization 2005](http://www.who.int/ipcs/assessment/tef_values.pdf)  

<br/>

---

<br/>

### 2.2 Centralization & Normalization
<!-- note: below incorporates from BHI1.0, along with preliminary contaminants_prep.Rmd sections, the following: -->
<!-- raw_pcb_data_prep.R, raw_dioxin_data_prep.R, and raw_pfos_data_prep.R -->
<!-- station_attribute_prep.R, congener_description.R -->

```{r read raw datasets, message = FALSE, warning = FALSE, echo = TRUE}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "CW", "CON")

lapply(
  list(
    c("ContaminantsBiota_PCBs", "pcb_rawdata_bio"),
    c("ContaminantsSediment_PCBs", "pcb_rawdata_sed"),
    c("ContaminantsBiota_PFOS", "pfos_rawdata_bio"),
    c("ContaminantsBiota_Dioxins", "dioxin_rawdata_bio"),
    c("ContaminantsSediment_Dioxins", "dioxin_rawdata_sed")
  ),
  function(x){
    read_csv(
      file.path(dir_rawdata, x[1], paste(x[1], "csv", sep = ".")),
      ## some columns need types specified so aren't read incorrectly...
      col_types = cols(
        SUBNO = col_character(), 
        DETLI = col_number(), 
        LMQNT = col_number(), 
        BULKID = col_integer(), 
        PURPM = col_character()
      )
    ) %>% assign(x = x[2], envir = .GlobalEnv)
  }
)

## check number of dates and years sample by country, PCBs data from ICES
## Denmark doesn't have herring data...
do.call(rbind, lapply(as.list(unique(pcb_rawdata_bio$Country)), function(x){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == x) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = x
  )
})) %>% DT::datatable()
```

<br>

#### 2.2.1 Rename Fields/Variables

```{r rename fields for data, echo = TRUE}
## ICES column name descriptors:
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20biota.pdf
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20sediment.pdf
rename_vars <- function(dataset){
  
  df_vars_renamed <- dataset %>% 
    
    ## create date, month, year, day columns
    dplyr::mutate(date = as.Date(DATE, "%d/%m/%Y")) %>% 
    
    dplyr::mutate(
      day = lubridate::day(date),
      month = lubridate::month(date), 
      year = lubridate::year(date)) %>% 
    
    ## change column names
    dplyr::rename(
      country = Country, report_institute = RLABO,
      station = STATN, 
      monit_year = MYEAR, date_ices = DATE,
      
      latitude = Latitude, longitude = Longitude,
      
      param_group = PARGROUP, variable = PARAM, 
      value = Value, unit = MUNIT,
      
      species = Species, sex_specimen = SEXCO, num_indiv_subsample = NOINP,
      test_organism = `Test Organism`,
      matrix_analyzed = MATRX, not_used_in_datatype = NODIS,
      
      monit_program = MPROG, monit_purpose = PURPM,
      
      basis_determination = BASIS, qflag = QFLAG,
      vflag = VFLAG, detect_lim = DETLI,
      quant_lim = LMQNT, uncert_val = UNCRT, method_uncert = METCU,
      
      analyt_lab = ALABO, ref_source = REFSK, method_storage = METST,
      method_pretreat = METPT, method_pur_sep = METPS, method_chem_fix = METFP,
      method_chem_extract = METCX, method_analysis = METOA, formula_calc = FORML,
      
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sampler_type = SMTYP, factor_compli_interp = FINFL,
      
      analyt_method_ref = tblAnalysisID, measurement_ref = tblParamID,
      samp_ref = tblSampleID
    ) %>% 
    
    ## improve clarity of 'basis_determination' and 'matrix_analyzed' column content
    mutate(
      basis_determination = ifelse(
        basis_determination == "L", "lipid weight",
        ifelse(
          basis_determination == "W", "wet weight",
          ifelse(
            basis_determination == "D", "dry weight", NA
          )
        )
      ),
      matrix_analyzed = ifelse(
        matrix_analyzed == "LI", "liver",
        ifelse(
          matrix_analyzed == "MU", "muscle",
          ifelse(
            matrix_analyzed == "WO", "whole organism", NA
          )
        )
      )
    )
  return(df_vars_renamed)
}

## same names and structures so can apply function to all datasets
lapply(
  list("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(sub_samp_ref = tblBioID)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
lapply(
  list("pcb_rawdata_sed", "dioxin_rawdata_sed"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(press_depth = DEPHU, depth_low = DEPHL)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
```

---

<br>

#### 2.2.2 Standardize Units for Data: PCB, Dioxin, PFOS

The main objective of the code below is to clean the contaminants datases set so they contain only values based on wet weight for biota or dry weight for sediment-matrix measurements, in standardized units of ug/kg.
This includes the following pre-processing steps:
- remove flagged and deprecated data entries  
- separate 'b-bio' data from the other param group data ('oc-cb', 'oc-dx', or 'o-fl' for PCB, Dioxin, PFOS resp.) for use in lipid basis to wet weight conversion
- take averages where there are duplicate data samples, based on the sub_samp_ref value groupings for biota or samp_ref value groupings for sediment-matrix measurements
- convert all congener concentration data to ug/kg and to wet weight for biota
- if data were presented in lipid weight, they were converted to wet weight by: $(\mbox{EXLIP%}/100)*(\mbox{CB conc. lipid weight})$

The datasets each contain two main categories (param_groups) one of which is BBIO. BBIO consists of variables with information about the sample like dry/lipid/wet weight percentage, age, weight and length. The second category contains the congeners concentration information. In stages, these are each manipulated and later rejoined by the sample (samp_ref or sub_samp_ref) ID numbers.

<br>

<!-- the following code chunks are modified from raw_data_prep.r scripts in bhi-1.0-archive/baltic2015/prep/CW/contaminants -->
```{r standardize units in biota datasets, echo = TRUE}

contam_standardize_data <- function(data_renamed, matrix_biota = TRUE, contam_param, rm_vars = NULL){
  
  ## what are the specific parameters?
  ## unique parameter groups and associated variables:
  chk_params <- data_renamed %>% 
    select(param_group, variable) %>% 
    distinct() %>% 
    arrange(param_group, variable)
 
  ## filter and/or remove unneeded variables from data ----
  message("STEP 1: filter and/or unselect unneeded variables and congeners from dataset\n")
  df <- data_renamed %>% 
    ## remove 'suspect' and other non-'acceptable': https://vocab.ices.dk/?ref=58
    filter(!vflag %in% c("S", "C")) %>% 
    ## remove samples for liver tissue, keep muscle, and whole organism for length x weight
    filter(matrix_analyzed != "liver" | is.na(matrix_analyzed)) %>% 
    ## remove certain variables-- summarized data or depreciated codes
    filter(!variable %in% rm_vars)
  
  
  ## sediment versus biota datasets, different sample/id variables
  sampvars <- c("sub_samp_ref", "samp_ref", "sub_samp_id")
  if(!matrix_biota){
    sampvars <- setdiff(sampvars, "sub_samp_ref")
  }
  ## check alignment of all measurements with sub_samp_ref for biota, samp_ref for sediment
  ## (most unique besides measurement_ref)
  ## there are more unique measurement_ref but these are for different vars w/in sub_samp_id
  chk_ids <- c()
  for(i in c(sampvars, "measurement_ref")){
    chk_ids <- c(chk_ids, sprintf("%s: %s", i, length(unique(df[[i]]))))
  }
  if(nrow(df %>% filter(is.na(sampvars[1]))) != 0){
    warning(sprintf("there are observations without %s in the dataset", sampvars[1]))
  }
  message(sprintf("NOTE will align by %s when grouping to identify duplicates\n", sampvars[1]))
  
  
  ## BBIO DATA
  
  ## separate out bbio data for lipid to wet-weight conversion ----
  ## B-BIO variable code: http://vocab.ices.dk/?CodeID=51634
  ## b-bio data -- length, weight, fat and lipid content
  ## lipid content, etc. needed to convert lipid basis samples into the wet weight are in the B-BIO column
  message("STEP 2: separate out bbio data and wrangle for use in lipid to wet-weight conversion...\n")
  df_bbio <- df  %>% 
    filter(param_group == "B-BIO") %>%
    select(
      station, latitude, longitude, date, year, sampvars, 
      species, matrix_analyzed, basis_determination,
      variable, unit, value
    )
  
  ## if there are cm, convert to mm
  df_bbio <- df_bbio %>% 
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "mm"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = ifelse(is.na(ConvertUnit), value, value*ConvertFactor),
      unit = ifelse(is.na(ConvertUnit), unit, "mm")
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## confirm that units of bbio, are one-to-one
  chk_bbio_units <- df_bbio %>% 
    select(variable, unit) %>% 
    distinct()
  
  df_bbio <- select(df_bbio, -unit)

  
  chk_num_bbio_dup <- nrow(df_bbio) - nrow(distinct(df_bbio %>% select(-value)))
  
  ## BBIO DUPLICATES
  ## identify, explore, handle bbio duplicates ----
  ## group to identify duplicates; for a given sub_samp_ref only some variables may have duplicates
  grpvars <- c(
    sampvars, "date", "variable",
    "longitude", "latitude", "station", "year", "species",
    "basis_determination", "matrix_analyzed"
  )
  chk <- c()
  for(i in 8:length(grpvars)){
    bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(c(grpvars[1:7], grpvars[8:i]))) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
    chk <- c(chk, nrow(filter(bbio_duplicates, n > 1)))
  }
  if(var(chk) != 0){
    message(sprintf(
      "NOTE bbio duplicates dataframe dims vary with ID variables, investigate in grpvars: %s",
      paste(grpvars[which(chk == boxplot(chk, plot = FALSE)$out)+7], collapse = ", ")
    ))
  }
  
  ## join duplicate table by grouped vars to locate within full bbio dataset
  df_bbio <- left_join(df_bbio, bbio_duplicates, by = grpvars)
  
  ## take averages for variable/sample duplicates
  df_bbio <- bind_rows(
    ## averages of duplicates
    df_bbio %>% 
      filter(n > 1) %>% 
      group_by(!!!syms(grpvars)) %>% 
      summarize(value = mean(value)) %>% 
      ungroup(),
    ## rows of bbio data with no duplicates
    df_bbio %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## check for unique variables and matrix_analyzed, per species
  chk_bbio_vars <- NULL
  if(matrix_biota){
    chk_bbio_vars <- do.call(
      rbind, 
      lapply(
        as.list(unique(df_bbio$species)), 
        function(x){
          cbind(
            df_bbio %>% 
              filter(species == x) %>%
              select(matrix_analyzed, basis_determination, variable) %>% 
              distinct(),
            species = x
          )
        }
      )
    )
  }
  
  ## WIDE BBIO DATA
  ## bbio data wide format ----
  df_bbio_wide <- tidyr::pivot_wider(df_bbio, names_from = variable, values_from = value)
  
  ## which columns are needed to uniquely identify and later rejoin with congener conc. data
  ## i.e. at this stage, which subset of grpvars gives groupings such that all n are one?
  # for(i in grpvars){print(paste(i, length(unique(df_bbio_wide[[i]]))))}
  chkgrpvars <- intersect(grpvars, names(df_bbio_wide))
  chk <- chkgrpvars
  for(i in 1:length(chkgrpvars)){
    bbio_wide_duplicates <- df_bbio_wide %>% 
      group_by(!!!syms(setdiff(chk, chkgrpvars[i]))) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    if(nrow(bbio_wide_duplicates) == 0){
      chk <- setdiff(chk, chkgrpvars[i])
    }
  }
  message(sprintf(
    "NOTE minimum group ID variables for later rejoining uniquely with congener data:\n%s\n", 
    paste(chk, collapse = ", ")
  ))
  chk_bbio_wide_ids <- chk
  ## sub_samp_id and samp_ref together are as unique as sub_samp_ref
  # nrow(select(df_bbio_wide, sub_samp_ref) %>% distinct())
  # nrow(select(df_bbio_wide, sub_samp_id, samp_ref) %>% distinct())
  
  
  ## CONGENER CONCENTRATIONS DATA
  ## check congener concentration data, units and duplicates ----
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  
  df_conc <- df %>%
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      station, latitude, longitude, date, year, sampvars,
      species, matrix_analyzed, basis_determination,
      variable, unit, value, detect_lim, quant_lim
    )
  
  ## convert congener concentration units all to ug/kg
  message("STEP 3: convert congener concentrations units to ug/kg")
  df_conc <- df_conc %>%
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "ug/kg"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = value*ConvertFactor, 
      detect_lim = detect_lim*ConvertFactor,
      unit = "ug/kg"
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## check whether variables vs units relationship is one-to-one
  chk_conc_units <- df_conc %>% 
    select(variable, unit) %>% 
    distinct() %>%
    arrange(variable)
  
  df_conc <- select(df_conc, -unit)
  
  
  ## take averages for congener conc. variable x sample duplicates ----
  
  ## identify duplicates
  ## group to identify duplicates, 
  ## for a given sub_samp_ref only some vars/congeners may have duplicates
  message("STEP 4: averaging, where multiple congener concentrations observations per sub sample")
  chk_num_conc_dup <- nrow(df_conc) - nrow(distinct(df_conc %>% select(-value, -detect_lim, -quant_lim)))
  
  conc_duplicates <- df_conc %>% 
    group_by(!!!syms(grpvars)) %>%
    summarise(n = n()) %>% 
    filter(n > 1) %>% 
    ungroup()
  
  ## join duplicates tables by grouped vars to locate them in original dataset
  df_conc <- left_join(df_conc, conc_duplicates, by = grpvars)
  chk_conc_dup <- filter(df_conc, !is.na(n))
  
  df_conc <- bind_rows(
    ## averages of duplicates
    df_conc %>% 
      filter(n > 1) %>%
      group_by(!!!syms(grpvars)) %>% 
      summarize(
        value = mean(value), 
        detect_lim = mean(detect_lim, na.rm = TRUE), 
        quant_lim =  mean(detect_lim, na.rm = TRUE)
      ) %>% 
      ungroup(),
    ## rows of conc data with no duplicates
    df_conc %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## separate detect and quantification limit variables before next steps
  detect_quant_lims <- select(df_conc, grpvars, detect_lim, quant_lim)
  chk_lims_ids <- nrow(detect_quant_lims) == nrow(distinct(select(detect_quant_lims, grpvars)))

  ## spread df_conc data to wide format
  ## UNITS HAVE ALL BEEN CONVERTED TO MICROGRAMS PER KILOGRAM
  df_conc_wide <- df_conc %>%
    select(-detect_lim, -quant_lim) %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  
  ## remaining duplicates for biota datasets are due to dual wet/lipid weight records:
  ## of these, keep wet weight records
  if(matrix_biota){
    chk <- setdiff(grpvars, c("basis_determination", "matrix_analyzed", "variable"))
    chk_conc_wide_id <- df_conc_wide %>%
      group_by(!!!syms(chk)) %>%
      mutate(n = n()) %>%
      filter(n > 1) %>% 
      ungroup()
    chk_conc_wide_id <- unique(chk_conc_wide_id[[sampvars[1]]])
    df_conc_wide <- df_conc_wide %>%
      filter(!(sampvars[1] %in% chk_conc_wide_id & basis_determination == "lipid weight"))
  }
  
  ## check one row for every unique sub_samp_ref for biota, samp_ref for sediment
  chk_conc_sub_samp <- length(unique(df_conc[[sampvars[1]]])) == nrow(distinct(df_conc_wide))
  
  
  ## for biota convert lipid weight measurements to wet weight ----
  ## use the df_bbio_wide datatable to convert values in df_conc_wide table
  df_final <- df_conc_wide %>% 
      left_join(df_bbio_wide, by = intersect(grpvars, names(df_bbio_wide))) %>% 
      tidyr::pivot_longer(
        cols = tidyselect::one_of(unique(df_conc$variable)), 
        names_to = "variable", 
        values_to = "value"
      ) %>% 
      left_join(detect_quant_lims, by = grpvars) 
  
  if(matrix_biota){
    message("STEP 5: converting congener concentrations observations all to wet weight")
    df_final <- df_final %>% 
      ## if value is not wet weight convert, otherwise keep value
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`EXLIP%`/100),
          basis_determination == "dry weight" ~ .*(`DRYWT%`/100),
          basis_determination == "wet weight" ~ .
        )
        ))
  }
  
  ## rejoin with meta information ----
  ## rejoin with info on country and monitoring program info, qflaugs, etc
  message("FINAL STEP: rejoining with meta information\n")
  df_final <- df %>% 
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      country, monit_program, monit_purpose, 
      report_institute, 
      monit_year, date_ices, day, month,
      num_indiv_subsample, 
      qflag, uncert_val, method_uncert, bulk_id, grpvars
    ) %>% 
  right_join(df_final, by = grpvars) %>% 
  mutate(qflagged = ifelse(is.na(qflag), FALSE, TRUE))
  
  
  ## return wrangled data and checks ----
  
  ## list of checks as part of result
  chks <- list(
    chk_params, chk_ids, 
    chk_bbio_units, chk_num_bbio_dup, chk_bbio_vars,
    chk_conc_units, chk_num_conc_dup, chk_conc_dup,
    chk_lims_ids, chk_conc_sub_samp
  )
  
  df_final <- filter(df_final, !is.na(value))
  return(list(
    df_final = df_final, 
    df_conc_wide = df_conc_wide, 
    df_bbio_wide = df_bbio_wide, 
    checks = chks
  ))
}
```

---

<br>

#### 2.2.3 Save all Wrangled Data

```{r save cleaned datasets, echo = TRUE}
dir_interm <- here::here("data", "CW", "contaminants", version_year, "intermediate")

lapply(
  list(
    ## PCB datasets
    ## remove PCB, SCB, SCB7 - these are summarized data or depreciated codes
    ## OC-CB variable codes: vocab.ices.dk/?CodeID=26983
    list("pcb_bio", TRUE, "OC-CB", c("PCB", "SCB", "SCB7")),
    list("pcb_sed", FALSE, "OC-CB", c("PCB", "SCB", "SCB7")),
    
    ## Dioxin datasets
    list("dioxin_bio", TRUE, "OC-DX", NULL),
    list("dioxin_sed", FALSE, "OC-DX", NULL),

    ## PFOS dataset
    list("pfos_bio", TRUE, "O-FL", NULL)
  ),
  
  function(dat){
    dat_final <- contam_standardize_data(get(dat[[1]]), dat[[2]], dat[[3]], dat[[4]]) 
    assign(
      x = paste(dat[[1]], "cleaned", sep = "_"), 
      value = dat_final, 
      envir = .GlobalEnv
    )
    write_csv(
      dat_final[["df_final"]], 
      file.path(dir_interm, paste(dat[[1]], "cleaned.csv", sep = "_"))
    )
  }
)
```

<br>

---

<br>

### 2.3 Initial Data Exploration

<br>

#### 2.3.1 Plots by Congener

```{r plots by congener, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5}
## reshape for plotting
plotdf <- pcb_bio_cleaned$df_final %>% # try also with pfos_bio_cleaned$df_final etc...
  group_by(variable, month, year, country) %>% 
  summarize(Value = mean(value, na.rm = TRUE) %>% round(3)) %>% 
  ungroup() %>% 
  group_by(variable, year, country) %>%
  mutate(yearlyMean = mean(Value, na.rm = TRUE) %>% round(3)) %>% 
  ungroup %>% 
  filter(year > 2000) %>% 
  rename(Congener = variable, Year = year) %>% 
  mutate(Date = as.Date(paste("1", month, Year, sep = "-"), tryFormats = "%d-%m-%Y"))

## color palettes
cols <- c(
  RColorBrewer::brewer.pal(8, "Dark2"), 
  RColorBrewer::brewer.pal(9, "Set1")
)
cols <- colorRampPalette(cols)(42)[sample(1:42)]

## monthly plots
plotly::ggplotly(
  ggplot(plotdf, aes(Date, Value, fill = Congener)) +
    geom_col(position = "stack", show.legend = FALSE) +
    scale_x_date(
      breaks = function(x){seq.Date(from = min(plotdf$Date), to = max(plotdf$Date), by = "3 months")},
      date_labels = "%b %Y"
    ) +
    scale_fill_manual(values = cols) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, size = 6)) +
    facet_wrap(~country, scales = "free_y", ncol = 1) 
)
## yearly plots
plotly::ggplotly(
  ggplot(plotdf, aes(Year, yearlyMean, fill = Congener)) +
    geom_col(position = "stack", show.legend = FALSE) +
    scale_fill_manual(values = cols) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, size = 6)) +
    facet_wrap(~country, scales = "free_y", ncol = 1) 
)
```

<br> 

#### 2.3.2 Spatial Sampling Densities Map

```{r sampling maps, results = "show", message = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 4.7, out.width = "120%"}
## basemap with baltic countries borders and BHI regions with ID numbers
bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile"), 
    layer = "BHI_shapefile",
    quiet = TRUE
  )) %>% sf::st_as_sf()

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", 
    size = 0.1
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "grey40") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(
    panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3")
  )

## mapping datasets for biota and sediments
make_mapdf <- function(x, y){
  cbind(
    get(x) %>% 
      filter(year %in% y) %>%
      group_by(month, latitude, longitude) %>%
      summarize(
        count_obs = n(), 
        num_congener = n_distinct(variable), 
        mean_val = mean(value, na.rm = TRUE), 
        sum_val = sum(value)
      ) %>%
      tidyr::pivot_longer(
        cols = c(mean_val, sum_val, count_obs, num_congener), 
        names_to = "metric", values_to = "value"
      ) %>%
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326, agr = "identity"),
    source = x)
}
mapdf_biota <- do.call(rbind, lapply(list("pcb_bio", "pfos_bio", "dioxin_bio"), function(x) make_mapdf(x, 2015:2019)))
mapdf_sediment <- do.call(rbind, lapply(list("pcb_sed", "dioxin_sed"), function(x) make_mapdf(x, 2013:2019)))


## contaminants datasets overlaying basemap
basemap + 
  geom_sf(
    aes(size = value, color = month), 
    alpha = 0.5, 
    shape = 19, 
    data = mapdf_biota %>% mutate(month = as.factor(month)),
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric))

basemap + 
  geom_sf(
    aes(size = value, color = month), 
    alpha = 0.5, 
    shape = 19, 
    data = mapdf_sediment %>% mutate(month = as.factor(month)),
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric))
```

<br>

#### 2.3.3 Contaminants in Biota vs Sediments

```{r contaminants in biota vs sediment histograms, echo = TRUE, fig.width = 8, fig.height = 5, fig.width = 100%}
sf::st_geometry(mapdf_sediment) <- NULL
sf::st_geometry(mapdf_biota) <- NULL

boxdf <- bind_rows(
  mutate(
    mapdf_sediment, 
    matrix = "sediment",
    source = str_remove(source, "_[a-z]+")
  ),
  mutate(
    mapdf_biota, 
    matrix = "biota",
    source = str_remove(source, "_[a-z]+")
  )
) %>% filter(metric == "mean_val")

ggplot(boxdf, aes(x = source, y = value, color = matrix)) + 
  geom_boxplot(outlier.shape = NA) + 
  scale_y_continuous(limits = quantile(boxdf$value, c(0.1, 0.9))) + 
  coord_flip() + 
  labs(
    y = "\nMean value Congener Concentrations \n(ug/kg, without outliers)", 
    x = NULL, 
    color = "Contaminant, Matrix"
  ) + 
  theme(legend.position = c(0.9, 0.8)) +
  scale_color_manual(values = RColorBrewer::brewer.pal(5, "Paired"))
```

<br>
