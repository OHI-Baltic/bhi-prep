
```{r preamble data, echo = FALSE, include = FALSE, error = FALSE}
source(here::here("R", "setup.R"))
```


### 2.1 Datasets with Sources
<br/>

#### 2.1.1 PCB Data

**PCB Data in Biota**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_PCBs.csv -->
<!-- w/ one year more of data...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_20Feb07_PCBs.csv -->
```{r PCB biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2017"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**PCB Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26983 -->
```{r PCB congeners table, echo = FALSE}
pcb_congeners <- t(data.frame(
  c("CB180", "2,2',3,4,4',5,5'-heptachlorobiphenyl"),
  c("SCB7", "sum of CBs.- Sum of"),
  c("CB28", "2,4,4'-trichlorobiphenyl"),
  c("CB52", "2,2',5,5'-tetrachlorobiphenyl"),
  c("CB101", "2,2',4,5,5'-pentachlorobiphenyl"),
  c("CB118", "2,3',4,4',5-pentachlorobiphenyl"),
  c("CB153", "2,2',4,4',5,5'-hexachlorobiphenyl"),
  c("CB138", "2,2',3,4,4',5'-hexachlorobiphenyl"),
  c("PCB", "polychlorinated biphenyls - Deprecated- Report as single PCBs"),
  c("CB194", "2,2',3,3',4,4',5,5'-octachlorobiphenyl"),
  c("CB105", "2,3,3',4,4'-pentachlorobiphenyl"),
  c("CB110", "2,3,3',4',6-pentachlorobiphenyl"),
  c("CB126", "3,3',4,4',5-pentachlorobiphenyl"),
  c("CB128", "2,2',3,3',4,4'-hexachlorobiphenyl"),
  c("CB149", "2,2',3,4',5',6-hexachlorobiphenyl"),
  c("CB151", "2,2',3,5,5',6-hexachlorobiphenyl"),
  c("CB156", "2,3,3',4,4',5-hexachlorobiphenyl"),
  c("CB157", "2,3,4,3',4',5'-hexachlorobiphenyl"),
  c("CB170", "2,2',3,3',4,4',5-heptachlorobiphenyl"),
  c("CB44", "2,2',3,5'-tetrachlorobiphenyl"),
  c("CB49", "2,2',4,5'-tetrachlorobiphenyl"),
  c("CB99", "2,2',4,4',5-pentachlorobiphenyl"),
  c("CB77", "3,3',4,4'-tetrachlorobiphenyl"),
  c("CB169", "3,3',4,4',5,5'-hexachlorobiphenyl"),
  c("CB31", "2,4',5-trichlorobiphenyl"),
  c("CB81", "3,4,4',5-tetrachlorobiphenyl"),
  c("SCB", "sum of CBs.- Specify in method data"),
  c("CB189", "2,3,3',4,4',5,5'-heptachlorobiphenyl"),
  c("CB114", "2,3,4,4',5-pentachlorobiphenyl"),
  c("CB123", "1,1'-Biphenyl, 2,3',4,4',5'-pentachloro-"),
  c("CB167", "2',3,4,4',5,5'-hexachlorobiphenyl"),
  c("CB187", "2,2',3,4',5,5',6-heptachlorobiphenyl"),
  c("CB66", "2,3',4,4'-tetrachlorobiphenyl"),
  c("CB60", "1,1'-Biphenyl, 2,3,4,4'-tetrachloro-"),
  c("CB141", "2,2',3,4,5,5'-hexachlorobiphenyl"),
  c("CB74", "2,4,4',5-tetrachlorobiphenyl"),
  c("CB206", "2,2',3,3',4,4',5,5',6-nonachlorobiphenyl"),
  c("CB33", "2',3,4-trichlorobiphenyl"),
  c("CB18", "2,2',5-trichlorobiphenyl"),
  c("CB183", "2,2',3,4,4',5',6-heptachlorobiphenyl"),
  c("CB47", "2,2',4,4'-tetrachlorobiphenyl"),
  c("CB209", "2,2',3,3',4,4',5,5',6,6'-decachlorobiphenyl"),
  c("CB51", "2,2',4,6'-Tetrachlorobiphenyl"),
  c("CB122", "1,1'-Biphenyl, 2,3,3',4',5'-pentachloro-"),
  c("CB138+163", "2,2',3,4,4',5'-hexachlorobiphenyl")))

colnames(pcb_congeners) <- c("Data Code", "")
rownames(pcb_congeners) <- NULL
htmlTable::htmlTable(pcb_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br/>

**PCBs in Sediment**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_PCBs/ContaminantsSediment_PCBs.csv -->
```{r PCB sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All8"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.2 PFOS Data

**PFOS in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_PFOS.csv -->
<!-- w/ one year more of data...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_20Feb07_PFOS.csv -->
```{r PFOS biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "2005-2017  (2005 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Organofluorines"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```
<br/>

#### 2.1.3 Dioxin Data

**Dioxins in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_Dioxins.csv -->
<!-- w/ one year more...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_20Feb07_Dioxins.csv -->
```{r dioxin biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1998-2017  (1998 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**Dioxin Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26986 -->
```{r dioxin congeners table, echo = FALSE}
dioxin_congeners <- t(data.frame(
  c("CDD1N", "1 2 3 7 8-pentachlorodibenzo-p-dioxin"),  
  c("CDD4X", "1 2 3 4 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD6P", "1 2 3 4 6 7 8-heptachlorodibenzo-p-dioxin"), 
  c("CDD6X", "1 2 3 6 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD9X", "1 2 3 7 8 9-hexachlorodibenzo-p-dioxin"), 
  c("CDDO", "1 2 3 4 6 7 8 9-octachlorodibenzo-p-dioxin"),   
  c("CDF2N", "2 3 4 7 8-pentachlorodibenzofuran"),   
  c("CDF2T", "2 3 7 8-tetrachloro-dibenzofuran"),   
  c("CDF4X", "2 3 4 6 7 8-hexachlorodibenzofuran"),   
  c("CDF6P", "1 2 3 4 6 7 8-heptachlorodibenzofuran"),   
  c("CDF6X", "1 2 3 6 7 8-hexachlorodibenzofuran"),   
  c("CDF9P", "1 2 3 4 7 8 9-heptachlorodibenzofuran"),   
  c("CDF9X", "1 2 3 7 8 9-hexachlorodibenzofuran"),   
  c("CDFDN", "1 2 3 7 8/1 2 3 4 8-pentachloro-dibenzofuran"),   
  c("CDFO", "octachloro-dibenzofuran (group)"),    
  c("TCDD", "2 3 7 8-tetrachlorodibenzo-p-dioxin")))   

colnames(dioxin_congeners) <- c("Data Code", "")
rownames(dioxin_congeners) <- NULL
htmlTable::htmlTable(dioxin_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br>

**Dioxins in Sediment**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_Dioxins/ContaminantsSediment_Dioxins.csv -->
```{r dioxin sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
---

<br>

### 2.2 Centralization & Normalization
<!-- note: remainder of this document incorporates from BHI1.0, along with preliminary contaminants_prep.Rmd sections: -->
<!-- raw_pcb_data_prep.R, raw_dioxin_data_prep.R, and raw_pfos_data_prep.R -->
<!-- station_attribute_prep.R, congener_description.R -->

This preliminary data wrangling includes steps to harmonize and check the 5 datasets used in the Contaminants subgoal: 

- Check number of years with samples by Country and Species, for Contaminants in Biota datasets
- Rename columns and some variables within columns to improve clarity
- Standardize by converting units and also between methods of measurement (e.g. wet vs. dry weight or muscle vs liver matrix analyzed)

More details about the standardization and convertions in section 2.2.2.


```{r read raw datasets, message = FALSE, warning = FALSE, echo = TRUE, results = "hide"}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "CW", "CON")

lapply(
  list(
    c("ContaminantsBiota_20Feb07_PCBs", "pcb_rawdata_bio"),
    c("ContaminantsSediment_PCBs", "pcb_rawdata_sed"),
    c("ContaminantsBiota_20Feb07_PFOS", "pfos_rawdata_bio"),
    c("ContaminantsBiota_20Feb07_Dioxins", "dioxin_rawdata_bio"),
    c("ContaminantsSediment_Dioxins", "dioxin_rawdata_sed")
  ),
  function(x){
    read_csv(
      file.path(dir_rawdata, x[1], paste(x[1], "csv", sep = ".")),
      ## where not read in correctly, column types must be specified ...
      col_types = cols(
        .default = col_character(),
        MYEAR = col_number(), 
        Latitude = col_number(), 
        Longitude = col_number(), 
        NOINP = col_number(),
        Value = col_number(), 
        DETLI = col_number(), 
        LMQNT = col_number(), 
        UNCRT = col_number(),
        tblAnalysisID = col_number(), 
        tblParamID = col_number(), 
        tblBioID = col_number(), 
        tblSampleID = col_number()
      )
    ) %>% assign(x = x[2], envir = .GlobalEnv)
  }
)
```


##### Check number of years with samples by Country {.tabset .tabset-fade .tabset-pills}

***

###### PCBs

```{r check number of years sample by country in pcb data,  results  = "show"}
## check number of dates and years sample by country, PCBs data from ICES
## Denmark doesn't have herring data...
do.call(rbind, lapply(as.list(unique(pcb_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  ) %>% select(Country, Species, NumYrs, LatestYr)
})) %>% DT::datatable(options = list(sDom  = '<"bottom">rrt<"top">ip'), rownames = FALSE)
```

###### PFOS 

```{r check number of dates and years sample by country in pfos data,  results  = "show"}
do.call(rbind, lapply(as.list(unique(pfos_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  ) %>% select(Country, Species, NumYrs, LatestYr)
})) %>% DT::datatable(options = list(sDom  = '<"bottom">rrt<"top">ip'), rownames = FALSE)
```

###### Dioxins

```{r check number of dates and years sample by country in dioxin data,  results  = "show"}
do.call(rbind, lapply(as.list(unique(dioxin_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  ) %>% select(Country, Species, NumYrs, LatestYr)
})) %>% DT::datatable(options = list(sDom  = '<"bottom">rrt<"top">ip'), rownames = FALSE)
```

***

<br>

---

#### 2.2.1 Rename Fields/Variables

Renaming columns and some variables within columns for clarity. See references: [Contaminants in Biota](http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20biota.pdf) and [Contaminants in Sediment](http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20sediment.pdf). For more information about the ICES reporting format for environmental data see [this document](http://ices.dk/marine-data/Documents/ENV/ERF3.2.doc), also referenced in [this document from HELCOM BalticBOOST workshop](https://portal.helcom.fi/meetings/HELCOM%20BalticBOOST%20HZ%20WS%201-2016-323/MeetingDocuments/1-9%20Comparison%20of%20COMBINE%20data%20fields%20to%20EIONET%20data%20fields.pdf) on the HOLAS II hazardous substance assessment.

```{r rename fields for data, echo = TRUE, results = "hide"}
rename_vars <- function(dataset){
  
  df_vars_renamed <- dataset %>% 
    
    ## create date, month, year, day columns
    dplyr::mutate(date = as.Date(DATE, "%d/%m/%Y")) %>% 
    
    dplyr::mutate(
      day = lubridate::day(date),
      month = lubridate::month(date), 
      year = lubridate::year(date)) %>% 
    
    ## change column names
    dplyr::rename(
      country = Country, report_institute = RLABO,
      station = STATN, 
      monit_year = MYEAR, date_ices = DATE,
      
      latitude = Latitude, longitude = Longitude,
      
      param_group = PARGROUP, variable = PARAM, 
      value = Value, unit = MUNIT,
      
      species = Species, sex_specimen = SEXCO, num_indiv_subsample = NOINP,
      test_organism = `Test Organism`,
      matrix_analyzed = MATRX, not_used_in_datatype = NODIS,
      
      monit_program = MPROG, monit_purpose = PURPM,
      
      basis_determination = BASIS, qflag = QFLAG,
      vflag = VFLAG, detect_lim = DETLI,
      quant_lim = LMQNT, uncert_val = UNCRT, method_uncert = METCU,
      
      analyt_lab = ALABO, ref_source = REFSK, 
      method_storage = METST, method_pretreat = METPT, 
      method_pur_sep = METPS, method_chem_fix = METFP,
      method_chem_extract = METCX, method_analysis = METOA, 
      formula_calc = FORML,
      
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sampler_type = SMTYP, factor_compli_interp = FINFL,
      
      analyt_method_ref = tblAnalysisID, 
      measurement_ref = tblParamID,
      samp_ref = tblSampleID
    ) %>% 
    
    ## improve clarity of 'basis_determination' and 'matrix_analyzed' column content
    mutate(
      basis_determination = ifelse(
        basis_determination == "L", "lipid weight",
        ifelse(
          basis_determination == "W", "wet weight",
          ifelse(
            basis_determination == "D", "dry weight", NA
          )
        )
      ),
      matrix_analyzed = ifelse(
        matrix_analyzed == "LI", "liver",
        ifelse(
          matrix_analyzed == "MU", "muscle",
          ifelse(
            matrix_analyzed == "WO", "wholeorganism", NA
          )
        )
      )
    )
  
  return(df_vars_renamed)
}

## same names and structures so can apply function to all datasets
lapply(
  list("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(sub_samp_ref = tblBioID)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
lapply(
  list("pcb_rawdata_sed", "dioxin_rawdata_sed"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(press_depth = DEPHU, depth_low = DEPHL) %>% 
      mutate(press_depth = as.numeric(press_depth), depth_low = as.numeric(depth_low))
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
rm("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio", "pcb_rawdata_sed", "dioxin_rawdata_sed")
```

---

#### 2.2.2 Standardize Units


The main objective of the code below is to clean the contaminants datases set so they contain only values based on wet weight for biota or dry weight for sediment-matrix measurements, in standardized units of ug/kg.
This includes the following pre-processing steps:

- Remove flagged and deprecated data entries  
- Separate `B-BIO` data from the other param group data (`OC-CB`, `OC-DX`, or `O-FL` for PCB, Dioxin, PFOS resp.) for use in lipid basis to wet weight conversion for biota or for conversion to dry weight for sediments; also for calculation of muscle equivalent in PFOS data
- Take averages where there are duplicate data samples, based on the `sub_samp_ref` value groupings for biota or `samp_ref` value groupings for sediment-matrix measurements  
- If wrangling PFOS dataset, calculate the muscle equivalent of values where matrix analyzed was liver, using [Faxneld et al 2014, table 8](https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf)
- Convert all congener concentration data to ug/kg, and to wet weight for biota or dry weight for sediment
- If data were presented in lipid weight, they were converted to wet weight by: $(\mbox{EXLIP%}/100)*(\mbox{CB conc. lipid weight})$  


The datasets each contain two main categories (param_groups) one of which is BBIO. BBIO consists of variables with information about the sample like dry/lipid/wet weight percentage, age, weight and length. The second category contains the congeners concentration information. In stages, these are each manipulated and later rejoined by the sample (`samp_ref` or `sub_samp_ref`) ID numbers.

<br>

**Check Sediment data Coverage before Filtering and Standardizing Units**

Setting the cutoff to 0.05m (concentration measurements from sediment samples taked from within 5cm of the surface) means we retain coverage in the Gulf of Finland for PCBs indicator, and many more measurements in Germany around Kiel. Setting the depth cutoff to any smaller value would result in poor coverage.

```{r check at what depths theres still good sediment data coverage, warning = FALSE, message = FALSE, echo = TRUE}
## basemap with baltic countries borders and BHI regions with ID numbers
bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile"), 
    layer = "BHI_shapefile",
    quiet = TRUE
  )) %>% sf::st_as_sf()

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

depthcols <- c("firebrick", "coral", "khaki1", "thistle", "thistle4")
```

<br>

```{r spatial coverage for sediment measurement depths, results = "show", fig.width = 12, fig.height = 5}
pcb_sed_depths <- basemap + 
  geom_sf(
    data = pcb_sed %>% 
      filter(longitude > 9, depth_low <= 0.05) %>% ## play with depth value to evaluate spatial coverage...
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326),
    aes(size = depth_low, color = depth_low),
    show.legend = FALSE,
    alpha = 0.08
  ) +
  scale_color_gradientn(colors = depthcols)

dioxin_sed_depths <- basemap + 
  geom_sf(
    data = dioxin_sed %>% 
      filter(longitude > 9, depth_low <= 0.05) %>% ## play with depth value to evaluate spatial coverage...
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326),
    aes(size = depth_low, color = depth_low), 
    alpha = 0.08
  ) +
  scale_color_gradientn(colors = depthcols) +
  guides(color = guide_colorbar("Depth"), size = FALSE) +
  theme(legend.position = c(0.95, 0.85), legend.background = element_rect(color = "grey"))

gridExtra::grid.arrange(pcb_sed_depths, dioxin_sed_depths, nrow = 1)
```

<br>

<!-- the following code chunks are modified from raw_data_prep.r scripts in bhi-1.0-archive/baltic2015/prep/CW/contaminants -->

```{r standardize units in biota datasets, echo = TRUE}

standardize_con_data <- function(data_renamed, matrix_biota = TRUE, contam_param, rm_vars = NULL){
  
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  
  ## what are the specific parameters?
  ## unique parameter groups and associated variables:
  chk_params <- data_renamed %>% 
    select(param_group, variable) %>% 
    distinct() %>% 
    arrange(param_group, variable)
 
  ## filter and/or remove unneeded variables from data ----
  message("STEP 1: filter and/or unselect unneeded variables and congeners from dataset\n")
  df <- data_renamed %>% 
    ## remove 'suspect' and other non-'acceptable': https://vocab.ices.dk/?ref=58
    filter(!vflag %in% c("S", "C")) %>% 
    ## remove certain variables-- summarized data or depreciated codes
    filter(!variable %in% rm_vars)
  
  if(contam_param != "FL"){
    ## remove samples for liver tissue, keep muscle, and whole organism for length x weight
    df <- filter(df, matrix_analyzed != "liver" | is.na(matrix_analyzed))
  }
  ## for PFOS (contaminant pargroup 'O-FL'), keep liver measurements-- 
  ## all compounds except parameter 'PFOS' measured only in the liver
  ## DRYWT% and EXLIP% have been measured for both muscle and liver
  
  
  ## sediment versus biota datasets, different sample/id variables
  sampvars <- c("sub_samp_id", "samp_ref", "sub_samp_ref")
  if(!matrix_biota){
    sampvars <- setdiff(sampvars, "sub_samp_ref")
  }
  ## check alignment of all measurements with sub_samp_ref for biota, samp_ref for sediment
  ## (most unique besides measurement_ref)
  ## there are more unique measurement_ref but these are for different vars w/in sub_samp_id
  chk_ids <- c()
  for(i in c(sampvars, "measurement_ref")){
    chk_ids <- c(chk_ids, sprintf("%s: %s", i, length(unique(df[[i]]))))
  }
  if(nrow(df %>% filter(is.na(sampvars[length(sampvars)]))) != 0){
    warning(sprintf("there are observations without %s in the dataset", sampvars[length(sampvars)]))
  }
  message(sprintf("NOTE will align by %s when grouping to identify duplicates\n", sampvars[length(sampvars)]))
  
  
  ## BBIO DATA
  
  ## separate out bbio data for lipid to wet-weight conversion ----
  ## B-BIO variable code: http://vocab.ices.dk/?CodeID=51634
  ## b-bio data -- length, weight, fat and lipid content
  ## lipid content, etc. needed to convert lipid basis samples into the wet weight are in the B-BIO column
  message("STEP 2: separate out bbio data and wrangle for use in lipid to wet-weight conversion...\n")
  df_bbio <- df  %>% 
    filter(param_group == "B-BIO") %>%
    select(
      station, latitude, longitude, date, year, 
      species, matrix_analyzed, basis_determination, qflag,
      variable, unit, value,
      !!!syms(sampvars)
    )
  
  ## if there are cm, convert to mm
  df_bbio <- df_bbio %>% 
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "mm"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = ifelse(is.na(ConvertUnit), value, value*ConvertFactor),
      unit = ifelse(is.na(ConvertUnit), unit, "mm")
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## confirm that units of bbio, are one-to-one
  chk_bbio_units <- df_bbio %>% 
    select(variable, unit) %>% 
    distinct()
  
  ## if dealing with sediment, need to keep units for now...
  if(matrix_biota){df_bbio <- select(df_bbio, -unit)}

  chk_num_bbio_dup <- nrow(df_bbio) - nrow(distinct(df_bbio %>% select(-value)))
  
  ## BBIO DUPLICATES
  ## identify, explore, handle bbio duplicates ----
  ## group to identify duplicates; for a given sub_samp_ref only some variables may have duplicates
  grpvars <- c(
    "station", "year", "species", "basis_determination", "matrix_analyzed", "qflag", 
    sampvars, "date", "variable", "longitude", "latitude"
  )
  chk <- c()
  for(i in 1:6){
    bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(c(grpvars[i], grpvars[7:length(grpvars)]))) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
    chk <- c(chk, nrow(filter(bbio_duplicates, n > 1)))
  }
  if(var(chk) != 0){
    message(sprintf(
      "NOTE bbio duplicates dataframe dims vary with grpvars: %s",
      paste(grpvars[which(chk != chk[which.max(tabulate(match(chk, chk)))])], collapse = ", ")
    ))
  }
  
  ## join duplicate table by grouped vars to locate within full bbio dataset
  bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(grpvars)) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
  df_bbio <- left_join(df_bbio, bbio_duplicates, by = grpvars)
  
  ## take averages for variable/sample duplicates
  df_bbio <- bind_rows(
    ## averages of duplicates
    df_bbio %>% 
      filter(n > 1) %>% 
      group_by(!!!syms(grpvars)) %>% 
      summarize(value = mean(value)) %>% 
      ungroup(),
    ## rows of bbio data with no duplicates
    df_bbio %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## check for unique variables and matrix_analyzed, per species
  chk_bbio_vars <- NULL
  if(matrix_biota){
    chk_bbio_vars <- do.call(
      rbind, 
      lapply(
        as.list(unique(df_bbio$species)), 
        function(x){
          cbind(
            df_bbio %>% 
              filter(species == x) %>%
              select(matrix_analyzed, basis_determination, variable) %>% 
              distinct() %>% 
              arrange(variable, matrix_analyzed, basis_determination),
            species = x
          )
        }
      )
    )
  }

  
  ## WIDE BBIO DATA
  ## bbio data wide format ----
  
  ## remove basis_determ. as some bio vars are recorded for whole organism, others for liver or muscle,
  ## no concentration variables measured for whole organism matrix, so don't need for joining...
  ## no problem pivoting wider also indicates uniquely identified by remaining grouping variables
  # unique(filter(df, param_group != "B-BIO")$matrix_analyzed)
  
  if(contam_param == "FL"){
    ## for PFOS we have liver and muscle measurements
    ## need to deal with matrix_analyzed to get 'muscle equivalent' from conc. measurements in liver
    df_bbio_wide <- df_bbio %>% 
      mutate(variable = paste(matrix_analyzed, variable, sep = "_")) %>% 
      select(-matrix_analyzed, -basis_determination)
  } else {
    df_bbio_wide <- df_bbio %>% 
      select(-basis_determination)
  }
  df_bbio_wide <- df_bbio_wide %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  

  ## which columns are needed to uniquely identify and later rejoin with congener conc. data
  ## i.e. at this stage, which subset of grpvars gives groupings such that all n are one?
  # for(i in grpvars){print(paste(i, length(unique(df_bbio_wide[[i]]))))}
  chkgrpvars <- intersect(grpvars, names(df_bbio_wide))
  chk <- chkgrpvars
  for(i in 1:length(chkgrpvars)){
    bbio_wide_duplicates <- df_bbio_wide %>% 
      group_by(!!!syms(setdiff(chk, chkgrpvars[i]))) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    if(nrow(bbio_wide_duplicates) == 0){
      chk <- setdiff(chk, chkgrpvars[i])
    }
  }
  message(sprintf(
    "NOTE minimum group ID variables for later rejoining uniquely with congener data:\n%s\n", 
    paste(chk, collapse = ", ")
  ))
  chk_bbio_wide_ids <- chk
  ## sub_samp_id and samp_ref together are as unique as sub_samp_ref
  # nrow(select(df_bbio_wide, sub_samp_ref) %>% distinct())
  # nrow(select(df_bbio_wide, sub_samp_id, samp_ref) %>% distinct())
  
  
  ## CONGENER CONCENTRATIONS DATA
  ## check congener concentration data, units and duplicates ----
  
  if(!matrix_biota){
    ## units of depth variables meters
    ## only keep sediment measurements in top 2cm, 
    ## or maximum 5cm if filtering to within 2cm of surface yeilds too few data pts...
    df <- df %>% filter(depth_low <= 0.05) 
  }
  
  df_conc <- df %>%
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      station, latitude, longitude, date, year,
      species, matrix_analyzed, basis_determination,
      variable, unit, value, detect_lim, quant_lim, qflag,
      !!!syms(sampvars)
    )
  
  ## convert congener concentration units all to ug/kg
  message("STEP 3: convert congener concentrations units to ug/kg")
  df_conc <- df_conc %>%
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "ug/kg"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = value*ConvertFactor, 
      detect_lim = detect_lim*ConvertFactor,
      unit = "ug/kg"
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## check whether variables vs units relationship is one-to-one
  chk_conc_units <- df_conc %>% 
    select(variable, unit) %>% 
    distinct() %>%
    arrange(variable)
  
  df_conc <- select(df_conc, -unit)
  
  
  ## take averages for congener conc. variable x sample duplicates ----
  
  ## identify duplicates
  ## group to identify duplicates, 
  ## for a given sub_samp_ref only some vars/congeners may have duplicates
  message("STEP 4: averaging, where multiple congener concentrations observations per sub sample\n")
  chk_num_conc_dup <- nrow(df_conc) - nrow(distinct(df_conc %>% select(-value, -detect_lim, -quant_lim)))

  conc_duplicates <- df_conc %>% 
    group_by(!!!syms(grpvars)) %>%
    summarise(n = n()) %>% 
    ## no cases where duplicates with-and-without qflags, else would keep cases unflagged observations...
    # group_by(!!!syms(setdiff(grpvars, "qflag"))) %>%
    # mutate(allflagged = !any(is.na(qflag))) %>%
    # filter(n > 1, !allflagged) %>% ...
    filter(n > 1) %>% 
    ungroup()
  
  ## join duplicates tables by grouped vars to locate them in original dataset
  df_conc <- left_join(df_conc, conc_duplicates, by = grpvars)
  chk_conc_dup <- filter(df_conc, !is.na(n))
  
  df_conc <- bind_rows(
    ## averages of duplicates
    df_conc %>% 
      filter(n > 1) %>%
      group_by(!!!syms(grpvars)) %>% 
      summarize(
        value = mean(value), 
        detect_lim = mean(detect_lim, na.rm = TRUE), 
        quant_lim =  mean(detect_lim, na.rm = TRUE)
      ) %>% 
      ungroup(),
    ## rows of conc data with no duplicates
    df_conc %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## remaining duplicates for biota datasets are due to dual wet/lipid weight records;
  ## of these, keep wet weight records, when has a value
  if(matrix_biota){
    chk <- df_conc %>%
      group_by(!!!syms(setdiff(grpvars, c("basis_determination", "matrix_analyzed")))) %>%
      mutate(n = n(), ww_val = any(basis_determination == "wet weight" & !is.na(value))) %>%
      filter(n > 1) %>% 
      mutate(
        rm_duplicate = 
          (ww_val & basis_determination == "lipid weight")|
          (!ww_val & basis_determination == "wet weight")
      ) %>% 
      ungroup()
    df_conc <- df_conc %>%
      left_join(chk, by = intersect(names(df_conc), names(chk))) %>% 
      mutate(rm_duplicate = ifelse(is.na(rm_duplicate), TRUE, rm_duplicate)) %>% 
      filter(rm_duplicate) %>% 
      select(-n, -ww_val, -rm_duplicate)
  }
  
  ## do not want to spread the data because the qflag, detli etc is unique to each congener
  ## but, spread to check if one row for every unique sub_samp_ref for biota, samp_ref for sediment
  df_conc_wide <- df_conc %>%
    select(-detect_lim, -quant_lim) %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  if(length(unique(df_conc[[sampvars[length(sampvars)]]])) != nrow(distinct(df_conc_wide))){
    message(
      "NOTE conc. subsamples not uniquely identified even after averaging; 
            multiple obs per ID, probably due to qflags\n"
    )
  }
  
  ## for biota convert lipid weight measurements to wet weight ----
  ## UNITS HAVE ALL BEEN CONVERTED TO MICROGRAMS PER KILOGRAM
  ## use the df_bbio_wide datatable to convert values in df_conc table
  df_final <- left_join(df_conc, df_bbio_wide, by = intersect(grpvars, names(df_bbio_wide))) 
  
  if(matrix_biota){
    
    message("STEP 5: converting all congener concentrations in biota to wet weight, muscle equivalence")
    
    ## for PFOS data convert liver values into those for muscle 
    ## using conversion values from Faxneld et al 2014
    ## https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf)
    ## follow methods in the HELCOM core indicator p.9
    ## http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf
    ## use the mean liver:muscle ratio for all species (17.9), see Table 8 in Faxneld et al 2014
    if(contam_param == "FL"){
      df_final <- df_final %>% 
        mutate_at(
          vars(c("value", "detect_lim", "quant_lim")), 
          list(pfos_muscle_equiv = ~ case_when(
            variable == "PFOS" & matrix_analyzed == "liver" ~ ./17.9,
            variable == "PFOS" & matrix_analyzed == "muscle" ~ .,
            ## NOT IN BHI1.0, BUT INCLUDING FOR INITIAL EXPLORATION...
            variable == "PFOA" & species == "Clupea harengus" & matrix_analyzed == "liver" ~ ./13.4,
            variable == "PFOA" & species == "Clupea harengus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFOA" & species == "Zoarces viviparus" & matrix_analyzed == "liver" ~ ./6.13,
            variable == "PFOA" & species == "Zoarces viviparus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFOA" & species == "Perca fluviatilis" & matrix_analyzed == "liver" ~ ./13.7,
            variable == "PFOA" & species == "Perca fluviatilis" & matrix_analyzed == "muscle" ~ .,
            
            variable == "PFDA" & species == "Clupea harengus" & matrix_analyzed == "liver" ~ ./19.4,
            variable == "PFDA" & species == "Clupea harengus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFDA" & species == "Zoarces viviparus" & matrix_analyzed == "liver" ~ ./5.69,
            variable == "PFDA" & species == "Zoarces viviparus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFDA" & species == "Perca fluviatiliss" & matrix_analyzed == "liver" ~ ./5.69,
            variable == "PFDA" & species == "Perca fluviatilis" & matrix_analyzed == "muscle" ~ .,
            
            variable == "PFNA" & species == "Clupea harengus" & matrix_analyzed == "liver" ~ ./15.5,
            variable == "PFNA" & species == "Clupea harengus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFNA" & species == "Zoarces viviparus" & matrix_analyzed == "liver" ~ ./5.62,
            variable == "PFNA" & species == "Zoarces viviparus" & matrix_analyzed == "muscle" ~ .,
            variable == "PFNA" & species == "Perca fluviatilis" & matrix_analyzed == "liver" ~ ./13.7,
            variable == "PFNA" & species == "Perca fluviatilis" & matrix_analyzed == "muscle" ~ .,

            variable == "PFPEDA" & matrix_analyzed == "liver" ~ ./7.4,
            variable == "PFPEDA" & matrix_analyzed == "muscle" ~ .,
            variable == "PFUnDA" & matrix_analyzed == "liver" ~ ./10.1,
            variable == "PFUnDA" & matrix_analyzed == "muscle" ~ .
          ))
        ) %>% 
        mutate_at(
        vars(c("value_pfos_muscle_equiv", "detect_lim_pfos_muscle_equiv", "quant_lim_pfos_muscle_equiv")), 
        ## will probably all be in wet weight already, but just in case...
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`muscle_EXLIP%`/100), # IS THIS HOW EXLIP% VARIABLE WORKS??
          basis_determination == "dry weight" ~ .*(100/`muscle_DRYWT%`), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "wet weight" ~ .
        ))
      )
    } else {
      df_final <- df_final %>% 
      ## if value is not wet weight convert, otherwise keep value
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`EXLIP%`/100), # IS THIS HOW EXLIP% VARIABLE WORKS????
          basis_determination == "dry weight" ~ .*(100/`DRYWT%`), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "wet weight" ~ .
        ))
      )
    }
    
  }
  ## for sediment data, still need to convert to dry weights
  if(!matrix_biota){
    ## what to do with the dry weights....
    message("STEP 5: converting all congener concentrations in sediment to dry weight")
    df_final <- df_final %>% 
      ## if value is not dry weight convert, otherwise keep value
      ## even though some have units of ug/kg treat the DRYWT% as percentage...
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(dry_wgt = ~ case_when(
          basis_determination == "wet weight" ~ .*(`DRYWT%`/100), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "dry weight" ~ .
        ))
      )
  }
  
  ## rejoin with meta information ----
  ## rejoin with info on country and monitoring program info, qflaugs, etc
  message("FINAL STEP: rejoining with meta information\n")
  
  df_final <- df %>% 
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      country, monit_program, monit_purpose, 
      report_institute, 
      monit_year, date_ices, day, month,
      num_indiv_subsample, bulk_id,  
      !!!syms(grpvars)
    ) %>% 
    distinct() %>% 
    right_join(df_final, by = grpvars) %>% 
    mutate(qflagged = ifelse(is.na(qflag), FALSE, TRUE))
  
  ## return wrangled data and checks ----
  
  ## list of checks as part of result
  chks <- list(
    chk_params, chk_ids, 
    chk_bbio_units, chk_num_bbio_dup, chk_bbio_vars,
    chk_conc_units, chk_num_conc_dup, chk_conc_dup
  )
  
  df_final <- filter(df_final, !is.na(value))
    
  if(!all(mutate(group_by(df_final, !!!syms(grpvars)), n = n())$n == 1)){
    warning("NOTE rows of final dataframe are not uniquely identified by grouping variables")
  }
  
  return(list(
    df_final = df_final, 
    groupingvars = grpvars,
    df_conc_wide = df_conc_wide, 
    df_bbio_wide = df_bbio_wide, 
    checks = chks
  ))
}
```

<br>

#### 2.2.3 Wrangle all and Save

Apply the Standardization function defined above to all 5 Contaminants datasets and save the cleaned, harmonized data for later analysis.
For PCBs in biota data, remove PCB, SCB, SCB7 variables as these are summarized data or depreciated codes; for PCBs in sediments remove PCB and SCB. 

<!-- ideally at this stage we would save to a postgres+postgis database; still in the process of building this database now -->

```{r save cleaned datasets, echo = TRUE, message = FALSE, warning = FALSE, results = "hide"}
dir_interm <- here::here("data", "CW", "contaminants", version_year, "intermediate")

lapply(
  list(
    ## for param definitions see //vocab.ices.dk/?ref=37
    
    ## PCB datasets
    ## remove PCB, SCB, SCB7 - these are summarized data or depreciated codes
    ## OC-CB variable codes: vocab.ices.dk/?CodeID=26983
    list("pcb_bio", TRUE, "OC-CB", c("PCB", "SCB", "SCB7")),
    list("pcb_sed", FALSE, "OC-CB", c("PCB", "SCB")),
    
    ## Dioxin datasets
    list("dioxin_bio", TRUE, "OC-DX", NULL),
    list("dioxin_sed", FALSE, "OC-DX", NULL),

    ## PFOS dataset
    list("pfos_bio", TRUE, "O-FL", NULL)
  ),
  
  function(dat){
    dat_final <- standardize_con_data(get(dat[[1]]), dat[[2]], dat[[3]], dat[[4]]) 
    assign(
      x = paste(dat[[1]], "cleaned", sep = "_"), 
      value = dat_final, 
      envir = .GlobalEnv
    )
    assign(
      x = paste(dat[[1]], "clean_df", sep = "_"), 
      value = dat_final[["df_final"]], 
      envir = .GlobalEnv
    )
    write_csv(
      dat_final[["df_final"]], 
      file.path(dir_interm, paste(dat[[1]], "cleaned.csv", sep = "_"))
    )
  }
)
```

---

### 2.3 Initial Data Exploration

```{r combining data for initial exploration, echo = TRUE, warning = FALSE, message = FALSE}
## to start running code from here, will need to load in cleaned  datasets...

# dir_interm <- here::here("data/CW/contaminants/v2019/intermediate")
# lapply(list.files(dir_interm), function(dat){
#   dat_final <- read_csv(file.path(dir_interm, dat))
#   assign(
#     x = str_replace(dat, "cleaned.csv", "clean_df"),
#     value = dat_final,
#     envir = .GlobalEnv
#   )
# })

make_plotdf <- function(x, yrs){
  
  grpvars <- c("year", "latitude", "longitude", "variable", "num_distinct_dates", "species")
  valvar <- "value_wet_wgt"
  if(str_detect(x, "sed")){
    grpvars <- setdiff(grpvars, "species")
    valvar <- "value_dry_wgt"
  }
  if(str_detect(x, "pfos")){
    valvar <- "value_pfos_muscle_equiv_wet_wgt"
  }
  cbind(
    get(x) %>%
      filter(!is.na(!!!syms(valvar))) %>% 
      filter(year %in% yrs, longitude > 9) %>%
      group_by(latitude, longitude, variable) %>%
      ## number of disinct dates at the location for the variable
      mutate(num_distinct_dates = n_distinct(date)) %>%
      group_by(!!!syms(grpvars)) %>%
      ## mean annual values at the locatioin, by variable
      summarize(
        mean_val = ifelse(
          str_detect(x, "sed"), 
          mean(value_dry_wgt), 
          ifelse(
            str_detect(x, "pfos"),
            mean(value_pfos_muscle_equiv_wet_wgt), 
            mean(value_wet_wgt)
          )
        )
      ) %>%
      ungroup(),
    source = str_to_upper(str_remove(x, "_clean_df")))
}
## apply make_plotdf bringing all datasets together 
plotdf <- bind_rows(
  do.call(
    rbind, 
    lapply(
      list("pcb_bio_clean_df", "dioxin_bio_clean_df", "pfos_bio_clean_df"), 
      function(x) make_plotdf(x, 2016:2019)
    )) %>% mutate(matrix = "biota", indicator = str_remove(source, "_[A-Z].*")),
  do.call(
    rbind, 
    lapply(
      list("pcb_sed_clean_df", "dioxin_sed_clean_df"), 
      function(x) make_plotdf(x, 2016:2019)
    )) %>% mutate(matrix = "sediment", indicator = str_remove(source, "_[A-Z].*"))
)
```

<br>

#### 2.3.2 Spatial Distributions of Measurements {.tabset .tabset-fade .tabset-pills}

The maps below show data distribution spatially. Size and color correspond to number of distinct dates measurements were collected for a variable, for the given location within the specified time period (2016 through 2019); larger points with more yellow color indicate greater number of observations while smaller more red points indicate fewer observations. Opacity corresponds to number of years with greater transparency indicating fewer years of data. These faceted plots are created for multiple species; the species selected for visualization are those with the greatest number of measurements recorded across the three indicators.

```{r make plotting dataframe, echo = TRUE, warning = FALSE, message = FALSE}
make_map <- function(data, yrs){
  
  ## make data spatial using lat/lon columns
  df <- sf::st_as_sf(
    x = data, 
    agr = "identity",
    coords = c("longitude", "latitude"), 
    crs = 4326
  )
  ## contaminants datasets overlaying basemap
  map <- basemap + 
    geom_sf(
      data = df,
      aes(
        size = num_distinct_dates,
        color = num_distinct_dates), 
      show.legend = FALSE,
      alpha = 0.5, 
      shape = 19
    ) +
    scale_color_gradient2(
      low = "red3", 
      mid = "lightcoral",
      high = "lightgoldenrod",
      midpoint = 2.5
    ) +
    facet_wrap(c("indicator", "variable"), ncol = 5)

  return(map)
}
# for(i in unique(plotdf$indicator)){
#   plotdf %>% 
#     filter(matrix == "biota", indicator == i) %>% 
#     group_by(species) %>%
#     summarise(n = sum(num_distinct_dates)) %>% 
#     arrange(desc(n))
# }
```

<br>

##### Clupea Harengus

```{r sampling maps herring, results = "show", echo = TRUE, fig.width = 11, fig.height = 28.2}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Clupea harengus")))
```

##### Zoarces Viviparus

```{r sampling maps eelpout, results = "show", echo = TRUE, fig.width = 11, fig.height = 23.8}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Zoarces viviparus")))
```

##### Perca Fluviatilis

```{r sampling maps perch, results = "show", echo = TRUE, fig.width = 11, fig.height = 28.2}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Perca fluviatilis")))
```

##### Platichthys Flesus

```{r sampling maps flounder, results = "show", echo = TRUE, fig.width = 11, fig.height = 21.7}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Platichthys flesus")))
```

##### Mytilus Edulis

```{r sampling maps blue muscles, results = "show", echo = TRUE, fig.width = 11, fig.height = 13}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Mytilus edulis")))
```

##### Uria Aalge

```{r sampling maps common murre, results = "show", echo = TRUE, fig.width = 11, fig.height = 15.2}
make_map(filter(plotdf, matrix == "biota", str_detect(species, "Uria aalge")))
```

##### Sediments

```{r sampling maps sediments, results = "show", echo = TRUE, fig.width = 11, fig.height = 17.3}
make_map(filter(plotdf, matrix == "sediment"))
```

---

<br>

#### 2.3.3 Contaminants in Biota vs Sediments

Distributions of contaminant concentration values by indicator and matrix. Given the nearly exponential shape of the concentration distributions, plotting log values would makes some sense, though these are more difficult to interpret. Rescaling faceted axes of plots with actual values, to exclude outliers and focus in on 1st-3rd quartiles proved difficult (though rough  code to do this visualization was kept and commented out below).

```{r contaminants in biota vs sediment histograms, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 12}
## for boxplots, can (1) filter to remove beyond 90th quartile, or (2) log the data
## contaminants measurements represent an exponential dist. more closely than normal
## though logarithms are less intuitive to interpret here...
boxdf <- plotdf %>% mutate(log_mean_val = log(mean_val))

## mapping datasets for biota and sediments
make_boxplot <- function(dataset){
  
  boxplot <- ggplot(dataset) + 
    geom_boxplot(
      # aes(x = variable, y = mean_val, color = matrix),
      aes(x = variable, y = log_mean_val, color = matrix),
      outlier.alpha = 0.2, 
      outlier.shape = 20, 
      show.legend = FALSE
    ) + 
    labs(x = NULL, y = NULL) + 
    scale_color_manual(values = c("orchid", "tomato")) +
    facet_grid(cols = vars(matrix), rows = vars(variable), scales = "free", switch = "y") +
    coord_flip() +
    theme(
      axis.text.y = element_blank(),
      axis.ticks.y.left = element_blank(),
      panel.grid.minor.x = element_blank(), 
      panel.grid.major.x = element_blank(),
      strip.text.y = element_text(size = 8, angle = 180)
    )
  # boxplot <- boxplot + scale_y_continuous(limits = c(0, quantile(dataset$mean_val, 0.95)))
  
  return(boxplot)
}
plotpcb <- make_boxplot(boxdf %>% filter(indicator == "PCB"))
plotdioxin <- make_boxplot(boxdf %>% filter(indicator == "DIOXIN"))
gridExtra::grid.arrange(plotpcb, plotdioxin, ncol = 2)
```

<br>
