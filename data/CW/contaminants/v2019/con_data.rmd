
```{r preamble data, echo = FALSE, include = FALSE, error = FALSE}
source(here::here("R", "setup.R"))
```


### 2.1 Datasets with Sources
<br/>

#### 2.1.1 PCB Data

**PCB Data in Biota**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_PCBs.csv -->
<!-- w/ one year more of data...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_20Feb07_PCBs.csv -->
```{r PCB biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2017"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**PCB Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26983 -->
```{r PCB congeners table, echo = FALSE}
pcb_congeners <- t(data.frame(
  c("CB180", "2,2',3,4,4',5,5'-heptachlorobiphenyl"),
  c("SCB7", "sum of CBs.- Sum of"),
  c("CB28", "2,4,4'-trichlorobiphenyl"),
  c("CB52", "2,2',5,5'-tetrachlorobiphenyl"),
  c("CB101", "2,2',4,5,5'-pentachlorobiphenyl"),
  c("CB118", "2,3',4,4',5-pentachlorobiphenyl"),
  c("CB153", "2,2',4,4',5,5'-hexachlorobiphenyl"),
  c("CB138", "2,2',3,4,4',5'-hexachlorobiphenyl"),
  c("PCB", "polychlorinated biphenyls - Deprecated- Report as single PCBs"),
  c("CB194", "2,2',3,3',4,4',5,5'-octachlorobiphenyl"),
  c("CB105", "2,3,3',4,4'-pentachlorobiphenyl"),
  c("CB110", "2,3,3',4',6-pentachlorobiphenyl"),
  c("CB126", "3,3',4,4',5-pentachlorobiphenyl"),
  c("CB128", "2,2',3,3',4,4'-hexachlorobiphenyl"),
  c("CB149", "2,2',3,4',5',6-hexachlorobiphenyl"),
  c("CB151", "2,2',3,5,5',6-hexachlorobiphenyl"),
  c("CB156", "2,3,3',4,4',5-hexachlorobiphenyl"),
  c("CB157", "2,3,4,3',4',5'-hexachlorobiphenyl"),
  c("CB170", "2,2',3,3',4,4',5-heptachlorobiphenyl"),
  c("CB44", "2,2',3,5'-tetrachlorobiphenyl"),
  c("CB49", "2,2',4,5'-tetrachlorobiphenyl"),
  c("CB99", "2,2',4,4',5-pentachlorobiphenyl"),
  c("CB77", "3,3',4,4'-tetrachlorobiphenyl"),
  c("CB169", "3,3',4,4',5,5'-hexachlorobiphenyl"),
  c("CB31", "2,4',5-trichlorobiphenyl"),
  c("CB81", "3,4,4',5-tetrachlorobiphenyl"),
  c("SCB", "sum of CBs.- Specify in method data"),
  c("CB189", "2,3,3',4,4',5,5'-heptachlorobiphenyl"),
  c("CB114", "2,3,4,4',5-pentachlorobiphenyl"),
  c("CB123", "1,1'-Biphenyl, 2,3',4,4',5'-pentachloro-"),
  c("CB167", "2',3,4,4',5,5'-hexachlorobiphenyl"),
  c("CB187", "2,2',3,4',5,5',6-heptachlorobiphenyl"),
  c("CB66", "2,3',4,4'-tetrachlorobiphenyl"),
  c("CB60", "1,1'-Biphenyl, 2,3,4,4'-tetrachloro-"),
  c("CB141", "2,2',3,4,5,5'-hexachlorobiphenyl"),
  c("CB74", "2,4,4',5-tetrachlorobiphenyl"),
  c("CB206", "2,2',3,3',4,4',5,5',6-nonachlorobiphenyl"),
  c("CB33", "2',3,4-trichlorobiphenyl"),
  c("CB18", "2,2',5-trichlorobiphenyl"),
  c("CB183", "2,2',3,4,4',5',6-heptachlorobiphenyl"),
  c("CB47", "2,2',4,4'-tetrachlorobiphenyl"),
  c("CB209", "2,2',3,3',4,4',5,5',6,6'-decachlorobiphenyl"),
  c("CB51", "2,2',4,6'-Tetrachlorobiphenyl"),
  c("CB122", "1,1'-Biphenyl, 2,3,3',4',5'-pentachloro-"),
  c("CB138+163", "2,2',3,4,4',5'-hexachlorobiphenyl")))

colnames(pcb_congeners) <- c("Data Code", "")
rownames(pcb_congeners) <- NULL
htmlTable::htmlTable(pcb_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br/>

**PCBs in Sediment**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_PCBs/ContaminantsSediment_PCBs.csv -->
```{r PCB sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All8"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.2 PFOS Data

**PFOS in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_PFOS.csv -->
<!-- w/ one year more of data...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_20Feb07_PFOS.csv -->
```{r PFOS biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "2005-2017  (2005 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Organofluorines"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```
<br/>

#### 2.1.3 Dioxin Data

**Dioxins in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_Dioxins.csv -->
<!-- w/ one year more...BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_20Feb07_Dioxins.csv -->
```{r dioxin biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1998-2017  (1998 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**Dioxin Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26986 -->
```{r dioxin congeners table, echo = FALSE}
dioxin_congeners <- t(data.frame(
  c("CDD1N", "1 2 3 7 8-pentachlorodibenzo-p-dioxin"),  
  c("CDD4X", "1 2 3 4 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD6P", "1 2 3 4 6 7 8-heptachlorodibenzo-p-dioxin"), 
  c("CDD6X", "1 2 3 6 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD9X", "1 2 3 7 8 9-hexachlorodibenzo-p-dioxin"), 
  c("CDDO", "1 2 3 4 6 7 8 9-octachlorodibenzo-p-dioxin"),   
  c("CDF2N", "2 3 4 7 8-pentachlorodibenzofuran"),   
  c("CDF2T", "2 3 7 8-tetrachloro-dibenzofuran"),   
  c("CDF4X", "2 3 4 6 7 8-hexachlorodibenzofuran"),   
  c("CDF6P", "1 2 3 4 6 7 8-heptachlorodibenzofuran"),   
  c("CDF6X", "1 2 3 6 7 8-hexachlorodibenzofuran"),   
  c("CDF9P", "1 2 3 4 7 8 9-heptachlorodibenzofuran"),   
  c("CDF9X", "1 2 3 7 8 9-hexachlorodibenzofuran"),   
  c("CDFDN", "1 2 3 7 8/1 2 3 4 8-pentachloro-dibenzofuran"),   
  c("CDFO", "octachloro-dibenzofuran (group)"),    
  c("TCDD", "2 3 7 8-tetrachlorodibenzo-p-dioxin")))   

colnames(dioxin_congeners) <- c("Data Code", "")
rownames(dioxin_congeners) <- NULL
htmlTable::htmlTable(dioxin_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br>

**Dioxins in Sediment**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_Dioxins/ContaminantsSediment_Dioxins.csv -->
```{r dioxin sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
---

<br>

### 2.2 Centralization & Normalization
<!-- note: below incorporates from BHI1.0, along with preliminary contaminants_prep.Rmd sections, the following: -->
<!-- raw_pcb_data_prep.R, raw_dioxin_data_prep.R, and raw_pfos_data_prep.R -->
<!-- station_attribute_prep.R, congener_description.R -->

```{r read raw datasets, message = FALSE, warning = FALSE, echo = TRUE, results = "hide"}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "CW", "CON")

lapply(
  list(
    c("ContaminantsBiota_20Feb07_PCBs", "pcb_rawdata_bio"),
    c("ContaminantsSediment_PCBs", "pcb_rawdata_sed"),
    c("ContaminantsBiota_20Feb07_PFOS", "pfos_rawdata_bio"),
    c("ContaminantsBiota_20Feb07_Dioxins", "dioxin_rawdata_bio"),
    c("ContaminantsSediment_Dioxins", "dioxin_rawdata_sed")
  ),
  function(x){
    read_csv(
      file.path(dir_rawdata, x[1], paste(x[1], "csv", sep = ".")),
      ## where not read in correctly, column types must be specified ...
      col_types = cols(
        .default = col_character(),
        MYEAR = col_number(), 
        Latitude = col_number(), 
        Longitude = col_number(), 
        NOINP = col_number(),
        Value = col_number(), 
        DETLI = col_number(), 
        LMQNT = col_number(), 
        UNCRT = col_number(),
        tblAnalysisID = col_number(), 
        tblParamID = col_number(), 
        tblBioID = col_number(), 
        tblSampleID = col_number()
      )
    ) %>% assign(x = x[2], envir = .GlobalEnv)
  }
)
```


##### Check number of years with samples by Country {.tabset .tabset-fade .tabset-pills}

###### PCBs

```{r check number of years sample by country in pcb data,  results  = "show"}
do.call(rbind, lapply(as.list(unique(pcb_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  )
})) %>% DT::datatable()
## check number of dates and years sample by country, PCBs data from ICES
## Denmark doesn't have herring data...
```

###### PFOS 

```{r check number of dates and years sample by country in pfos data,  results  = "show"}
do.call(rbind, lapply(as.list(unique(pfos_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  )
})) %>% DT::datatable()
```

###### Dioxins

```{r check number of dates and years sample by country in dioxin data,  results  = "show"}
do.call(rbind, lapply(as.list(unique(dioxin_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  )
})) %>% DT::datatable()
```

---

#### 2.2.1 Rename Fields/Variables

```{r rename fields for data, echo = TRUE, results = "hide"}
## ICES column name descriptors:
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20biota.pdf
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20sediment.pdf
rename_vars <- function(dataset){
  
  df_vars_renamed <- dataset %>% 
    
    ## create date, month, year, day columns
    dplyr::mutate(date = as.Date(DATE, "%d/%m/%Y")) %>% 
    
    dplyr::mutate(
      day = lubridate::day(date),
      month = lubridate::month(date), 
      year = lubridate::year(date)) %>% 
    
    ## change column names
    dplyr::rename(
      country = Country, report_institute = RLABO,
      station = STATN, 
      monit_year = MYEAR, date_ices = DATE,
      
      latitude = Latitude, longitude = Longitude,
      
      param_group = PARGROUP, variable = PARAM, 
      value = Value, unit = MUNIT,
      
      species = Species, sex_specimen = SEXCO, num_indiv_subsample = NOINP,
      test_organism = `Test Organism`,
      matrix_analyzed = MATRX, not_used_in_datatype = NODIS,
      
      monit_program = MPROG, monit_purpose = PURPM,
      
      basis_determination = BASIS, qflag = QFLAG,
      vflag = VFLAG, detect_lim = DETLI,
      quant_lim = LMQNT, uncert_val = UNCRT, method_uncert = METCU,
      
      analyt_lab = ALABO, ref_source = REFSK, 
      method_storage = METST, method_pretreat = METPT, 
      method_pur_sep = METPS, method_chem_fix = METFP,
      method_chem_extract = METCX, method_analysis = METOA, 
      formula_calc = FORML,
      
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sampler_type = SMTYP, factor_compli_interp = FINFL,
      
      analyt_method_ref = tblAnalysisID, 
      measurement_ref = tblParamID,
      samp_ref = tblSampleID
    ) %>% 
    
    ## improve clarity of 'basis_determination' and 'matrix_analyzed' column content
    mutate(
      basis_determination = ifelse(
        basis_determination == "L", "lipid weight",
        ifelse(
          basis_determination == "W", "wet weight",
          ifelse(
            basis_determination == "D", "dry weight", NA
          )
        )
      ),
      matrix_analyzed = ifelse(
        matrix_analyzed == "LI", "liver",
        ifelse(
          matrix_analyzed == "MU", "muscle",
          ifelse(
            matrix_analyzed == "WO", "wholeorganism", NA
          )
        )
      )
    )
  
  return(df_vars_renamed)
}

## same names and structures so can apply function to all datasets
lapply(
  list("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(sub_samp_ref = tblBioID)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
lapply(
  list("pcb_rawdata_sed", "dioxin_rawdata_sed"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(press_depth = DEPHU, depth_low = DEPHL)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
rm("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio", "pcb_rawdata_sed", "dioxin_rawdata_sed")
```

---

#### 2.2.2 Standardize Units


The main objective of the code below is to clean the contaminants datases set so they contain only values based on wet weight for biota or dry weight for sediment-matrix measurements, in standardized units of ug/kg.
This includes the following pre-processing steps:

- Remove flagged and deprecated data entries  
- Separate 'b-bio' data from the other param group data ('oc-cb', 'oc-dx', or 'o-fl' for PCB, Dioxin, PFOS resp.) for use in lipid basis to wet weight conversion  
- Take averages where there are duplicate data samples, based on the sub_samp_ref value groupings for biota or samp_ref value groupings for sediment-matrix measurements  
- Convert all congener concentration data to ug/kg and to wet weight for biota  
- If data were presented in lipid weight, they were converted to wet weight by: $(\mbox{EXLIP%}/100)*(\mbox{CB conc. lipid weight})$  


The datasets each contain two main categories (param_groups) one of which is BBIO. BBIO consists of variables with information about the sample like dry/lipid/wet weight percentage, age, weight and length. The second category contains the congeners concentration information. In stages, these are each manipulated and later rejoined by the sample (samp_ref or sub_samp_ref) ID numbers.

<br>

<!-- the following code chunks are modified from raw_data_prep.r scripts in bhi-1.0-archive/baltic2015/prep/CW/contaminants -->

```{r standardize units in biota datasets, echo = TRUE}

standardize_con_data <- function(data_renamed, matrix_biota = TRUE, contam_param, rm_vars = NULL){
  
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  
  ## what are the specific parameters?
  ## unique parameter groups and associated variables:
  chk_params <- data_renamed %>% 
    select(param_group, variable) %>% 
    distinct() %>% 
    arrange(param_group, variable)
 
  ## filter and/or remove unneeded variables from data ----
  message("STEP 1: filter and/or unselect unneeded variables and congeners from dataset\n")
  df <- data_renamed %>% 
    ## remove 'suspect' and other non-'acceptable': https://vocab.ices.dk/?ref=58
    filter(!vflag %in% c("S", "C")) %>% 
    ## remove certain variables-- summarized data or depreciated codes
    filter(!variable %in% rm_vars)
  
  if(contam_param != "FL"){
    ## remove samples for liver tissue, keep muscle, and whole organism for length x weight
    df <- filter(df, matrix_analyzed != "liver" | is.na(matrix_analyzed))
  }
  ## for PFOS (contaminant pargroup 'O-FL'), keep liver measurements-- 
  ## all compounds except parameter 'PFOS' measured only in the liver
  ## DRYWT% and EXLIP% have been measured for both muscle and liver
  
  
  ## sediment versus biota datasets, different sample/id variables
  sampvars <- c("sub_samp_id", "samp_ref", "sub_samp_ref")
  if(!matrix_biota){
    sampvars <- setdiff(sampvars, "sub_samp_ref")
  }
  ## check alignment of all measurements with sub_samp_ref for biota, samp_ref for sediment
  ## (most unique besides measurement_ref)
  ## there are more unique measurement_ref but these are for different vars w/in sub_samp_id
  chk_ids <- c()
  for(i in c(sampvars, "measurement_ref")){
    chk_ids <- c(chk_ids, sprintf("%s: %s", i, length(unique(df[[i]]))))
  }
  if(nrow(df %>% filter(is.na(sampvars[length(sampvars)]))) != 0){
    warning(sprintf("there are observations without %s in the dataset", sampvars[length(sampvars)]))
  }
  message(sprintf("NOTE will align by %s when grouping to identify duplicates\n", sampvars[length(sampvars)]))
  
  
  ## BBIO DATA
  
  ## separate out bbio data for lipid to wet-weight conversion ----
  ## B-BIO variable code: http://vocab.ices.dk/?CodeID=51634
  ## b-bio data -- length, weight, fat and lipid content
  ## lipid content, etc. needed to convert lipid basis samples into the wet weight are in the B-BIO column
  message("STEP 2: separate out bbio data and wrangle for use in lipid to wet-weight conversion...\n")
  df_bbio <- df  %>% 
    filter(param_group == "B-BIO") %>%
    select(
      station, latitude, longitude, date, year, 
      species, matrix_analyzed, basis_determination, qflag,
      variable, unit, value,
      !!!syms(sampvars)
    )
  
  ## if there are cm, convert to mm
  df_bbio <- df_bbio %>% 
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "mm"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = ifelse(is.na(ConvertUnit), value, value*ConvertFactor),
      unit = ifelse(is.na(ConvertUnit), unit, "mm")
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## confirm that units of bbio, are one-to-one
  chk_bbio_units <- df_bbio %>% 
    select(variable, unit) %>% 
    distinct()
  
  ## if dealing with sediment, need to keep units for now...
  if(matrix_biota){df_bbio <- select(df_bbio, -unit)}

  chk_num_bbio_dup <- nrow(df_bbio) - nrow(distinct(df_bbio %>% select(-value)))
  
  ## BBIO DUPLICATES
  ## identify, explore, handle bbio duplicates ----
  ## group to identify duplicates; for a given sub_samp_ref only some variables may have duplicates
  grpvars <- c(
    "station", "year", "species", "basis_determination", "matrix_analyzed", "qflag", 
    sampvars, "date", "variable", "longitude", "latitude"
  )
  chk <- c()
  for(i in 1:6){
    bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(c(grpvars[i], grpvars[7:length(grpvars)]))) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
    chk <- c(chk, nrow(filter(bbio_duplicates, n > 1)))
  }
  if(var(chk) != 0){
    message(sprintf(
      "NOTE bbio duplicates dataframe dims vary with grpvars: %s",
      paste(grpvars[which(chk != chk[which.max(tabulate(match(chk, chk)))])], collapse = ", ")
    ))
  }
  
  ## join duplicate table by grouped vars to locate within full bbio dataset
  bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(grpvars)) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
  df_bbio <- left_join(df_bbio, bbio_duplicates, by = grpvars)
  
  ## take averages for variable/sample duplicates
  df_bbio <- bind_rows(
    ## averages of duplicates
    df_bbio %>% 
      filter(n > 1) %>% 
      group_by(!!!syms(grpvars)) %>% 
      summarize(value = mean(value)) %>% 
      ungroup(),
    ## rows of bbio data with no duplicates
    df_bbio %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## check for unique variables and matrix_analyzed, per species
  chk_bbio_vars <- NULL
  if(matrix_biota){
    chk_bbio_vars <- do.call(
      rbind, 
      lapply(
        as.list(unique(df_bbio$species)), 
        function(x){
          cbind(
            df_bbio %>% 
              filter(species == x) %>%
              select(matrix_analyzed, basis_determination, variable) %>% 
              distinct() %>% 
              arrange(variable, matrix_analyzed, basis_determination),
            species = x
          )
        }
      )
    )
  }

  
  ## WIDE BBIO DATA
  ## bbio data wide format ----
  
  ## remove basis_determination because some bio vars are recorded at whole organism scale, others for liver or muscle,
  ## no concentration variables measured for whole organism matrix, so don't need for joining...
  ## no problem pivoting wider also indicates uniquely identified by remaining grouping variables
  # unique(filter(df, param_group != "B-BIO")$matrix_analyzed)
  
  if(contam_param == "FL"){
    ## for PFOS we have liver and muscle measurements
    ## need to deal with matrix_analyzed to get 'muscle equivalent' from conc. measurements in liver
    df_bbio_wide <- df_bbio %>% 
      mutate(variable = paste(matrix_analyzed, variable, sep = "_")) %>% 
      select(-matrix_analyzed, -basis_determination)
  } else {
    df_bbio_wide <- df_bbio %>% 
      select(-basis_determination)
  }
  df_bbio_wide <- df_bbio_wide %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  

  ## which columns are needed to uniquely identify and later rejoin with congener conc. data
  ## i.e. at this stage, which subset of grpvars gives groupings such that all n are one?
  # for(i in grpvars){print(paste(i, length(unique(df_bbio_wide[[i]]))))}
  chkgrpvars <- intersect(grpvars, names(df_bbio_wide))
  chk <- chkgrpvars
  for(i in 1:length(chkgrpvars)){
    bbio_wide_duplicates <- df_bbio_wide %>% 
      group_by(!!!syms(setdiff(chk, chkgrpvars[i]))) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    if(nrow(bbio_wide_duplicates) == 0){
      chk <- setdiff(chk, chkgrpvars[i])
    }
  }
  message(sprintf(
    "NOTE minimum group ID variables for later rejoining uniquely with congener data:\n%s\n", 
    paste(chk, collapse = ", ")
  ))
  chk_bbio_wide_ids <- chk
  ## sub_samp_id and samp_ref together are as unique as sub_samp_ref
  # nrow(select(df_bbio_wide, sub_samp_ref) %>% distinct())
  # nrow(select(df_bbio_wide, sub_samp_id, samp_ref) %>% distinct())
  
  
  ## CONGENER CONCENTRATIONS DATA
  ## check congener concentration data, units and duplicates ----
  
  if(!matrix_biota){
    ## WHAT ARE THE UNITS OF DEPTH VARIABLES?????????
    ## only keep sediment measurements in top 2cm, 
    ## or maximum 5cm if filtering to within 2cm of surface yeilds too few data pts...
    df <- df %>% filter(depth_low < 5)
  }
  
  df_conc <- df %>%
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      station, latitude, longitude, date, year,
      species, matrix_analyzed, basis_determination,
      variable, unit, value, detect_lim, quant_lim, qflag,
      !!!syms(sampvars)
    )
  
  ## convert congener concentration units all to ug/kg
  message("STEP 3: convert congener concentrations units to ug/kg")
  df_conc <- df_conc %>%
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "ug/kg"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = value*ConvertFactor, 
      detect_lim = detect_lim*ConvertFactor,
      unit = "ug/kg"
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## check whether variables vs units relationship is one-to-one
  chk_conc_units <- df_conc %>% 
    select(variable, unit) %>% 
    distinct() %>%
    arrange(variable)
  
  df_conc <- select(df_conc, -unit)
  
  
  ## take averages for congener conc. variable x sample duplicates ----
  
  ## identify duplicates
  ## group to identify duplicates, 
  ## for a given sub_samp_ref only some vars/congeners may have duplicates
  message("STEP 4: averaging, where multiple congener concentrations observations per sub sample\n")
  chk_num_conc_dup <- nrow(df_conc) - nrow(distinct(df_conc %>% select(-value, -detect_lim, -quant_lim)))

  conc_duplicates <- df_conc %>% 
    group_by(!!!syms(grpvars)) %>%
    summarise(n = n()) %>% 
    ## no cases where duplicates with-and-without qflags, else would keep cases unflagged observations...
    # group_by(!!!syms(setdiff(grpvars, "qflag"))) %>%
    # mutate(allflagged = !any(is.na(qflag))) %>%
    # filter(n > 1, !allflagged) %>% ...
    filter(n > 1) %>% 
    ungroup()
  
  ## join duplicates tables by grouped vars to locate them in original dataset
  df_conc <- left_join(df_conc, conc_duplicates, by = grpvars)
  chk_conc_dup <- filter(df_conc, !is.na(n))
  
  df_conc <- bind_rows(
    ## averages of duplicates
    df_conc %>% 
      filter(n > 1) %>%
      group_by(!!!syms(grpvars)) %>% 
      summarize(
        value = mean(value), 
        detect_lim = mean(detect_lim, na.rm = TRUE), 
        quant_lim =  mean(detect_lim, na.rm = TRUE)
      ) %>% 
      ungroup(),
    ## rows of conc data with no duplicates
    df_conc %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## remaining duplicates for biota datasets are due to dual wet/lipid weight records;
  ## of these, keep wet weight records, when has a value
  if(matrix_biota){
    chk <- df_conc %>%
      group_by(!!!syms(setdiff(grpvars, c("basis_determination", "matrix_analyzed")))) %>%
      mutate(n = n(), ww_val = any(basis_determination == "wet weight" & !is.na(value))) %>%
      filter(n > 1) %>% 
      mutate(
        rm_duplicate = 
          (ww_val & basis_determination == "lipid weight")|
          (!ww_val & basis_determination == "wet weight")
      ) %>% 
      ungroup()
    df_conc <- df_conc %>%
      left_join(chk, by = intersect(names(df_conc), names(chk))) %>% 
      mutate(rm_duplicate = ifelse(is.na(rm_duplicate), TRUE, rm_duplicate)) %>% 
      filter(rm_duplicate) %>% 
      select(-n, -ww_val, -rm_duplicate)
  }
  
  ## do not want to spread the data because the qflag, detli etc is unique to each congener
  ## but, spread to check if one row for every unique sub_samp_ref for biota, samp_ref for sediment
  df_conc_wide <- df_conc %>%
    select(-detect_lim, -quant_lim) %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  if(length(unique(df_conc[[sampvars[length(sampvars)]]])) != nrow(distinct(df_conc_wide))){
    message(
      "NOTE conc. subsamples not uniquely identified even after averaging; 
            multiple obs per ID, probably due to qflags\n"
    )
  }
  
  ## for biota convert lipid weight measurements to wet weight ----
  ## UNITS HAVE ALL BEEN CONVERTED TO MICROGRAMS PER KILOGRAM
  ## use the df_bbio_wide datatable to convert values in df_conc table
  df_final <- left_join(df_conc, df_bbio_wide, by = intersect(grpvars, names(df_bbio_wide))) 
  
  if(matrix_biota){
    
    message("STEP 5: converting all congener concentrations in biota to wet weight, muscle equivalence")
    
    ## for PFOS data convert liver values into those for muscle 
    ## using conversion values from Faxneld et al 2014
    ## https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf)
    ## follow methods in the HELCOM core indicator p.9
    ## http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf
    ## use the mean liver:muscle ratio for all species (17.9), see Table 8 in Faxneld et al 2014
    if(contam_param == "FL"){
      df_final <- df_final %>% 
        mutate_at(
          vars(c("value", "detect_lim", "quant_lim")), 
          list(pfos_muscle_equiv = ~ case_when(
            variable == "PFOS" & matrix_analyzed == "liver" ~ ./17.9,
            variable == "PFOS" & matrix_analyzed == "muscle" ~ .
          ))
        ) %>% 
        mutate_at(
        vars(c("value_pfos_muscle_equiv", "detect_lim_pfos_muscle_equiv", "quant_lim_pfos_muscle_equiv")), 
        ## will probably all be in wet weight already, but just in case...
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`muscle_EXLIP%`/100), # IS THIS HOW EXLIP% VARIABLE WORKS????
          basis_determination == "dry weight" ~ .*(100/`muscle_DRYWT%`), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "wet weight" ~ .
        ))
      )
    } else {
      df_final <- df_final %>% 
      ## if value is not wet weight convert, otherwise keep value
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`EXLIP%`/100), # IS THIS HOW EXLIP% VARIABLE WORKS????
          basis_determination == "dry weight" ~ .*(100/`DRYWT%`), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "wet weight" ~ .
        ))
      )
    }
    
  }
  ## for sediment data, still need to convert to dry weights
  if(!matrix_biota){
    ## what to do with the dry weights....
    message("STEP 5: converting all congener concentrations in sediment to dry weight")
    df_final <- df_final %>% 
      ## if value is not dry weight convert, otherwise keep value
      ## even though some have units of ug/kg treat the DRYWT% as percentage...
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(dry_wgt = ~ case_when(
          basis_determination == "wet weight" ~ .*(`DRYWT%`/100), # IS THIS HOW DRYWT% VARIABLE WORKS????
          basis_determination == "dry weight" ~ .
        ))
      )
  }
  
  ## rejoin with meta information ----
  ## rejoin with info on country and monitoring program info, qflaugs, etc
  message("FINAL STEP: rejoining with meta information\n")
  
  df_final <- df %>% 
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      country, monit_program, monit_purpose, 
      report_institute, 
      monit_year, date_ices, day, month,
      num_indiv_subsample, bulk_id,  
      !!!syms(grpvars)
    ) %>% 
    distinct() %>% 
    right_join(df_final, by = grpvars) %>% 
    mutate(qflagged = ifelse(is.na(qflag), FALSE, TRUE))
  
  ## return wrangled data and checks ----
  
  ## list of checks as part of result
  chks <- list(
    chk_params, chk_ids, 
    chk_bbio_units, chk_num_bbio_dup, chk_bbio_vars,
    chk_conc_units, chk_num_conc_dup, chk_conc_dup
  )
  
  df_final <- filter(df_final, !is.na(value))
    
  if(!all(mutate(group_by(df_final, !!!syms(grpvars)), n = n())$n == 1)){
    warning("NOTE rows of final dataframe are not uniquely identified by grouping variables")
  }
  
  return(list(
    df_final = df_final, 
    groupingvars = grpvars,
    df_conc_wide = df_conc_wide, 
    df_bbio_wide = df_bbio_wide, 
    checks = chks
  ))
}
```

<br>

#### 2.2.3 Wrangle all and Save

```{r save cleaned datasets, echo = TRUE, message = FALSE, warning = FALSE, results = "hide"}
dir_interm <- here::here("data", "CW", "contaminants", version_year, "intermediate")

lapply(
  list(
    ## for param definitions see //vocab.ices.dk/?ref=37
    
    ## PCB datasets
    ## remove PCB, SCB, SCB7 - these are summarized data or depreciated codes
    ## OC-CB variable codes: vocab.ices.dk/?CodeID=26983
    list("pcb_bio", TRUE, "OC-CB", c("PCB", "SCB", "SCB7")),
    list("pcb_sed", FALSE, "OC-CB", c("PCB", "SCB")),
    
    ## Dioxin datasets
    list("dioxin_bio", TRUE, "OC-DX", NULL),
    list("dioxin_sed", FALSE, "OC-DX", NULL),

    ## PFOS dataset
    list("pfos_bio", TRUE, "O-FL", NULL)
  ),
  
  function(dat){
    dat_final <- standardize_con_data(get(dat[[1]]), dat[[2]], dat[[3]], dat[[4]]) 
    assign(
      x = paste(dat[[1]], "cleaned", sep = "_"), 
      value = dat_final, 
      envir = .GlobalEnv
    )
    assign(
      x = paste(dat[[1]], "clean_df", sep = "_"), 
      value = dat_final[["df_final"]], 
      envir = .GlobalEnv
    )
    write_csv(
      dat_final[["df_final"]], 
      file.path(dir_interm, paste(dat[[1]], "cleaned.csv", sep = "_"))
    )
  }
)
```

---

### 2.3 Initial Data Exploration

#### 2.3.2 Spatial Distributions of Measurements

```{r sampling maps, results = "show", message = FALSE, warning = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 20}
## to start running code from here, will need to load in cleaned  datasets...
# dir_interm <- here::here("data/CW/contaminants/v2019/intermediate")
# funtemp <- function(dat){
#   dat_final <- read_csv(file.path(dir_interm, dat))
#   assign(
#     x = str_replace(dat, "cleaned.csv", "clean_df"),
#     value = dat_final,
#     envir = .GlobalEnv
#   )
# }
# lapply(list.files(dir_interm), funtemp)


## basemap with baltic countries borders and BHI regions with ID numbers
bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile"), 
    layer = "BHI_shapefile",
    quiet = TRUE
  )) %>% sf::st_as_sf()

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

## mapping datasets for biota and sediments
make_mapdf <- function(x, yr){
  cbind(
    get(x) %>%
      filter(year %in% yr, longitude > 9) %>%
      group_by(year, latitude, longitude, variable) %>%
      summarize(
        n_obs = n(),
        mean_val = ifelse(
          str_detect(x, "sed"), 
          mean(value_dry_wgt, na.rm = TRUE),
          ifelse(
            str_detect(x, "pfos"),
            mean(value_pfos_muscle_equiv_wet_wgt, na.rm = TRUE), 
            mean(value_wet_wgt, na.rm = TRUE)
          )
        )
      ) %>%
      filter(!is.na(mean_val)) %>% 
      group_by(latitude, longitude) %>% 
      mutate(
        num_congeners = n_distinct(variable),
        mean_allcongeners_selectedyrs = mean(mean_val),
        sd_allcongeners_selectedyrs = ifelse(is.na(sd(mean_val)), 1, sd(mean_val) + 1)
      ) %>%
      tidyr::pivot_longer(
        cols = c(sd_allcongeners_selectedyrs, mean_allcongeners_selectedyrs), 
        names_to = "metric", values_to = "value"
      ) %>%
      ungroup() %>% 
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326, agr = "identity"),
    source = str_remove(x, "_clean_df"))
}
mapdf_biota <- do.call(
  rbind, lapply(
    list("pcb_bio_clean_df", "pfos_bio_clean_df", "dioxin_bio_clean_df"), 
    function(x) make_mapdf(x, 2016:2019)
  )
)
mapdf_sediment <- do.call(
  rbind, 
  lapply(
    list("pcb_sed_clean_df", "dioxin_sed_clean_df"), 
    function(x) make_mapdf(x, yr = 2014:2019)
  )
)

## contaminants datasets overlaying basemap
mapbio <- basemap + 
  geom_sf(
    aes(size = value, color = num_congeners), 
    alpha = 0.3, 
    shape = 19, 
    data = mapdf_biota
  ) +
  scale_color_distiller(palette = "OrRd") +
  facet_grid(rows = vars(source), cols = vars(metric)) +
  guides(size = FALSE) +
  theme(legend.position = c(0.1, 0.9), legend.box.background = element_rect(colour = "grey"))

mapsed <- basemap + 
  geom_sf(
    aes(size = value, color = num_congeners),
    alpha = 0.3, 
    shape = 19, 
    data = mapdf_sediment,
    show.legend = FALSE
  ) +
  scale_color_distiller(palette = "OrRd") +
  facet_grid(rows = vars(source), cols = vars(metric))

gridExtra::grid.arrange(mapbio, mapsed, ncol = 1, heights = c(1.5, 1))
```

<br>

#### 2.3.3 Contaminants in Biota vs Sediments

**Contaminants: PCB and Dioxin by Matrix per Congener**

```{r contaminants in biota vs sediment histograms, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 13}
sf::st_geometry(mapdf_sediment) <- NULL
sf::st_geometry(mapdf_biota) <- NULL

boxdf <- bind_rows(
  mutate(
    mapdf_sediment, 
    matrix = "sediment",
    source = str_remove(source, "_[a-z].*")
  ),
  mutate(
    mapdf_biota, 
    matrix = "biota",
    source = str_remove(source, "_[a-z].*")
  )
)
boxdf <- boxdf %>% 
  filter(metric == "mean_allcongeners_selectedyrs", source != "pfos") %>% 
  group_by(source) %>% 
  mutate(quant9 = quantile(mean_val, 0.9)) %>% 
  ungroup() %>% 
  filter(mean_val < quant9)

make_boxplot <- function(dataset){
  boxplot <- ggplot(dataset, aes(x = matrix, y = mean_val, color = matrix)) + 
    geom_boxplot(outlier.alpha = 0.2, outlier.shape = 20) + 
    labs(x = NULL, y = NULL) + 
    scale_color_manual(values = c("orchid", "tomato")) +
    facet_grid(rows = vars(variable), switch = "y") +
    coord_flip() +
    theme(
      legend.position = c(0.85, 0.95), 
      axis.text.y = element_blank(),
      axis.ticks.y.left = element_blank(),
      panel.grid.minor.x = element_blank(), 
      panel.grid.major.x = element_blank(),
      strip.text.y = element_text(size = 8, angle = 180)
    )
  return(boxplot)
}
plotpcb <- make_boxplot(boxdf %>% filter(source == "pcb")) + theme(legend.position = "none")
plotdioxin <- make_boxplot(boxdf %>% filter(source == "dioxin"))
gridExtra::grid.arrange(plotpcb, plotdioxin, ncol = 2)
```

<br>
