
```{r preamble data, echo = FALSE, include = FALSE, error = FALSE}
source(here::here("R", "setup.R"))
```


### 2.1 Datasets with Sources
<br/>

#### 2.1.1 PCB Data

**PCB Data in Biota**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_PCBs.csv -->
```{r PCB biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2017"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**PCB Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26983 -->
```{r PCB congeners table, echo = FALSE}
pcb_congeners <- t(data.frame(
  c("CB180", "2,2',3,4,4',5,5'-heptachlorobiphenyl"),
  c("SCB7", "sum of CBs.- Sum of"),
  c("CB28", "2,4,4'-trichlorobiphenyl"),
  c("CB52", "2,2',5,5'-tetrachlorobiphenyl"),
  c("CB101", "2,2',4,5,5'-pentachlorobiphenyl"),
  c("CB118", "2,3',4,4',5-pentachlorobiphenyl"),
  c("CB153", "2,2',4,4',5,5'-hexachlorobiphenyl"),
  c("CB138", "2,2',3,4,4',5'-hexachlorobiphenyl"),
  c("PCB", "polychlorinated biphenyls - Deprecated- Report as single PCBs"),
  c("CB194", "2,2',3,3',4,4',5,5'-octachlorobiphenyl"),
  c("CB105", "2,3,3',4,4'-pentachlorobiphenyl"),
  c("CB110", "2,3,3',4',6-pentachlorobiphenyl"),
  c("CB126", "3,3',4,4',5-pentachlorobiphenyl"),
  c("CB128", "2,2',3,3',4,4'-hexachlorobiphenyl"),
  c("CB149", "2,2',3,4',5',6-hexachlorobiphenyl"),
  c("CB151", "2,2',3,5,5',6-hexachlorobiphenyl"),
  c("CB156", "2,3,3',4,4',5-hexachlorobiphenyl"),
  c("CB157", "2,3,4,3',4',5'-hexachlorobiphenyl"),
  c("CB170", "2,2',3,3',4,4',5-heptachlorobiphenyl"),
  c("CB44", "2,2',3,5'-tetrachlorobiphenyl"),
  c("CB49", "2,2',4,5'-tetrachlorobiphenyl"),
  c("CB99", "2,2',4,4',5-pentachlorobiphenyl"),
  c("CB77", "3,3',4,4'-tetrachlorobiphenyl"),
  c("CB169", "3,3',4,4',5,5'-hexachlorobiphenyl"),
  c("CB31", "2,4',5-trichlorobiphenyl"),
  c("CB81", "3,4,4',5-tetrachlorobiphenyl"),
  c("SCB", "sum of CBs.- Specify in method data"),
  c("CB189", "2,3,3',4,4',5,5'-heptachlorobiphenyl"),
  c("CB114", "2,3,4,4',5-pentachlorobiphenyl"),
  c("CB123", "1,1'-Biphenyl, 2,3',4,4',5'-pentachloro-"),
  c("CB167", "2',3,4,4',5,5'-hexachlorobiphenyl"),
  c("CB187", "2,2',3,4',5,5',6-heptachlorobiphenyl"),
  c("CB66", "2,3',4,4'-tetrachlorobiphenyl"),
  c("CB60", "1,1'-Biphenyl, 2,3,4,4'-tetrachloro-"),
  c("CB141", "2,2',3,4,5,5'-hexachlorobiphenyl"),
  c("CB74", "2,4,4',5-tetrachlorobiphenyl"),
  c("CB206", "2,2',3,3',4,4',5,5',6-nonachlorobiphenyl"),
  c("CB33", "2',3,4-trichlorobiphenyl"),
  c("CB18", "2,2',5-trichlorobiphenyl"),
  c("CB183", "2,2',3,4,4',5',6-heptachlorobiphenyl"),
  c("CB47", "2,2',4,4'-tetrachlorobiphenyl"),
  c("CB209", "2,2',3,3',4,4',5,5',6,6'-decachlorobiphenyl"),
  c("CB51", "2,2',4,6'-Tetrachlorobiphenyl"),
  c("CB122", "1,1'-Biphenyl, 2,3,3',4',5'-pentachloro-"),
  c("CB138+163", "2,2',3,4,4',5'-hexachlorobiphenyl")))

colnames(pcb_congeners) <- c("Data Code", "")
rownames(pcb_congeners) <- NULL
htmlTable::htmlTable(pcb_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br/>

**PCBs in Sediment**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_PCBs/ContaminantsSediment_PCBs.csv -->
```{r PCB sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All8"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.2 PFOS Data

**PFOS in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_PFOS.csv -->

```{r PFOS biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "2005-2017  (2005 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Organofluorines"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```
<br/>

#### 2.1.3 Dioxin Data

**Dioxins in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_Dioxins.csv -->
```{r dioxin biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1998-2017  (1998 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**Dioxin Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26986 -->
```{r dioxin congeners table, echo = FALSE}
dioxin_congeners <- t(data.frame(
  c("CDD1N", "1 2 3 7 8-pentachlorodibenzo-p-dioxin"),  
  c("CDD4X", "1 2 3 4 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD6P", "1 2 3 4 6 7 8-heptachlorodibenzo-p-dioxin"), 
  c("CDD6X", "1 2 3 6 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD9X", "1 2 3 7 8 9-hexachlorodibenzo-p-dioxin"), 
  c("CDDO", "1 2 3 4 6 7 8 9-octachlorodibenzo-p-dioxin"),   
  c("CDF2N", "2 3 4 7 8-pentachlorodibenzofuran"),   
  c("CDF2T", "2 3 7 8-tetrachloro-dibenzofuran"),   
  c("CDF4X", "2 3 4 6 7 8-hexachlorodibenzofuran"),   
  c("CDF6P", "1 2 3 4 6 7 8-heptachlorodibenzofuran"),   
  c("CDF6X", "1 2 3 6 7 8-hexachlorodibenzofuran"),   
  c("CDF9P", "1 2 3 4 7 8 9-heptachlorodibenzofuran"),   
  c("CDF9X", "1 2 3 7 8 9-hexachlorodibenzofuran"),   
  c("CDFDN", "1 2 3 7 8/1 2 3 4 8-pentachloro-dibenzofuran"),   
  c("CDFO", "octachloro-dibenzofuran (group)"),    
  c("TCDD", "2 3 7 8-tetrachlorodibenzo-p-dioxin")))   

colnames(dioxin_congeners) <- c("Data Code", "")
rownames(dioxin_congeners) <- NULL
htmlTable::htmlTable(dioxin_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br>

**Dioxins in Sediment**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_Dioxins/ContaminantsSediment_Dioxins.csv -->
```{r dioxin sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "All"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(ICES) All ICES Areas")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 13 February 2020 by Ellie Campbell")
```
<br/>

#### 2.1.4 ICES Station Dictionary and Impacts

**ICES Station Dictionary**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_dictionary.csv -->
```{r ices station dictionary, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("", "")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES](SOURCE...) <br/> Downloaded [DATE...] February 2020 by Ellie Campbell")
```
<br/>

**ICES Station Impacts Codes**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_impacts.csv -->
```{r ices station impact codes, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Data theme:", "Environmental"),
  c("Keyword:", "Station"),
  c("Code Types:", "MSTAT")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES vocabulary](https://vocab.ices.dk/?ref=177) <br/> Downloaded 7 February 2020 by Ellie Campbell")
```

---

<br/>

### 2.2 Centralization & Normalization
<!-- note: below incorporates from BHI1.0, along with preliminary contaminants_prep.Rmd sections, the following: -->
<!-- raw_pcb_data_prep.R, raw_dioxin_data_prep.R, and raw_pfos_data_prep.R -->
<!-- station_attribute_prep.R, congener_description.R -->

```{r read raw datasets, message = FALSE, warning = FALSE, echo = TRUE, results = "hide"}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "CW", "CON")

lapply(
  list(
    c("ContaminantsBiota_PCBs", "pcb_rawdata_bio"),
    c("ContaminantsSediment_PCBs", "pcb_rawdata_sed"),
    c("ContaminantsBiota_PFOS", "pfos_rawdata_bio"),
    c("ContaminantsBiota_Dioxins", "dioxin_rawdata_bio"),
    c("ContaminantsSediment_Dioxins", "dioxin_rawdata_sed")
  ),
  function(x){
    read_csv(
      file.path(dir_rawdata, x[1], paste(x[1], "csv", sep = ".")),
      ## where not read in correctly, column types must be specified ...
      col_types = cols(
        SUBNO = col_character(), 
        DETLI = col_number(), 
        LMQNT = col_number(), 
        METCU = col_character(),
        METST = col_character(), 
        METPT = col_character(),
        METPS = col_character(),
        METFP = col_character(), 
        METOA = col_character(),
        REFSK = col_character(),
        VFLAG = col_character(), 
        BULKID = col_character(), 
        PURPM = col_character(),
        QFLAG = col_character(),
        FINFL = col_character(),
        UNCRT = col_number()
      )
    ) %>% assign(x = x[2], envir = .GlobalEnv)
  }
)

## check number of dates and years sample by country, PCBs data from ICES
## Denmark doesn't have herring data...
do.call(rbind, lapply(as.list(unique(pcb_rawdata_bio$Country)), function(country){
  cbind(
    pcb_rawdata_bio %>% 
      filter(Country == country) %>%
      select(Species, MYEAR) %>%
      distinct(.) %>%
      group_by(Species) %>%
      summarise(NumYrs = n(), LatestYr = last(MYEAR)) %>%
      ungroup(),
    Country = country
  )
})) %>% DT::datatable()
```

<br>

#### 2.2.1 Rename Fields/Variables

```{r rename fields for data, echo = TRUE, results = "hide"}
## ICES column name descriptors:
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20biota.pdf
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20sediment.pdf
rename_vars <- function(dataset){
  
  df_vars_renamed <- dataset %>% 
    
    ## create date, month, year, day columns
    dplyr::mutate(date = as.Date(DATE, "%d/%m/%Y")) %>% 
    
    dplyr::mutate(
      day = lubridate::day(date),
      month = lubridate::month(date), 
      year = lubridate::year(date)) %>% 
    
    ## change column names
    dplyr::rename(
      country = Country, report_institute = RLABO,
      station = STATN, 
      monit_year = MYEAR, date_ices = DATE,
      
      latitude = Latitude, longitude = Longitude,
      
      param_group = PARGROUP, variable = PARAM, 
      value = Value, unit = MUNIT,
      
      species = Species, sex_specimen = SEXCO, num_indiv_subsample = NOINP,
      test_organism = `Test Organism`,
      matrix_analyzed = MATRX, not_used_in_datatype = NODIS,
      
      monit_program = MPROG, monit_purpose = PURPM,
      
      basis_determination = BASIS, qflag = QFLAG,
      vflag = VFLAG, detect_lim = DETLI,
      quant_lim = LMQNT, uncert_val = UNCRT, method_uncert = METCU,
      
      analyt_lab = ALABO, ref_source = REFSK, 
      method_storage = METST, method_pretreat = METPT, 
      method_pur_sep = METPS, method_chem_fix = METFP,
      method_chem_extract = METCX, method_analysis = METOA, 
      formula_calc = FORML,
      
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sampler_type = SMTYP, factor_compli_interp = FINFL,
      
      analyt_method_ref = tblAnalysisID, 
      measurement_ref = tblParamID,
      samp_ref = tblSampleID
    ) %>% 
    
    ## improve clarity of 'basis_determination' and 'matrix_analyzed' column content
    mutate(
      basis_determination = ifelse(
        basis_determination == "L", "lipid weight",
        ifelse(
          basis_determination == "W", "wet weight",
          ifelse(
            basis_determination == "D", "dry weight", NA
          )
        )
      ),
      matrix_analyzed = ifelse(
        matrix_analyzed == "LI", "liver",
        ifelse(
          matrix_analyzed == "MU", "muscle",
          ifelse(
            matrix_analyzed == "WO", "whole organism", NA
          )
        )
      )
    )
  return(df_vars_renamed)
}

## same names and structures so can apply function to all datasets
lapply(
  list("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(sub_samp_ref = tblBioID)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
lapply(
  list("pcb_rawdata_sed", "dioxin_rawdata_sed"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      rename(press_depth = DEPHU, depth_low = DEPHL)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
rm("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio", "pcb_rawdata_sed", "dioxin_rawdata_sed")
```

---

<br>

#### 2.2.2 Standardize Units


The main objective of the code below is to clean the contaminants datases set so they contain only values based on wet weight for biota or dry weight for sediment-matrix measurements, in standardized units of ug/kg.
This includes the following pre-processing steps:

- Remove flagged and deprecated data entries  
- Separate 'b-bio' data from the other param group data ('oc-cb', 'oc-dx', or 'o-fl' for PCB, Dioxin, PFOS resp.) for use in lipid basis to wet weight conversion  
- Take averages where there are duplicate data samples, based on the sub_samp_ref value groupings for biota or samp_ref value groupings for sediment-matrix measurements  
- Convert all congener concentration data to ug/kg and to wet weight for biota  
- If data were presented in lipid weight, they were converted to wet weight by: $(\mbox{EXLIP%}/100)*(\mbox{CB conc. lipid weight})$  


The datasets each contain two main categories (param_groups) one of which is BBIO. BBIO consists of variables with information about the sample like dry/lipid/wet weight percentage, age, weight and length. The second category contains the congeners concentration information. In stages, these are each manipulated and later rejoined by the sample (samp_ref or sub_samp_ref) ID numbers.

<br>

<!-- the following code chunks are modified from raw_data_prep.r scripts in bhi-1.0-archive/baltic2015/prep/CW/contaminants -->

```{r standardize units in biota datasets, echo = TRUE}

standardize_con_data <- function(data_renamed, matrix_biota = TRUE, contam_param, rm_vars = NULL){
  
  
  ## what are the specific parameters?
  ## unique parameter groups and associated variables:
  chk_params <- data_renamed %>% 
    select(param_group, variable) %>% 
    distinct() %>% 
    arrange(param_group, variable)
 
  ## filter and/or remove unneeded variables from data ----
  message("STEP 1: filter and/or unselect unneeded variables and congeners from dataset\n")
  df <- data_renamed %>% 
    ## remove 'suspect' and other non-'acceptable': https://vocab.ices.dk/?ref=58
    filter(!vflag %in% c("S", "C")) %>% 
    ## remove samples for liver tissue, keep muscle, and whole organism for length x weight
    filter(matrix_analyzed != "liver" | is.na(matrix_analyzed)) %>% 
    ## remove certain variables-- summarized data or depreciated codes
    filter(!variable %in% rm_vars)
  
  
  ## sediment versus biota datasets, different sample/id variables
  sampvars <- c("sub_samp_id", "samp_ref", "sub_samp_ref")
  if(!matrix_biota){
    sampvars <- setdiff(sampvars, "sub_samp_ref")
  }
  ## check alignment of all measurements with sub_samp_ref for biota, samp_ref for sediment
  ## (most unique besides measurement_ref)
  ## there are more unique measurement_ref but these are for different vars w/in sub_samp_id
  chk_ids <- c()
  for(i in c(sampvars, "measurement_ref")){
    chk_ids <- c(chk_ids, sprintf("%s: %s", i, length(unique(df[[i]]))))
  }
  if(nrow(df %>% filter(is.na(sampvars[length(sampvars)]))) != 0){
    warning(sprintf("there are observations without %s in the dataset", sampvars[length(sampvars)]))
  }
  message(sprintf("NOTE will align by %s when grouping to identify duplicates\n", sampvars[length(sampvars)]))
  
  
  ## BBIO DATA
  
  ## separate out bbio data for lipid to wet-weight conversion ----
  ## B-BIO variable code: http://vocab.ices.dk/?CodeID=51634
  ## b-bio data -- length, weight, fat and lipid content
  ## lipid content, etc. needed to convert lipid basis samples into the wet weight are in the B-BIO column
  message("STEP 2: separate out bbio data and wrangle for use in lipid to wet-weight conversion...\n")
  df_bbio <- df  %>% 
    filter(param_group == "B-BIO") %>%
    select(
      station, latitude, longitude, date, year, 
      species, matrix_analyzed, basis_determination, qflag,
      variable, unit, value,
      !!!syms(sampvars)
    )
  
  ## if there are cm, convert to mm
  df_bbio <- df_bbio %>% 
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "mm"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = ifelse(is.na(ConvertUnit), value, value*ConvertFactor),
      unit = ifelse(is.na(ConvertUnit), unit, "mm")
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## confirm that units of bbio, are one-to-one
  chk_bbio_units <- df_bbio %>% 
    select(variable, unit) %>% 
    distinct()
  
  df_bbio <- select(df_bbio, -unit)

  chk_num_bbio_dup <- nrow(df_bbio) - nrow(distinct(df_bbio %>% select(-value)))
  
  ## BBIO DUPLICATES
  ## identify, explore, handle bbio duplicates ----
  ## group to identify duplicates; for a given sub_samp_ref only some variables may have duplicates
  grpvars <- c(
    "station", "year", "species", "basis_determination", "matrix_analyzed", "qflag", 
    sampvars, "date", "variable", "longitude", "latitude"
  )
  chk <- c()
  for(i in 1:6){
    bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(c(grpvars[i], grpvars[7:length(grpvars)]))) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
    chk <- c(chk, nrow(filter(bbio_duplicates, n > 1)))
  }
  if(var(chk) != 0){
    message(sprintf(
      "NOTE bbio duplicates dataframe dims vary with ID variables, investigate: %s",
      paste(grpvars[which(chk != chk[which.max(tabulate(match(chk, chk)))])], collapse = ", ")
    ))
  }
  
  ## join duplicate table by grouped vars to locate within full bbio dataset
  bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(grpvars)) %>%
      summarise(n = n()) %>% 
      filter(n > 1) %>% 
      ungroup()
  df_bbio <- left_join(df_bbio, bbio_duplicates, by = grpvars)
  
  ## take averages for variable/sample duplicates
  df_bbio <- bind_rows(
    ## averages of duplicates
    df_bbio %>% 
      filter(n > 1) %>% 
      group_by(!!!syms(grpvars)) %>% 
      summarize(value = mean(value)) %>% 
      ungroup(),
    ## rows of bbio data with no duplicates
    df_bbio %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## check for unique variables and matrix_analyzed, per species
  chk_bbio_vars <- NULL
  if(matrix_biota){
    chk_bbio_vars <- do.call(
      rbind, 
      lapply(
        as.list(unique(df_bbio$species)), 
        function(x){
          cbind(
            df_bbio %>% 
              filter(species == x) %>%
              select(matrix_analyzed, basis_determination, variable) %>% 
              distinct(),
            species = x
          )
        }
      )
    )
  }
  
  ## WIDE BBIO DATA
  ## bbio data wide format ----
  df_bbio_wide <- df_bbio %>% 
    ## remove basis_determination because not always recorded for bio vars, 
    ## will give incorrect NAs in EXLIP% among others for some rows when rejoined with concentration data
    select(-basis_determination) %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  
  ## which columns are needed to uniquely identify and later rejoin with congener conc. data
  ## i.e. at this stage, which subset of grpvars gives groupings such that all n are one?
  # for(i in grpvars){print(paste(i, length(unique(df_bbio_wide[[i]]))))}
  chkgrpvars <- intersect(grpvars, names(df_bbio_wide))
  chk <- chkgrpvars
  for(i in 1:length(chkgrpvars)){
    bbio_wide_duplicates <- df_bbio_wide %>% 
      group_by(!!!syms(setdiff(chk, chkgrpvars[i]))) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    if(nrow(bbio_wide_duplicates) == 0){
      chk <- setdiff(chk, chkgrpvars[i])
    }
  }
  message(sprintf(
    "NOTE minimum group ID variables for later rejoining uniquely with congener data:\n%s\n", 
    paste(chk, collapse = ", ")
  ))
  chk_bbio_wide_ids <- chk
  ## sub_samp_id and samp_ref together are as unique as sub_samp_ref
  # nrow(select(df_bbio_wide, sub_samp_ref) %>% distinct())
  # nrow(select(df_bbio_wide, sub_samp_id, samp_ref) %>% distinct())
  
  
  ## CONGENER CONCENTRATIONS DATA
  ## check congener concentration data, units and duplicates ----
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  
  df_conc <- df %>%
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      station, latitude, longitude, date, year,
      species, matrix_analyzed, basis_determination,
      variable, unit, value, detect_lim, quant_lim, qflag,
      !!!syms(sampvars)
    )
  
  ## convert congener concentration units all to ug/kg
  message("STEP 3: convert congener concentrations units to ug/kg")
  df_conc <- df_conc %>%
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "ug/kg"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = value*ConvertFactor, 
      detect_lim = detect_lim*ConvertFactor,
      unit = "ug/kg"
    ) %>% 
    select(-ConvertUnit, -ConvertFactor)
  
  ## check whether variables vs units relationship is one-to-one
  chk_conc_units <- df_conc %>% 
    select(variable, unit) %>% 
    distinct() %>%
    arrange(variable)
  
  df_conc <- select(df_conc, -unit)
  
  
  ## take averages for congener conc. variable x sample duplicates ----
  
  ## identify duplicates
  ## group to identify duplicates, 
  ## for a given sub_samp_ref only some vars/congeners may have duplicates
  message("STEP 4: averaging, where multiple congener concentrations observations per sub sample\n")
  chk_num_conc_dup <- nrow(df_conc) - nrow(distinct(df_conc %>% select(-value, -detect_lim, -quant_lim)))

  conc_duplicates <- df_conc %>% 
    group_by(!!!syms(grpvars)) %>%
    summarise(n = n()) %>% 
    ## no cases where duplicates with-and-without qflags, else would keep cases unflagged observations...
    # group_by(!!!syms(setdiff(grpvars, "qflag"))) %>%
    # mutate(allflagged = !any(is.na(qflag))) %>%
    # filter(n > 1, !allflagged) %>% ...
    filter(n > 1) %>% 
    ungroup()
  
  ## join duplicates tables by grouped vars to locate them in original dataset
  df_conc <- left_join(df_conc, conc_duplicates, by = grpvars)
  chk_conc_dup <- filter(df_conc, !is.na(n))
  
  df_conc <- bind_rows(
    ## averages of duplicates
    df_conc %>% 
      filter(n > 1) %>%
      group_by(!!!syms(grpvars)) %>% 
      summarize(
        value = mean(value), 
        detect_lim = mean(detect_lim, na.rm = TRUE), 
        quant_lim =  mean(detect_lim, na.rm = TRUE)
      ) %>% 
      ungroup(),
    ## rows of conc data with no duplicates
    df_conc %>% filter(is.na(n)) %>% select(-n)
  )
  
  ## remaining duplicates for biota datasets are due to dual wet/lipid weight records;
  ## of these, keep wet weight records, when has a value
  if(matrix_biota){
    chk <- df_conc %>%
      group_by(!!!syms(setdiff(grpvars, c("basis_determination", "matrix_analyzed")))) %>%
      mutate(n = n(), ww_val = any(basis_determination == "wet weight" & !is.na(value))) %>%
      filter(n > 1) %>% 
      mutate(
        rm_duplicate = 
          (ww_val & basis_determination == "lipid weight")|
          (!ww_val & basis_determination == "wet weight")
      ) %>% 
      ungroup()
    df_conc <- df_conc %>%
      left_join(chk, by = intersect(names(df_conc), names(chk))) %>% 
      mutate(rm_duplicate = ifelse(is.na(rm_duplicate), TRUE, rm_duplicate)) %>% 
      filter(rm_duplicate) %>% 
      select(-n, -ww_val, -rm_duplicate)
  }
  
  ## check if one row for every unique sub_samp_ref for biota, samp_ref for sediment
  df_conc_wide <- df_conc %>%
    select(-detect_lim, -quant_lim) %>% 
    tidyr::pivot_wider(names_from = variable, values_from = value)
  if(length(unique(df_conc[[sampvars[length(sampvars)]]])) != nrow(distinct(df_conc_wide))){
    message(
      "NOTE conc. subsamples not uniquely identified even after averaging; 
            multiple obs per ID, probably due to qflags\n"
    )
  }
  
  ## for biota convert lipid weight measurements to wet weight ----
  ## UNITS HAVE ALL BEEN CONVERTED TO MICROGRAMS PER KILOGRAM
  ## use the df_bbio_wide datatable to convert values in df_conc table
  df_final <- left_join(df_conc, df_bbio_wide, by = intersect(grpvars, names(df_bbio_wide))) 
  
  if(matrix_biota){
    message("STEP 5: converting all congener concentrations in biota to wet weight")
    df_final <- df_final %>% 
      ## if value is not wet weight convert, otherwise keep value
      mutate_at(
        vars(c("value", "detect_lim", "quant_lim")), 
        list(wet_wgt = ~ case_when(
          basis_determination == "lipid weight" ~ .*(`EXLIP%`/100),
          basis_determination == "dry weight" ~ .*(`DRYWT%`/100),
          basis_determination == "wet weight" ~ .
        ))
      )
  }
  
  ## rejoin with meta information ----
  ## rejoin with info on country and monitoring program info, qflaugs, etc
  message("FINAL STEP: rejoining with meta information\n")
  
  df_final <- df %>% 
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      country, monit_program, monit_purpose, 
      report_institute, 
      monit_year, date_ices, day, month,
      num_indiv_subsample, bulk_id,  
      !!!syms(grpvars)
    ) %>% 
    distinct() %>% 
    right_join(df_final, by = grpvars) %>% 
    mutate(qflagged = ifelse(is.na(qflag), FALSE, TRUE))
  
  ## return wrangled data and checks ----
  
  ## list of checks as part of result
  chks <- list(
    chk_params, chk_ids, 
    chk_bbio_units, chk_num_bbio_dup, chk_bbio_vars,
    chk_conc_units, chk_num_conc_dup, chk_conc_dup
  )
  
  df_final <- filter(df_final, !is.na(value))
    
  if(!all(mutate(group_by(df_final, !!!syms(grpvars)), n = n())$n == 1)){
    warning("NOTE rows of final dataframe are not uniquely identified by grouping variables")
  }
  
  return(list(
    df_final = df_final, 
    groupingvars = grpvars,
    df_conc_wide = df_conc_wide, 
    df_bbio_wide = df_bbio_wide, 
    checks = chks
  ))
}
```

---

<br>

#### 2.2.3 Wrangle all and Save

```{r save cleaned datasets, echo = TRUE, message = FALSE, warning = FALSE, results = "hide"}
dir_interm <- here::here("data", "CW", "contaminants", version_year, "intermediate")

lapply(
  list(
    ## PCB datasets
    ## remove PCB, SCB, SCB7 - these are summarized data or depreciated codes
    ## OC-CB variable codes: vocab.ices.dk/?CodeID=26983
    list("pcb_bio", TRUE, "OC-CB", c("PCB", "SCB", "SCB7")),
    list("pcb_sed", FALSE, "OC-CB", c("PCB", "SCB", "SCB7")),
    
    ## Dioxin datasets
    list("dioxin_bio", TRUE, "OC-DX", NULL),
    list("dioxin_sed", FALSE, "OC-DX", NULL),

    ## PFOS dataset
    list("pfos_bio", TRUE, "O-FL", NULL)
  ),
  
  function(dat){
    dat_final <- standardize_con_data(get(dat[[1]]), dat[[2]], dat[[3]], dat[[4]]) 
    assign(
      x = paste(dat[[1]], "cleaned", sep = "_"), 
      value = dat_final, 
      envir = .GlobalEnv
    )
    assign(
      x = paste(dat[[1]], "clean_df", sep = "_"), 
      value = dat_final[["df_final"]], 
      envir = .GlobalEnv
    )
    write_csv(
      dat_final[["df_final"]], 
      file.path(dir_interm, paste(dat[[1]], "cleaned.csv", sep = "_"))
    )
  }
)
```

<br>

---

### 2.3 Initial Data Exploration

#### 2.3.2 Spatial Distributions of Measurements

```{r sampling maps, results = "show", message = FALSE, warning = FALSE, echo = TRUE, fig.width = 9.5, fig.height = 20}
## basemap with baltic countries borders and BHI regions with ID numbers
bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile"), 
    layer = "BHI_shapefile",
    quiet = TRUE
  )) %>% sf::st_as_sf()

basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      sf::st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", color = "lightsteelblue",
    size = 0.1, alpha = 0.8
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "lightsteelblue") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3"))

## mapping datasets for biota and sediments
make_mapdf <- function(x, yr){
  cbind(
    get(x) %>%
      filter(year %in% yr, longitude > 9) %>%
      group_by(year, latitude, longitude, variable) %>%
      summarize(
        n_obs = n(),
        mean_val = ifelse(
          str_detect(x, "sed"), 
          mean(value, na.rm = TRUE),
          mean(value_wet_wgt, na.rm = TRUE)
        )
      ) %>%
      filter(!is.na(mean_val)) %>% 
      group_by(latitude, longitude) %>% 
      mutate(
        num_congeners = n(),
        mean_allcongeners_selectedyrs = mean(mean_val),
        sd_allcongeners_selectedyrs = ifelse(is.na(sd(mean_val)), 1, sd(mean_val) + 1)
      ) %>%
      tidyr::pivot_longer(
        cols = c(sd_allcongeners_selectedyrs, mean_allcongeners_selectedyrs), 
        names_to = "metric", values_to = "value"
      ) %>%
      ungroup() %>% 
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326, agr = "identity"),
    source = str_remove(x, "_clean_df"))
}
mapdf_biota <- do.call(
  rbind, lapply(
    list("pcb_bio_clean_df", "pfos_bio_clean_df", "dioxin_bio_clean_df"), 
    function(x) make_mapdf(x, 2016:2019)
  )
)
mapdf_sediment <- do.call(
  rbind, 
  lapply(
    list("pcb_sed_clean_df", "dioxin_sed_clean_df"), 
    function(x) make_mapdf(x, yr = 2014:2019)
  )
)

## contaminants datasets overlaying basemap
mapbio <- basemap + 
  geom_sf(
    aes(size = value), 
    color = "maroon",
    alpha = 0.2, 
    shape = 19, 
    data = mapdf_biota,
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric)) +
  theme(axis.text.x = element_blank())

mapsed <- basemap + 
  geom_sf(
    aes(size = value), 
    color = "maroon", 
    alpha = 0.2, 
    shape = 19, 
    data = mapdf_sediment,
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric))

gridExtra::grid.arrange(mapbio, mapsed, ncol = 1, heights = c(1.5, 1))
```


#### 2.3.3 Contaminants in Biota vs Sediments

**Contaminants: PCB and Dioxin by Matrix per Congener**

```{r contaminants in biota vs sediment histograms, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 11}
sf::st_geometry(mapdf_sediment) <- NULL
sf::st_geometry(mapdf_biota) <- NULL

boxdf <- bind_rows(
  mutate(
    mapdf_sediment, 
    matrix = "sediment",
    source = str_remove(source, "_[a-z].*")
  ),
  mutate(
    mapdf_biota, 
    matrix = "biota",
    source = str_remove(source, "_[a-z].*")
  )
)
boxdf <- boxdf %>% 
  filter(metric == "mean_allcongeners_selectedyrs", source != "pfos") %>% 
  group_by(source) %>% 
  mutate(quant9 = quantile(mean_val, 0.85)) %>% 
  ungroup() %>% 
  filter(mean_val < quant9)

ggplot(boxdf, aes(x = variable, y = mean_val, color = matrix)) + 
  geom_boxplot(outlier.alpha = 0.2, outlier.shape = 20) + 
  labs(x = NULL, y = NULL) + 
  scale_color_manual(values = c("orchid", "tomato")) +
  facet_wrap(~source, scales = "free", ncol = 12) +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip() +
  theme_bw() +
  theme(
    legend.background = element_rect(fill = "grey"),
    legend.position = c(0.42, 0.94), 
    panel.grid.minor.x = element_blank(), 
    panel.grid.major.x = element_blank()
  )
```

<br>
