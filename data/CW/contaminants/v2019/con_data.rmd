
## 2. Data

```{r preamble data, echo = FALSE, include = FALSE, error = FALSE}
source(here::here("R", "setup.R"))
```


### 2.1 Datasets with Sources
<br/>

#### 2.1.1 PCB Data

**PCB Data in Biota**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PCBs/ContaminantsBiota_PCBs.csv -->
```{r PCB biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2017"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**PCB Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26983 -->
```{r PCB congeners table, echo = FALSE}
pcb_congeners <- t(data.frame(
  c("CB180", "2,2',3,4,4',5,5'-heptachlorobiphenyl"),
  c("SCB7", "sum of CBs.- Sum of"),
  c("CB28", "2,4,4'-trichlorobiphenyl"),
  c("CB52", "2,2',5,5'-tetrachlorobiphenyl"),
  c("CB101", "2,2',4,5,5'-pentachlorobiphenyl"),
  c("CB118", "2,3',4,4',5-pentachlorobiphenyl"),
  c("CB153", "2,2',4,4',5,5'-hexachlorobiphenyl"),
  c("CB138", "2,2',3,4,4',5'-hexachlorobiphenyl"),
  c("PCB", "polychlorinated biphenyls - Deprecated- Report as single PCBs"),
  c("CB194", "2,2',3,3',4,4',5,5'-octachlorobiphenyl"),
  c("CB105", "2,3,3',4,4'-pentachlorobiphenyl"),
  c("CB110", "2,3,3',4',6-pentachlorobiphenyl"),
  c("CB126", "3,3',4,4',5-pentachlorobiphenyl"),
  c("CB128", "2,2',3,3',4,4'-hexachlorobiphenyl"),
  c("CB149", "2,2',3,4',5',6-hexachlorobiphenyl"),
  c("CB151", "2,2',3,5,5',6-hexachlorobiphenyl"),
  c("CB156", "2,3,3',4,4',5-hexachlorobiphenyl"),
  c("CB157", "2,3,4,3',4',5'-hexachlorobiphenyl"),
  c("CB170", "2,2',3,3',4,4',5-heptachlorobiphenyl"),
  c("CB44", "2,2',3,5'-tetrachlorobiphenyl"),
  c("CB49", "2,2',4,5'-tetrachlorobiphenyl"),
  c("CB99", "2,2',4,4',5-pentachlorobiphenyl"),
  c("CB77", "3,3',4,4'-tetrachlorobiphenyl"),
  c("CB169", "3,3',4,4',5,5'-hexachlorobiphenyl"),
  c("CB31", "2,4',5-trichlorobiphenyl"),
  c("CB81", "3,4,4',5-tetrachlorobiphenyl"),
  c("SCB", "sum of CBs.- Specify in method data"),
  c("CB189", "2,3,3',4,4',5,5'-heptachlorobiphenyl"),
  c("CB114", "2,3,4,4',5-pentachlorobiphenyl"),
  c("CB123", "1,1'-Biphenyl, 2,3',4,4',5'-pentachloro-"),
  c("CB167", "2',3,4,4',5,5'-hexachlorobiphenyl"),
  c("CB187", "2,2',3,4',5,5',6-heptachlorobiphenyl"),
  c("CB66", "2,3',4,4'-tetrachlorobiphenyl"),
  c("CB60", "1,1'-Biphenyl, 2,3,4,4'-tetrachloro-"),
  c("CB141", "2,2',3,4,5,5'-hexachlorobiphenyl"),
  c("CB74", "2,4,4',5-tetrachlorobiphenyl"),
  c("CB206", "2,2',3,3',4,4',5,5',6-nonachlorobiphenyl"),
  c("CB33", "2',3,4-trichlorobiphenyl"),
  c("CB18", "2,2',5-trichlorobiphenyl"),
  c("CB183", "2,2',3,4,4',5',6-heptachlorobiphenyl"),
  c("CB47", "2,2',4,4'-tetrachlorobiphenyl"),
  c("CB209", "2,2',3,3',4,4',5,5',6,6'-decachlorobiphenyl"),
  c("CB51", "2,2',4,6'-Tetrachlorobiphenyl"),
  c("CB122", "1,1'-Biphenyl, 2,3,3',4',5'-pentachloro-"),
  c("CB138+163", "2,2',3,4,4',5'-hexachlorobiphenyl")))

colnames(pcb_congeners) <- c("Data Code", "")
rownames(pcb_congeners) <- NULL
htmlTable::htmlTable(pcb_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br/>

**PCBs in Sediment**
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_PCBs/ContaminantsSediment_PCBs.csv -->
```{r PCB sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2018"),
  c("Purpose of monitoring", "All"),
  c("Country", "All"),
  c("Monitoring Program", "All"),
  c("Parameter Group", "Chlorobiphenyls"),
  c("Reporting Laboratory", "All"),
  c("Analytical laboratory", "All"),
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 3 October 2019 by Ellie Campbell")
```
<br/>

#### 2.1.2 PFOS Data

**PFOS in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_PFOS/ContaminantsBiota_PFOS.csv -->

```{r PFOS biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "2005-2017  (2005 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Organofluorines"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```
<br/>

#### 2.1.3 Dioxin Data

**Dioxins in Biota**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsBiota_Dioxins/ContaminantsBiota_Dioxins.csv -->
```{r dioxin biota data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1998-2017  (1998 earliest allowed)"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsBiota.aspx) <br/> Downloaded 22 April 2019 by Ellie Campbell")
```

**Dioxin Congeners**
<!-- reference codes found here: https://vocab.ices.dk/?CodeID=26986 -->
```{r dioxin congeners table, echo = FALSE}
dioxin_congeners <- t(data.frame(
  c("CDD1N", "1 2 3 7 8-pentachlorodibenzo-p-dioxin"),  
  c("CDD4X", "1 2 3 4 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD6P", "1 2 3 4 6 7 8-heptachlorodibenzo-p-dioxin"), 
  c("CDD6X", "1 2 3 6 7 8-hexachlorodibenzo-p-dioxin"), 
  c("CDD9X", "1 2 3 7 8 9-hexachlorodibenzo-p-dioxin"), 
  c("CDDO", "1 2 3 4 6 7 8 9-octachlorodibenzo-p-dioxin"),   
  c("CDF2N", "2 3 4 7 8-pentachlorodibenzofuran"),   
  c("CDF2T", "2 3 7 8-tetrachloro-dibenzofuran"),   
  c("CDF4X", "2 3 4 6 7 8-hexachlorodibenzofuran"),   
  c("CDF6P", "1 2 3 4 6 7 8-heptachlorodibenzofuran"),   
  c("CDF6X", "1 2 3 6 7 8-hexachlorodibenzofuran"),   
  c("CDF9P", "1 2 3 4 7 8 9-heptachlorodibenzofuran"),   
  c("CDF9X", "1 2 3 7 8 9-hexachlorodibenzofuran"),   
  c("CDFDN", "1 2 3 7 8/1 2 3 4 8-pentachloro-dibenzofuran"),   
  c("CDFO", "octachloro-dibenzofuran (group)"),    
  c("TCDD", "2 3 7 8-tetrachlorodibenzo-p-dioxin")))   

colnames(dioxin_congeners) <- c("Data Code", "")
rownames(dioxin_congeners) <- NULL
htmlTable::htmlTable(dioxin_congeners, align = "lr", col.rgroup = c("none", "#F7F7F7"))
```
<br>

**Dioxins in Sediment**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ContaminantsSediment_Dioxins/ContaminantsSediment_Dioxins.csv -->
```{r dioxin sediment data, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Year", "1990-2018"),  
  c("Purpose of monitoring", "All"), 
  c("Country", "All"),  
  c("Monitoring Program", "All"),  
  c("Parameter Group", "Dioxins"),  
  c("Reporting Laboratory", "All"),  
  c("Analytical laboratory", "All"),  
  c("Geographical Areas", "(HELCOM) ALL HELCOM sub-basins")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES Database](http://dome.ices.dk/views/ContaminantsSediment.aspx) <br/> Downloaded 3 October 2019 by Ellie Campbell")
```
<br/>

#### 2.1.4 ICES Station Dictionary and Impacts

**ICES Station Dictionary**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_dictionary.csv -->
```{r ices station dictionary, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("", "")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES](SOURCE...) <br/> Downloaded [DATE...] February 2020 by Ellie Campbell")
```
<br/>

**ICES Station Impacts Codes**  
<!-- dataset save location BHI_share/BHI 2.0/Goals/CW/CON/ICES_station_dictionary/ICES_station_impacts.csv -->
```{r ices station dictionary, echo = FALSE, results = "asis"}
tab <- t(data.frame(
  c("Data theme:", "Environmental"),
  c("Keyword:", "Station"),
  c("Code Types:", "MSTAT")))

colnames(tab) <- c("Option", "Specification")
rownames(tab) <- NULL

knitr::kable(tab, caption = "Source: [ICES vocabulary](https://vocab.ices.dk/?ref=177) <br/> Downloaded 7 February 2020 by Ellie Campbell")
```
<br/>


#### 2.1.5 TEQ values for dioxin-like PCBs and Dioxins

Dioxin and dioxin-like compounds. Target is set at 0.0065 TEQ ug/kg ww fish, crustaceans or molluscs (source of target: EQS biota human health). Secondary GES boundary: CB-118 24 ug/kg lw fish liver or muscle (source: EAC).  

This threshold was agreed upon as GES indicator at the most recent meeting of the [Working Group on the State of the Environment and Nature Conservation](http://helcom.fi/helcom-at-work/groups/state-and-conservation) April 11-15, 2016. *Recevied the draft report from Elisabeth Nyberg.*  

This is consistent with the [EU human health thresholds for dioxin and dioxin-like compounds - 6.5 pg/g](http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2011:320:0018:0023:EN:PDF)  

TEQ values from the [World Health Organization 2005](http://www.who.int/ipcs/assessment/tef_values.pdf)  

<br/>

#### 2.1.6 PFOS Indicator

According to [HELCOM PFOS core indicator document, p.3](http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf), the "GES boundary is set to 9.1 μg/kg wet weight (or 9.1 ng/g ww) with the protection goal of human health".

"The GES boundary is an environmental quality standard (EQS), derived at EU level as a substance included on the list of priority substances under the Water Framework Directive (European Commission 2000, 2013). GES, in accordance with the MSFD is defined as 'concentrations of contaminants at levels not giving rise to pollution effects'. 

EQS are derived from ecotoxicological studies to protect freshwater and marine ecosystems from potential adverse effects of chemicals, as well as adverse effects on human health via drinking water and food from aquatic environments. Quality Standards (QS) are derived for different protection goals, i.e.: pelagic and benthic communities, top-predators in these ecosystems, and human health. The most stringent of these QS is the basis for the EQS. The EQS boundary for PFOS is based on the QS set for biota to protect human health (9.1 μg/ kg fish ww), defined for edible parts in fish. For harmonization purposes the EC Guidance Document No. 32 on biota monitoring (the implementation of EQS biota) under the WFD was developed (European Commission 2014). This guidance document recommends that the results from the monitoring should be standardized to represent fish at a trophic level of 4, which is an estimate of the general trophic level in commercial fish in Europe. The recommendation to obtain PFOS data in fish at a trophic level of 4 is to adjust the values from monitoring in accordance with trophic magnification factors and trophic level."[HELCOM PFOS core indicator document, p.8](http://www.helcom.fi/Core%20Indicators/PFOS_HELCOM%20core%20indicator%202016_web%20version.pdf)  

**HELCOM core indicator report uses liver PFOS concentrations converted to muscle equivalent values** as in [Faxneld et al. 2014b](https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf).  

<br/>

---

<br/>

### 2.2 Centralization & Normalization
<!-- note: below incorporates from BHI1.0, along with preliminary contaminants_prep.Rmd sections, the following: -->
<!-- raw_pcb_data_prep.R, raw_dioxin_data_prep.R, and raw_pfos_data_prep.R -->
<!-- station_attribute_prep.R, congener_description.R -->

```{r read raw datasets, message = FALSE, warning = FALSE, echo = TRUE}
## root location of the raw data
dir_rawdata <- file.path(dir_B, "Goals", "CW", "CON")

## PCBs data from ICES
pcb_rawdata_bio <- read_csv(file.path(dir_rawdata, "ContaminantsBiota_PCBs", "ContaminantsBiota_PCBs.csv"))
pcb_rawdata_sed <- read_csv(file.path(dir_rawdata, "ContaminantsSediment_PCBs", "ContaminantsSediment_PCBs.csv"))

tab <- data.frame(Species = unique(pcb_rawdata_bio$Species))
for(ctry in unique(pcb_rawdata_bio$Country)){ 
  tmp <- pcb_rawdata_bio %>% 
    filter(Country == ctry) %>%
    select(Species, MYEAR) %>%
    distinct(.) %>%  # check number of dates and years by country
    arrange(Species, MYEAR) %>% 
    group_by(Species) %>%
    summarise(num_yr = n(), latest_year = last(MYEAR)) %>% # get last year for each country
    ungroup() 
  colnames(tmp) <- c("Species", paste0(ctry, "_NumYrs"), paste0(ctry, "_LastYr"))
  tab <- left_join(tab, tmp, by = "Species")
}
tab <- tab %>% 
  tidyr::pivot_longer(
    cols = 2:ncol(tab), 
    names_to = c("Country", "Metric"), 
    names_pattern = "(.*)_(.*)",
    values_to = "Value"
  ) %>% arrange(Species, Metric)
## check number of dates and years sample by country
## Denmark doesn't have herring data...
knitr::kable(tab)

## PFOS data from ICES
## no sediment data with PFOS 
pfos_rawdata_bio <- read_csv(file.path(dir_rawdata, "ContaminantsBiota_PFOS", "ContaminantsBiota_PFOS.csv"))

## Dioxin data from ICES
dioxin_rawdata_bio <- read_csv(file.path(dir_rawdata, "ContaminantsBiota_Dioxins", "ContaminantsBiota_Dioxins.csv"))
dioxin_rawdata_sed <- read_csv(file.path(dir_rawdata, "ContaminantsSediment_Dioxins", "ContaminantsSediment_Dioxins.csv"))
```

<br>

#### 2.2.1 Rename Fields/Variables

```{r rename fields for data, echo = TRUE}
## ICES column name descriptors:
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20biota.pdf
## http://dome.ices.dk/Download/Contaminants%20and%20effects%20of%20contaminants%20in%20sediment.pdf
rename_vars <- function(dataset){
  
  df_vars_renamed <- dataset %>% 
    
    ## create date, month, year, day columns
    dplyr::mutate(date = as.Date(DATE, "%d/%m/%Y")) %>% 
    
    dplyr::mutate(
      day = lubridate::day(date),
      month = lubridate::month(date), 
      year = lubridate::year(date)) %>% 
    
    ## change column names
    dplyr::rename(
      country = Country, report_institute = RLABO,
      station = STATN, 
      monit_year = MYEAR, date_ices = DATE,
      
      latitude = Latitude, longitude = Longitude,
      
      param_group = PARGROUP, variable = PARAM, 
      value = Value, unit = MUNIT,
      
      species = Species, sex_specimen = SEXCO, num_indiv_subsample = NOINP,
      test_organism = `Test Organism`,
      matrix_analyzed = MATRX, not_used_in_datatype = NODIS,
      
      monit_program = MPROG, monit_purpose = PURPM,
      
      basis_determination = BASIS, qflag = QFLAG,
      vflag = VFLAG, detect_lim = DETLI,
      quant_lim = LMQNT, uncert_val = UNCRT, method_uncert = METCU,
      
      analyt_lab = ALABO, ref_source = REFSK, method_storage = METST,
      method_pretreat = METPT, method_pur_sep = METPS, method_chem_fix = METFP,
      method_chem_extract = METCX, method_analysis = METOA, formula_calc = FORML,
      
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sampler_type = SMTYP, factor_compli_interp = FINFL,
      
      analyt_method_ref = tblAnalysisID, measurement_ref = tblParamID,
      samp_ref = tblSampleID
    ) %>% 
    
    ## improve clarity of 'basis_determination' and 'matrix_analyzed' column content
    mutate(
      basis_determination = ifelse(
        basis_determination == "L", "lipid weight",
        ifelse(
          basis_determination == "W", "wet weight",
          ifelse(
            basis_determination == "D", "dry weight", NA
          )
        )
      ),
      matrix_analyzed = ifelse(
        matrix_analyzed == "LI", "liver",
        ifelse(
          matrix_analyzed == "MU", "muscle",
          ifelse(
            matrix_analyzed == "WO", "whole organism", NA
          )
        )
      )
    )
  return(df_vars_renamed)
}

## same names and structures so can apply function to all datasets
lapply(
  list("pcb_rawdata_bio", "pfos_rawdata_bio", "dioxin_rawdata_bio"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      mutate(sub_samp_ref = tblBioID)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
lapply(
  list("pcb_rawdata_sed", "dioxin_rawdata_sed"),
  function(x){
    renameddf <- rename_vars(get(x)) %>% 
      mutate(press_depth = DEPHU, depth_low = DEPHL)
    assign(str_remove(x, "_rawdata"), renameddf, envir = .GlobalEnv)
  }
)
```

---

<br>

#### 2.2.2 Standardize Units for Biota Data: PCB, Dioxin, PFOS

The main objective of the code below is to clean the biota datases set so the contain only values based on wet weight, in standardized units of ug/kg.
This includes the following pre-processing steps:
- remove flagged and deprecated data entries  
- separate 'b-bio' data from the other param group data ('oc-cb', 'oc-dx', or 'o-fl' for PCB, Dioxin, PFOS resp.) for use in lipid basis to wet weight conversion
- take averages where there are duplicate data samples, based on the sub_samp_ref value groupings  
- convert all congener concentration data to ug/kg and to wet weight 
- if data were presented in lipid weight, they were converted to wet weight by: $(\mbox{EXLIP%}/100)*(\mbox{CB conc. lipid weight})$

The datasets each contain two main categories (param_groups) one of which is BBIO. BBIO consists of variables with information about the sample like dry/lipid/wet weight percentage, age, weight and length. The second category contains the congeners concentration information. In stages, these are each manipulated separately and later rejoined by the measurement reference (measurement_ref) and and sub-sample (sub_samp_ref) ID numbers.

<br>

<!-- the following code chunks are modified from raw_data_prep.r scripts in bhi-1.0-archive/baltic2015/prep/CW/contaminants -->
```{r standardize units function}

biota_standardize <- function(biotadf, contam_param, rm_vars = NULL){
  
  ## what are the specific parameters?
  ## unique parameter groups and associated variables:
  chk_params <- biotadf %>% 
    select(param_group, variable) %>% 
    distinct() %>% 
    arrange(param_group, variable)
 
  ## filter and/or remove unneeded variables from data ----
  df <- biotadf %>% 
    ## remove 'suspect' and other non-'acceptable': https://vocab.ices.dk/?ref=58
    filter(!vflag %in% c("S", "C")) %>% 
    ## remove samples for liver tissue, keep muscle, and whole organism for length x weight
    filter(matrix_analyzed != "liver") %>% 
    ## remove certain variables-- summarized data or depreciated codes
    filter(!variable %in% rm_vars)
  
  ## align all measurements with sub_samp_ref (most unique besides measurement_ref)
  ## there are more unique measurement_ref but these are for different vars w/in sub_samp_id
  chk_ids <- lapply(
    list(
      df$bulk_id, 
      df$sub_samp_id, 
      df$samp_ref, 
      df$sub_samp_ref,
      df$measurement_ref
    ), 
    function(x){length(unique(x))}
  )
  ## check if any observations do not have sub_samp_ref
  if(nrow(df %>% filter(is.na(sub_samp_ref))) != 0){
    warning("there are observations without sub_samp_ref in the dataset")
  }
  
  ## BBIO DATA
  
  ## separate out bbio data for lipid to wet-weight conversion ----
  ## B-BIO variable code: http://vocab.ices.dk/?CodeID=51634
  ## b-bio data -- length, weight, fat and lipid content
  ## lipid content, etc. needed to convert lipid basis samples into the wet weight are in the B-BIO column
  df_bbio <- df  %>% 
    filter(param_group == "B-BIO") %>%
    select(
      station, latitude, longitude, date, year,
      sub_samp_id, 
      sub_samp_ref, samp_ref, measurement_ref,
      species, matrix_analyzed, basis_determination,
      variable, unit, value
    )
  
  ## BBIO DUPLICATES
  ## identify, explore, handle bbio duplicates ----
  ## group to identify duplicates; for a given sub_samp_ref only some variables may have duplicates
  grpvars <- c(
    "station", "date", "species", "variable", "matrix_analyzed", "sub_samp_ref",
    "latitude", "longitude", "year", "unit", "basis_determination", "samp_ref"
  )
  chk_bbio_dup <- c()
  for(i in 7:length(grpvars)){
    bbio_duplicates <- df_bbio %>% 
      group_by(!!!syms(grpvars[1:6]), !!!syms(grpvars[7:i])) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    chk_bbio_dup <- c(chk_bbio_dup, nrow(bbio_duplicates))
  }
  if(var(chk_bbio_dup) != 0){
    warning("issue with bbio duplicates: dataframe dims vary unexpectedly with ID variables")
  }
  
  ## join duplicate table by grouped vars to locate within full bbio dataset
  df_bbio <- left_join(df_bbio, bbio_duplicates, by = grpvars)
  
  ## take averages for variable/sample duplicates
  df_bbio <- bind_rows(
    ## averages of duplicates
    df_bbio %>% 
      filter(!is.na(n)) %>% 
      group_by(!!!syms(grpvars[1:6])) %>% 
      mutate(value = mean(value)) %>% 
      ungroup() %>% 
      select(-measurement_ref, -n) %>% 
      distinct(),
    
    ## rows of bbio data with no duplicates
    df_bbio %>% 
      filter(is.na(n)) %>% 
      select(-measurement_ref, -n)
  )
  
  ## check for unique variables and matrix_analyzed, per species
  chk_bbio_vars <- do.call(
    rbind, 
    lapply(
      as.list(unique(df_bbio$species)), 
      function(x){
        cbind(
          df_bbio %>% 
            filter(species == x) %>%
            select(matrix_analyzed, basis_determination, variable) %>% 
            distinct() %>% 
            arrange(variable),
          species = x
        )
      }
    )
  )
  chk_bbio_units <- df_bbio %>% 
    select(variable, unit) %>% 
    distinct()
  
  chk_exlip_matrix <- summary(as.factor(filter(df_bbio, variable == "EXLIP%")$matrix_analyzed))
  chk_exlip_basis <- summary(as.factor(filter(df_bbio, variable == "EXLIP%")$basis_determination))
  
  ## WIDE BBIO DATA
  ## bbio data wide format ----
  df_bbio_wide <- df_bbio %>%
    select(-unit) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value)
  
  ## which columns are needed to uniquely identify and later rejoin with congener conc. data
  ## i.e. at this stage, which give groupings such that n are greater than one?
  grpvars <- c(
    "sub_samp_ref", "sub_samp_id", "samp_ref", "date", 
    "longitude", "latitude", "station", "year", "species",
    "basis_determination", "matrix_analyzed"
  )
  # for(i in grpvars){print(paste(i, length(unique(df_bbio_wide[[i]]))))}
  ## sub_samp_id and samp_ref together are as unique as sub_samp_ref
  # nrow(select(df_bbio_wide, sub_samp_ref) %>% distinct())
  # nrow(select(df_bbio_wide, sub_samp_id, samp_ref) %>% distinct())
  
  chk_bbio_wide_ids <- grpvars
  for(i in 1:length(grpvars)){
    bbio_wide_duplicates <- df_bbio_wide %>% 
      group_by(!!!syms(setdiff(chk_bbio_wide_ids, grpvars[i]))) %>%
      summarise(n = n()) %>% 
      ungroup() %>% 
      filter(n > 1)
    if(nrow(bbio_wide_duplicates) == 0){
      chk_bbio_wide_ids <- setdiff(chk_bbio_wide_ids, grpvars[i])
    }
  }
  message(paste(
    "ID variables for later rejoining uniquely with congener data:", 
    paste(chk_bbio_wide_ids, collapse = ", ")
  ))
  
  
  ## CONGENER CONCENTRATIONS DATA
  ## check congener concentration data, units and duplicates ----
  
  contam_param <- substr(contam_param, str_length(contam_param) - 1, str_length(contam_param))
  
  df_conc <- df %>%
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      station, latitude, longitude, date, year, 
      sub_samp_ref, sub_samp_id, samp_ref, measurement_ref,
      species, matrix_analyzed, basis_determination,
      variable, unit, value, detect_lim, quant_lim
    )
  
  ## check whether variables vs units relationship is one-to-one
  chk_conc_units <- df_conc %>% 
    select(variable, unit) %>% 
    distinct() %>% 
    arrange(variable)
  
  ## convert congener concentration units all to ug/kg
  df_conc <- df_conc %>%
    left_join(
      read_csv(
        here::here("supplement", "lookup_tabs", "unit_conversion.csv"),
        col_types = cols()
      ) %>% filter(ConvertUnit == "ug/kg"),
      by = c("unit" = "OriginalUnit")
    ) %>% 
    mutate(
      value = value*ConvertFactor, 
      unit = "ug/kg",
      detect_lim = detect_lim*ConvertFactor
    ) %>% 
    select(-ConvertUnit, -ConvertFactor, -unit)
  
  ## take averages for congener conc. variable x sample duplicates ----
  
  idvars <- "list of id vars..."
  
  ## separate detect and quantification limit variables before next steps
  detect_quant_lims <- select(df_conc, idvars, detect_lim, quant_lim)

  ## spread df_conc data to wide format
  ## UNITS HAVE ALL BEEN CONVERTED TO MICROGRAMS PER KILOGRAM
  df_conc_wide <- df_conc %>%
    select(-unit, -detect_lim, -quant_lim) %>%
    group_by(!!!syms(idvars)) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    dplyr::rename(param_occb = param_group) %>%
    ungroup()
  
## remaining duplicates are due to dual wet/lipid weight records:
## of these, keep lipid weight records
pcb_bio_occb_duplicates3 <- pcb_bio_occb_wide %>% 
  group_by(station, date, species, sub_samp_ref) %>%
  summarise(n = n()) %>% 
  ungroup() %>% 
  filter(n > 1)
pcb_bio_occb_wide %>% filter(sub_samp_ref %in% pcb_bio_occb_duplicates3$sub_samp_ref)

pcb_bio_occb_wide <- pcb_bio_occb_wide %>% 
  select(-param_occb) %>% 
  filter(
    !(sub_samp_ref %in% pcb_bio_occb_duplicates3$sub_samp_ref & 
        basis_determination == "lipid weight")
  )
  
  
  
  ## check one row for every unique sub_samp_ref
  chk_conc_sub_samp <- length(unique(df_conc$sub_samp_ref)) == nrow(df_conc_wide %>% distinct())
  
  
  ## convert lipid weight measurements to wet weight ----
  ## use the df_bbio_wide datatable to convert values in df_conc_wide table
  df_final <- df_conc_wide %>% 
    left_join(df_bbio_wide, by = chk_bbio_wide_ids) %>% 
    tidyr::pivot_longer(
      cols = starts_with(contam_param), 
      names_to = "variable", 
      values_to = "value"
    ) %>% 
    left_join(detect_quant_lims, by = idvars) %>% 
    ## if value is not wet weight convert, otherwise keep value
    mutate(
      value_converted_ww = ifelse(
        basis_determination == "lipid weight", 
        value*(`EXLIP%`/100),
        ifelse(
          basis_determination == "dry weight",
          value*(`DRYWT%`),
          value
        )
      )
    )
  
  
  ## rejoin with meta information ----
  ## rejoin with info on country and monitoring program info, qflaugs, etc
  df_final <- df %>% 
    filter(str_detect(param_group, pattern = contam_param)) %>%
    select(
      country, monit_program, monit_purpose, 
      report_institute, station, 
      latitude, longitude, 
      date, monit_year, date_ices, day, month,
      species, num_indiv_subsample, 
      qflag, detect_lim, quant_lim, 
      uncert_val, method_uncert, 
      bulk_id, sub_samp_ref
    ) %>% 
  right_join(df_final, by = chk_bbio_wide_ids) %>% 
  mutate(qflagged = ifelse(is.na(qflag), FALSE, TRUE))
  
  
  ## return wrangled data and checks ----
  
  ## list of checks as part of result
  chks <- list(
    chk_params, chk_ids, 
    chk_bbio_vars, chk_bbio_units, 
    chk_exlip_matrix, chk_exlip_basis,
    chk_conc_units, chk_conc_sub_samp
  )
  
  df_final <- filter(df_final, !is.na(value))
  return(list(df_final, chks))
}
```

**START ORIGINAL PCB ANALYSIS...**


```{r PCBs biota - wrangle occb congener concentration data, echo = TRUE}
## OCCB DUPLICATES
## identify, explore, handle duplicates....
## group to identify duplicates, for a given sub_samp_ref only some vars/congeners may have duplicates
pcb_bio_occb_duplicates1 <- pcb_bio_occb %>% 
  group_by(station, date, species, variable, basis_determination, sub_samp_ref) %>%
  ## group includ. latitude, longitude, year, unit, matrix_analyzed, samp_id gives same
  summarise(n = n()) %>% 
  ungroup() %>% 
  filter(n > 1) # length(pcb_bio_occb_duplicates1$sub_samp_ref)
pcb_bio_occb_duplicates2 <- pcb_bio_occb %>% 
  group_by(station, date, species, variable, sub_samp_ref) %>%
  ## excluding basis_determination gives different result...
  summarise(n = n()) %>% 
  ungroup() %>% 
  filter(n > 1) # length(pcb_bio_occb_duplicates2$sub_samp_ref)
pcb_bio_occb_duplicates2 %>% 
  ## has both wet and lipid wgt for sub_samp_ref 3771406, 3771418, 3771427 CB118 & CB180
  filter(
    sub_samp_ref %in% setdiff(
      pcb_bio_occb_duplicates2$sub_samp_ref, 
      pcb_bio_occb_duplicates1$sub_samp_ref
  )) %>% 
  select(variable, sub_samp_ref) %>% 
  distinct()

pcb_bio_occb <- pcb_bio_occb %>% # join duplicate table by grouped vars to locate within full occb dataset
  left_join(
    pcb_bio_occb_duplicates1, 
    by = c("station", "date", "species", "variable", "basis_determination", "sub_samp_ref")
  )
tmp <- pcb_bio_occb %>%
  filter(!is.na(n)) %>% # filter and check the result
  arrange(date, sub_samp_ref, variable, measurement_ref)

## take averages for variable/sample duplicates
idvars <- c("station", "date", "species", "variable", "basis_determination", "matrix_analyzed", "sub_samp_ref")

pcb_bio_occb <- rbind(
  ## averages of duplicates
  pcb_bio_occb %>% 
      filter(!is.na(n)) %>%
      group_by(!!!syms(idvars)) %>% 
      mutate(
        value = mean(value), 
        detect_lim = mean(detect_lim, na.rm = TRUE), 
        quant_lim = any(quant_lim) # what if duplicates average to over/under quant lim?...
      ) %>% 
      ungroup() %>% 
      ## to keep only distinct rows, must deselect unique measurement_refs
      select(-measurement_ref) %>%
      distinct(),
  ## no-duplicates rows of occb data
  pcb_bio_occb %>% 
    filter(is.na(n)) %>% 
    select(-measurement_ref)
) %>% select(-n) 

```

<br>

**END ORIGINAL PCBs ANALYSIS**





```{r apply standardize function to datasets}
## wrangle PCBs dataset
pcb_bio_lst <- biota_standardize(
  pcb_bio, 
  contam_param = "OC-CB",
  ## remove PCB, SCB, SCB7 - these are summarized data or depreciated codes
  ## OC-CB variable codes: vocab.ices.dk/?CodeID=26983
  rm_vars = c("PCB", "SCB", "SCB7")
)
pcb_bio <- pcb_bio_lst$df

## wrangle dioxin dataset
dioxin_bio_lst <- biota_standardize(
  dioxin_bio, 
  contam_param = "OC-DX"
)
dioxin_bio <- dioxin_bio_lst$df

```
<br>

#### 2.2.3 Standardize Units for Sediment Data: PCB, Dioxin


---
<br>

#### 2.2.4 Save all Wrangled Data

```{r save cleaned datasets, echo = TRUE}
write_csv(
  pcb_bio_final, 
  here::here("data", "CW", "contaminants", version_year, "intermediate", "pcb_biota_cleaned.csv")
)
```

<br>

---

<br>

### 2.3 Initial Data Exploration

<br>

#### 2.3.1 Plots by Congener

```{r PCB biota dataset, echo = TRUE}
ggplot(pcb_bio_final) + 
  geom_point(aes(date, value, colour = qflagged), alpha = 0.2, size = 0.5, show.legend = FALSE) +
  facet_wrap(~congener, ncol = 6, scales = "free_y") + 
  labs(x = NULL, y = "Concentration ug/kg Wet Weight")

cols <- c(
  RColorBrewer::brewer.pal(8, "Dark2"), 
  RColorBrewer::brewer.pal(9, "Set1")
)
cols <- colorRampPalette(cols)(42)[sample(1:42)]

areaplotdf <- pcb_bio_final %>% 
  group_by(congener, month, year, country) %>% 
  summarize(Value = mean(value, na.rm = TRUE) %>% round(3)) %>% 
  ungroup() %>% 
  filter(year > 2000) %>% 
  tidyr::complete(month, year, country, congener, fill = list(Value = 0)) %>% 
  mutate(Date = as.Date(paste("1", month, year, sep = "-"), tryFormats = "%d-%m-%Y")) %>% 
  rename(Congener = congener, Year = year)

pcbs_plotly <- plotly::ggplotly(
  ggplot(areaplotdf) +
    geom_area(aes(Date, Value, fill = Congener), position = "stack", show.legend = FALSE) +
    scale_fill_manual(values = cols) +
    # facet_wrap(~country, scales = "free_y") +
    facet_grid(rows = vars(country), cols = vars(month), scales = "free_y") +
    labs(x = NULL, y = NULL)
)
pcbs_plotly$x$layout$legend$borderwidth <- 10
pcbs_plotly$x$layout$font$family <- "serif"
pcbs_plotly
```

```{r PCB sediment dataset}

```

```{r PFOS biota dataset}

```

```{r PFOS sediment dataset}

```

```{r Dioxin biota dataset}

```

```{r Dioxin sediment dataset}

```

<br> 

#### 2.3.2 Spatial Sampling Densities Map

```{r sampling maps}
bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile"), 
    layer = "BHI_shapefile",
    quiet = TRUE
  )) %>% sf::st_as_sf()

## mapping datasets for biota and sediments
make_mapdf <- function(x, y){
  cbind(
    get(x) %>% 
      filter(year > y) %>%
      group_by(month, latitude, longitude) %>%
      summarize(
        count_obs = n(), 
        num_congener = n_distinct(variable), 
        mean_val = mean(value, na.rm = TRUE), 
        sum_val = sum(value)
      ) %>%
      tidyr::pivot_longer(
        cols = c(mean_val, sum_val, count_obs, num_congener), 
        names_to = "metric", values_to = "value"
      ) %>%
      sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326, agr = "identity"),
    source = x)
}
mapdf_biota <- do.call(rbind, lapply(list("pcb_bio", "pfos_bio", "dioxin_bio"), function(x) make_mapdf(x, 2015)))
mapdf_sediment <- do.call(rbind, lapply(list("pcb_sed", "dioxin_sed"), function(x) make_mapdf(x, 2014)))

## basemap with baltic countries borders and BHI regions with ID numbers
basemap <- ggplot2::ggplot() + 
  geom_sf(
    data = rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
      st_crop(xmin = 0, xmax = 40, ymin = 53, ymax = 67),
    fill = "ivory", 
    size = 0.1
  ) +
  geom_sf(data = bhi_rgns_simple, fill = NA, size = 0.15, color = "grey40") +
  scale_x_continuous(limit = c(4, 32)) +
  scale_y_continuous(limit = c(53.5, 66)) +
  theme(
    panel.background = element_rect(fill = "#F8FBFC", color = "#E2EEF3")
  )

basemap + 
  geom_sf(
    aes(size = value, color = month), 
    alpha = 0.6, 
    shape = 19, 
    data = mapdf_biota %>% mutate(month = as.factor(month)),
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric))

basemap + 
  geom_sf(
    aes(size = value, color = month), 
    alpha = 0.6, 
    shape = 19, 
    data = mapdf_sediment %>% mutate(month = as.factor(month)),
    show.legend = FALSE
  ) +
  facet_grid(rows = vars(source), cols = vars(metric))
```

<br>
