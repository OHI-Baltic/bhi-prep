## Libraries
source(file.path(here::here(), "R", "common.R"))
library(tools)

## Functions

#' provide a link to the data prep github_document in readme
#'
#' @param dir path from project root to a goal or dimension subfolder of `prep` or `data`
#' @param prep_file file path starting where `dir` leaves off, to a specific data prep rmarkdown document (e.g. "v2019/ao_prep.rmd")
#'
#' @return no immediate output; result is the created readme

create_readme <- function(dir, prep_file) {
  if(dirname(dir) != here::here()){
    dir <- file.path(here::here(), dir)
    if(!file.exists(dir)){stop("cannot find that directory...specify either prep or data subfolder...")}
  }
  
  ## don't overwrite existing README.md!
  if(!file.exists(file.path(dir, "README.md"))) {
    
    ## create git urls
    repo <- "bhi-prep"
    w <- stringr::str_split(file.path(dir, prep_file), repo)[[1]][2]
    rawurl_goal <- sprintf("https://github.com/OHI-Science/%s/tree/master/ref/goal_summaries/%s.Rmd", 
                           repo, str_extract(w, pattern = "[A-Z]{2,3}"))
    rawurl_prep <- sprintf("https://github.com/OHI-Science/%s/tree/master%s.rmd", 
                           repo, tools::file_path_sans_ext(w))
    
    g <- read_csv(file.path(here::here(), "ref", "lookup_tabs", "bhi_goal_names.csv")) %>% 
      dplyr::filter(goal == str_extract(w, pattern = "[A-Z]{2,3}"))
    
    ## rewrite from readme_template.md
    tmp <- readLines(file.path(here::here(), "ref", "readme_template.md")) %>%
      stringr::str_replace("GOAL", sprintf("%s", g$name)) %>%
      stringr::str_replace("HERE1", sprintf("[here](%s)", rawurl_goal)) %>%
      stringr::str_replace("HERE2", sprintf("[here](%s)", rawurl_prep))
    # stringr::str_replace("DATA MANAGEMENT SOP", sprintf("[data management SOP](%s)", rawurl_prep)) %>% 
    if(is.na(str_extract(w, pattern = "[A-Z]{2,3}"))){ tmp <- tmp[-5]}
    writeLines(tmp, file.path(dir, "README.md"))
  }
}

#' update readmes for all prep folders
#' 
#' this function will update the readmes generated by the 'create_readme' function
#' @param version_year the assessment year with a preceeding "v", specified as a string
#' 
#' @return no immediate output; result is the revised readme

update_readmes <- function(version_year){
  dir <- here::here()
  
  ## directories where readmes need to be updated
  ## exclude dirs where readmes shouldn't be overwritten...
  update_where <- list.dirs(dir) %>% 
    grep(pattern = "/prep/|/data/", value = TRUE) %>% 
    grep(pattern = "prep/pressures$|data/pressures$|prep/spatial|data/spatial|CW$", 
         invert = TRUE, value = TRUE)
  update_where <- update_where[file.exists(file.path(update_where, "README.md"))]
  
  repo <- "bhi-prep"
  for(d in update_where){
    ## create git urls
    file <- list.files(file.path(d, version_year), pattern = "_data.rmd$|_prep.rmd$", full.names = TRUE)
    w <- stringr::str_remove(file, pattern = here::here())
    rawurl_goal <- sprintf("https://github.com/OHI-Science/%s/tree/master/ref/goal_summaries/%s.Rmd", 
                           repo, str_extract(w, pattern = "[A-Z]{2,3}"))
    rawurl_prep <- sprintf("https://github.com/OHI-Science/%s/tree/master%s.rmd", 
                           repo, tools::file_path_sans_ext(w))
    
    g <- read_csv(file.path(here::here(), "ref", "lookup_tabs", "bhi_goal_names.csv")) %>% 
      dplyr::filter(goal == str_extract(w, pattern = "[A-Z]{2,3}"))
    g1 <- ifelse(dim(g)[1] == 0, "Pressure or Resilience Dimensions", g$name)
    g2 <- ifelse(dim(g)[1] == 0, "pressure or resilience dimensions", paste("the", g$name, "goal"))
    
    ## rewrite from readme_template.md
    tmp <- readLines(file.path(here::here(), "ref", "readme_template.md")) %>%
      stringr::str_replace("GOAL1", sprintf("%s", g1)) %>%
      stringr::str_replace("GOAL2", sprintf("%s", g2)) %>%
      stringr::str_replace("METHODS", ifelse(
        substr(w, 2, 5) == "prep",
        "methods used to prepare data", 
        "routines for collecting and organizing data")) %>%
      stringr::str_replace("HERE1", sprintf("[here](%s)", rawurl_goal)) %>%
      stringr::str_replace("HERE2", sprintf("[here](%s)", rawurl_prep))
    # stringr::str_replace("DATA MANAGEMENT SOP", sprintf("[data management SOP](%s)", rawurl_prep)) %>% 
    if(is.na(str_extract(w, pattern = "[A-Z]{2,3}"))){ tmp <- tmp[-5]}
    writeLines(tmp, file.path(d, "README.md"))
  }
}


#' compile readme information associated with functions defined in a script
#'
#' written to generate readme content for functions in bhi/R scripts, but could be used elsewhere...
#'
#' @param bhiR_dir file path to the directory containing the script of interest
#' @param script_name the name of the script with functions you want readme documentation for
#'
#' @return text for readme content is returned in the console, but output is also configured as a character vector

bhiRfun_readme <- function(bhiR_dir, script_name){

  funs_text <- scan(file = file.path(bhiR_dir, script_name), what = "character", sep = "\n")

  funs_names <- funs_text %>%
    grep(pattern = "^[a-z_]+.*function.*", value = TRUE) %>%
    stringr::str_extract("^\\S+") %>%
    stringr::str_pad(width = str_length(.)+4, side = "both", pad = "*")
  funs_info <- funs_text %>%
    grep(pattern = "^#'\\s", value = TRUE) %>%
    stringr::str_remove_all("#' ")
  sep <- c(0, which(stringr::str_detect(funs_info, pattern = "@return|@return.*\n\n"))) # last roxygen element assumed @return... if have anything else after...

  out <- vector()
  if(length(sep) == length(funs_names)+1 & length(sep) > 1){

    for(i in 1:length(funs_names)){
      funs_doc <- c(funs_names[i], funs_info[(sep[i]+1):(sep[i+1])], "<br/>")
      cat(funs_doc, sep = " <br/> \n")
      out <- c(out, paste0(funs_doc, sep = " <br/>"))
    }
    return(out)

  } else { print("cannot parse... check script for missing roxygen documentation") }
}


#' generate basic readme outline
#'
#' look within a folder and create structure dependent on content and file tree
#' if has subfolders...
#' result not to be the end all be all, just a starting point or rough outline to start from
#' will still have to actually open and manually edit some fields, but readme_content function will help with that
#' describe_objects could be: file, table, folder, function, script
#'
#' could use `sink` function to write readme outline output directly to a specified readme file
#'
#' @param folder_filepath file path to folder where README will be located and which contains objects to document
#' @param type_objects character string with type of thing to document in the readme: folders, functions, files, tables, or scripts
#'
#' @return text for readme outline is printed to the console, and can be copied from there or sunk to a file

readme_outline <- function(folder_filepath, type_objects = "files", delim = ","){

  ## setup and extract file tree
  S <- .Platform$file.sep
  title <- basename(folder_filepath)

  tree <- list.files(folder_filepath, recursive = TRUE, full.names = TRUE) %>%
    gsub(pattern = folder_filepath, replacement = "")
  tree <- tree[tree != paste0(S, "README.md")]

  obj_info <- list()
  subtitles <- NULL
  general <- paste0(c("Created on:",
                      "Last modified on:",
                      "Used by or referenced in functions/scripts: <br/>\n\n"),
                    collapse = " <br/>\n") ## can change and include more/different fields later...

  ## if we want subfolders listed (with summary descriptions for each)
  if(type_objects == "folders"){
    obj_names <- tree[stringr::str_count(tree, pattern = S) >= 2] %>%
      stringr::str_extract(paste0("^", S, "[a-z0-9_]+", S)) %>%
      gsub(pattern = S, replacement = "") %>%
      unique() # non-empty immediately-adjacent subdirectories
    for(n in obj_names){
      obj_info[[n]] <- "add short description here"
    }
  }
  ## if we want all functions within a set of R scripts listed (with summary of what each does)
  if(type_objects == "functions"){
    subtitles <- tree[stringr::str_detect(tree, pattern = "\\.R")] %>%
      gsub(pattern = S, replacement = "")
    general <- vector() # for functions get rid of 'general' fields...
    for(s in subtitles){
      obj_names <- c(scan(file = file.path(folder_filepath, s),
                          what = "character", sep = "\n") %>%
                       grep(pattern = "^[a-z_]+.*function.*", value = TRUE) %>%
                       stringr::str_extract("^\\S+"))
      obj_info[[s]][["obj_names"]] <- list(obj_names)
    }
  }
  ## if we want each file listed (with summary of purpose and description of its contents)
  if(type_objects %in% c("files", "tables", "scripts")){
    tree <- tree[stringr::str_count(tree, pattern = S) < 2] # eliminate files in subdirectories
    obj_names <- basename(tree)[basename(tree) != "README.md"] %>%
      gsub(pattern = S, replacement = "")
    for(n in obj_names){
      obj_info[[n]] <- "add a short description here"
    }

    if(type_objects == "tables"){
      obj_names <- obj_names[grep(".csv$|.shp$", obj_names)]
      obj_info <- list() # ignore bit above about including description in obj_info...

      for(j in obj_names){
        if(stringr::str_detect(j, "\\.csv$")){ # for csv files
          if(delim == ","){
            tmp <- read.csv(file.path(folder_filepath, j), stringsAsFactors = FALSE)
          } else {
            tmp <- readr::read_delim(file.path(folder_filepath, j), delim = delim) %>%
              as.data.frame()
          }
        }
        if(stringr::str_detect(j, "\\.shp$")){ # for shapefiles; requires sf package
          tmp <- sf::st_read(folder_filepath, substr(j, 1, nchar(j)-4))
          st_geometry(tmp) <- NULL # get just table; coerces to dataframe
        }
        nms <- names(tmp) # names of columns in table
        cla <- vector() # classes of each attribute or column
        lvl <- vector() # levels or categories (or a place for descriptions)
        for(k in 1:ncol(tmp)){
          lvls <- ifelse(length(unique(tmp[, k])) < 10 & # these won't work if tmp is a tibble
                                 all(str_length(unique(tmp[, 1])) < 10),
                         paste(unique(tmp[, k]), collapse = ", "), "")
          cla <- c(cla, paste0("* ", nms[k], ": ", class(tmp[, k])))
          lvl <- c(lvl, paste0("* ", nms[k], ": ", paste(lvls, collapse = ", ")))
        }
        obj_info[[j]][["class"]] <- cla
        obj_info[[j]][["levels"]] <- lvl
      }
    }
  }
  ## put everything in order and print out
  t <- paste0("# `", title, "`") # title
  cat(t, "\n\n<br/>\n\n")
  out <- vector()
  for(i in names(obj_info)){
    line <- unlist(obj_info[[i]])
    if(i %in% subtitles){
      subt <- paste0("### ",
                    i %>% stringr::str_pad(width = str_length(.) + 2,
                                            side = "both", pad = "`"))
      line <- line %>% stringr::str_pad(width = str_length(.) + 4, side = "both", pad = "*")
    } else {
      subt <- paste0(i %>% stringr::str_pad(width = str_length(.) + 2,
                                    side = "both", pad = "`") %>%
                       stringr::str_pad(width = str_length(.) + 4,
                                        side = "both", pad = "*"))
    }
    cat(subt, "\n\n")
    cat(general)
    if(type_objects == "tables"){
      cat(paste0(line, collapse = " <br/>\n"),
          ifelse(length(line) == 0, "\n", " <br/>\n\n<br/>\n\n"))
    } else {
      cat(paste0(line, collapse = " <br/>\n\n<br/>\n\n"),
          ifelse(length(line) == 0, "<br/>\n\n", "<br/>\n\n<br/>\n\n"))
    }
    out <- c(out, subt, general, line)
  }
  out <- c(t, out)
  return(out)
}
